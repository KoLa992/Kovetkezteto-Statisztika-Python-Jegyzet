<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>2 Statisztikához szükséges Python nyelvi alapok | Következtető Statisztika Python Jegyzet</title>
  <meta name="description" content="<p>Lecture notes on BSc level Inferential Statistics in bookdown format.
Mainly for Business Information Systems BSc students at Corvinus University of Budapest.</p>" />
  <meta name="generator" content="bookdown 0.43 and GitBook 2.6.7" />

  <meta property="og:title" content="2 Statisztikához szükséges Python nyelvi alapok | Következtető Statisztika Python Jegyzet" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="<p>Lecture notes on BSc level Inferential Statistics in bookdown format.
Mainly for Business Information Systems BSc students at Corvinus University of Budapest.</p>" />
  <meta name="github-repo" content="KoLa992/Kovetkezteto-Statisztika-Python-Jegyzet" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="2 Statisztikához szükséges Python nyelvi alapok | Következtető Statisztika Python Jegyzet" />
  
  <meta name="twitter:description" content="<p>Lecture notes on BSc level Inferential Statistics in bookdown format.
Mainly for Business Information Systems BSc students at Corvinus University of Budapest.</p>" />
  

<meta name="author" content="Kovács László" />


<meta name="date" content="2025-06-24" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="index.html"/>
<link rel="next" href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Következtető Statisztika Python Jegyzet</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Előhang</a></li>
<li class="chapter" data-level="2" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html"><i class="fa fa-check"></i><b>2</b> Statisztikához szükséges Python nyelvi alapok</a>
<ul>
<li class="chapter" data-level="2.1" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#programozási-alapelvek"><i class="fa fa-check"></i><b>2.1</b> Programozási alapelvek</a></li>
<li class="chapter" data-level="2.2" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-pythonról-általában"><i class="fa fa-check"></i><b>2.2</b> A Pythonról általában</a></li>
<li class="chapter" data-level="2.3" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-spyder-felülete"><i class="fa fa-check"></i><b>2.3</b> A Spyder felülete</a></li>
<li class="chapter" data-level="2.4" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#working-directory"><i class="fa fa-check"></i><b>2.4</b> Working Directory</a></li>
<li class="chapter" data-level="2.5" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#alapvető-python-adattípusok-és-adatszerkezetek"><i class="fa fa-check"></i><b>2.5</b> Alapvető Python adattípusok és adatszerkezetek</a>
<ul>
<li class="chapter" data-level="2.5.1" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#egyszerű-adattípusok"><i class="fa fa-check"></i><b>2.5.1</b> Egyszerű adattípusok</a></li>
<li class="chapter" data-level="2.5.2" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#összetett-adatszerkezetek"><i class="fa fa-check"></i><b>2.5.2</b> Összetett adatszerkezetek</a></li>
<li class="chapter" data-level="2.5.3" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-numpy-tömb"><i class="fa fa-check"></i><b>2.5.3</b> A <code>numpy</code> tömb</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#vezérlési-szerkezetek"><i class="fa fa-check"></i><b>2.6</b> Vezérlési szerkezetek</a>
<ul>
<li class="chapter" data-level="2.6.1" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#elágazás-if"><i class="fa fa-check"></i><b>2.6.1</b> Elágazás (<code>if</code>)</a></li>
<li class="chapter" data-level="2.6.2" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#ciklusok-for"><i class="fa fa-check"></i><b>2.6.2</b> Ciklusok (<code>for</code>)</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-pandas-data-frame-objektum"><i class="fa fa-check"></i><b>2.7</b> A Pandas data frame objektum</a>
<ul>
<li class="chapter" data-level="2.7.1" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#hivatkozási-lehetőségek-data-frame-ben"><i class="fa fa-check"></i><b>2.7.1</b> Hivatkozási lehetőségek data frame-ben</a></li>
<li class="chapter" data-level="2.7.2" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#data-frame-k-módosítása"><i class="fa fa-check"></i><b>2.7.2</b> Data frame-k módosítása</a></li>
<li class="chapter" data-level="2.7.3" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#szűrés-data-frame-ben-logikai-indexszálás"><i class="fa fa-check"></i><b>2.7.3</b> Szűrés data frame-ben: logikai indexszálás</a></li>
<li class="chapter" data-level="2.7.4" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#hiányzó-értékek-kezelése-data-frame-ben"><i class="fa fa-check"></i><b>2.7.4</b> Hiányzó értékek kezelése data frame-ben</a></li>
<li class="chapter" data-level="2.7.5" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#adatvizualizáció-data-frame-en-keresztül"><i class="fa fa-check"></i><b>2.7.5</b> Adatvizualizáció data frame-en keresztül</a></li>
</ul></li>
<li class="chapter" data-level="2.8" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#aggregálás-data-frame-ben"><i class="fa fa-check"></i><b>2.8</b> Aggregálás data frame-ben</a></li>
<li class="chapter" data-level="2.9" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#egyszerű-leíró-statisztika-data-frame-ben"><i class="fa fa-check"></i><b>2.9</b> Egyszerű leíró statisztika data frame-ben</a></li>
<li class="chapter" data-level="2.10" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#adatminőségi-problémák-felismerése-és-kezelése-leíró-statisztika-segítségével"><i class="fa fa-check"></i><b>2.10</b> Adatminőségi problémák felismerése és kezelése leíró statisztika segítségével</a></li>
<li class="chapter" data-level="2.11" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#data-frame-k-összekapcsolása"><i class="fa fa-check"></i><b>2.11</b> Data frame-k összekapcsolása</a>
<ul>
<li class="chapter" data-level="2.11.1" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-kapcsolási-kulcsnak-használt-oszlop-ellenőrzése-és-javítása"><i class="fa fa-check"></i><b>2.11.1</b> A kapcsolási kulcsnak használt oszlop ellenőrzése és javítása</a></li>
</ul></li>
<li class="chapter" data-level="2.12" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#kilógó-értékek-keresése-és-kezelése"><i class="fa fa-check"></i><b>2.12</b> Kilógó értékek keresése és kezelése</a></li>
<li class="chapter" data-level="2.13" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#korrelációs-elemzések-data-frame-ben"><i class="fa fa-check"></i><b>2.13</b> Korrelációs elemzések data frame-ben</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#gyakorló-feladatok"><i class="fa fa-check"></i>Gyakorló feladatok</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#gyakorló-feladatok-megoldása"><i class="fa fa-check"></i>Gyakorló feladatok megoldása</a>
<ul>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat"><i class="fa fa-check"></i>1. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-1"><i class="fa fa-check"></i>2. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-2"><i class="fa fa-check"></i>3. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-3"><i class="fa fa-check"></i>4. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-4"><i class="fa fa-check"></i>5. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-5"><i class="fa fa-check"></i>6. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-6"><i class="fa fa-check"></i>7. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-7"><i class="fa fa-check"></i>8. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-8"><i class="fa fa-check"></i>9. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-9"><i class="fa fa-check"></i>10. feladat</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><i class="fa fa-check"></i><b>3</b> Leíró Statisztika ismétlés és Valószínűségszámítás alapok</a>
<ul>
<li class="chapter" data-level="3.1" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#leíró-statisztikai-mutatók"><i class="fa fa-check"></i><b>3.1</b> Leíró statisztikai mutatók</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#hisztogram-és-alakmutatók"><i class="fa fa-check"></i><b>3.1.1</b> Hisztogram és Alakmutatók</a></li>
<li class="chapter" data-level="3.1.2" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#gyakorisági-tábla-lekérése"><i class="fa fa-check"></i><b>3.1.2</b> Gyakorisági tábla lekérése</a></li>
<li class="chapter" data-level="3.1.3" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#gyakorisági-tábla-bővítése"><i class="fa fa-check"></i><b>3.1.3</b> Gyakorisági tábla bővítése</a></li>
<li class="chapter" data-level="3.1.4" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#súlyozott-átlag-és-szórás-pythonban"><i class="fa fa-check"></i><b>3.1.4</b> Súlyozott átlag és szórás Pythonban</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#a-normális-eloszlás-és-sűrűségfüggvénye"><i class="fa fa-check"></i><b>3.2</b> A normális eloszlás és sűrűségfüggvénye</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#a-sűrűségfüggvény-használata"><i class="fa fa-check"></i><b>3.2.1</b> A sűrűségfüggvény használata</a></li>
<li class="chapter" data-level="3.2.2" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#a-sűrűségfüggvény-integrálja"><i class="fa fa-check"></i><b>3.2.2</b> A sűrűségfüggvény integrálja</a></li>
<li class="chapter" data-level="3.2.3" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#valószínűség-vs-relatív-gyakoriság"><i class="fa fa-check"></i><b>3.2.3</b> Valószínűség vs Relatív Gyakoriság</a></li>
<li class="chapter" data-level="3.2.4" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#centrális-határeloszlás-tétel-cht"><i class="fa fa-check"></i><b>3.2.4</b> Centrális Határeloszlás Tétel (CHT)</a></li>
<li class="chapter" data-level="3.2.5" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#inverz-értékek"><i class="fa fa-check"></i><b>3.2.5</b> Inverz Értékek</a></li>
<li class="chapter" data-level="3.2.6" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#a-standard-normális-eloszlás"><i class="fa fa-check"></i><b>3.2.6</b> A Standard Normális Eloszlás</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#az-exponenciális-eloszlás"><i class="fa fa-check"></i><b>3.3</b> Az Exponenciális eloszlás</a></li>
<li class="chapter" data-level="3.4" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#a-varianciahányados-pythonban---kokain-a-balatonban"><i class="fa fa-check"></i><b>3.4</b> A Varianciahányados Pythonban - Kokain a Balatonban</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#további-minőségi-ismérvek-és-a-kokainmennyiség"><i class="fa fa-check"></i><b>3.4.1</b> További minőségi ismérvek és a kokainmennyiség</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Bookdownban szerkesztve.</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Következtető Statisztika Python Jegyzet</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="statisztikához-szükséges-python-nyelvi-alapok" class="section level1 hasAnchor" number="2">
<h1><span class="header-section-number">2</span> Statisztikához szükséges Python nyelvi alapok<a href="statisztikához-szükséges-python-nyelvi-alapok.html#statisztikához-szükséges-python-nyelvi-alapok" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="programozási-alapelvek" class="section level2 hasAnchor" number="2.1">
<h2><span class="header-section-number">2.1</span> Programozási alapelvek<a href="statisztikához-szükséges-python-nyelvi-alapok.html#programozási-alapelvek" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Mivel a Python egy programnyelv, így elengedhetetlen, hogy a használata előtt némi programozási alapvetésekkel tisztában legyünk.</p>
<p>Talán az már kijelenthetó, hogy közismert a tény, mi szerint a mai számítógépek alapvetően a Neumann-elvek szerint működnek.</p>
<p>A mi szempontunkból ez csak annyit jelent, hogy a számítógépet alapvetően <em>utasítások</em> végrehajtására használjuk programozás során: pl. számold ki ezt, vagy rajzold ki amazt. A programozás kihívása, hogy a gépállat felfogása nagyon nehéz, ezért az utasításokat nagyon konkrétan meg kell neki fogalmazni. Ehhez a megfogalmazáshoz adnak segítséget a különböző programnyelvek, így a Python is.</p>
<p>A Neumann-elvek szerint a programnyelven kiadott utasításokat a számítógépben a <em>processzor</em> (Central Processing Unit, CPU) hajtja végre. Ugyanakkor az utasítások végrehajtásához a gépnek adatokat is fejben kellhet tartania (mondjuk átlag számítás során nem árt tudnia milyen számok átlagát számoljuk ki). Ezeket az adatokat nem meglepő módon a <em>memóriájában</em> (Random Access Memory, RAM) tárolja a gép.
A gépállattal való kommunikációhoz szükségvan valami beviteli = input eszközre (billentyűzet, egér) és az utasítások eredményének megjelenítéséhez kell egy kimeneti = output eszköz (monitor) is.</p>
<p>És…ennyi! Alapvetően a modern számítógépek ennyi alkotóelemből állnak (a háttértár programozás szempontjából irreleváns).
Mindez egy cuki ábrán (a processzor belső felépítése minket jelenleg nem érdekel):</p>
<center>
<img src="neumann.png" style="width:50.0%" />
</center>
<p>Számítógép vásárlás szempontjából is alapvetően a CPU és a RAM határozza meg mennyire gyors a gép: minél nagyobb a CPU órajele (GHz) és minél több magja van, annál több utasítást tud végrehajtani a gép egy adott idő alatt, és minél nagyobb a RAM mérete (GB) annál több adatot tud egyszerre fejben tartani.
Talán nem ér minket meglepetésként, ha azt mondom, hogy a <em>statisztikai számítások alapvetően RAM igényesek</em> (mert sok adattal dolgoznak). 16-32 GB már kell, hogy komolyabb statisztikai modelleket gyorsan tudjunk futtatni egy valós vállalati adattáblán (ami általában több, mint 1 millió rekroddal és minimum 30-40 oszloppal = változóval rendelkezik).</p>
</div>
<div id="a-pythonról-általában" class="section level2 hasAnchor" number="2.2">
<h2><span class="header-section-number">2.2</span> A Pythonról általában<a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-pythonról-általában" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Az Python a jegyzet írásakor a legnépszerűbb általános célú programozási nyelv, 2024 januárjában a <a href="https://www.tiobe.com/tiobe-index/">TIOBE index</a> alapján a legtöbb sor programkódot Python nyelven írják a fejlesztők.</p>
<p>A mi szempontunkból a Python olyan szempontból vonzó, hogy a külső kiegészítő csomagjai segítségével a valószínűségszámítás, statisztika és általánosabb adatelemzés műveletei könnyen és gyorsan elvégezhetők a segítségével. Tehát a Python használható olyan matematikai, statisztikai modellezési és elemzési feladatok elvégzésére alkalmas szkriptnyelvként, mint például az <a href="https://cran.r-project.org/">R</a> vagy a <a href="https://www.mathworks.com/products/matlab.html">Matlab</a>. A Python előnye ezekkel a nyelvekkel szemben, hogy mivel általános célú programnyelv, így a matematikai-statisztikai számítások eredményei sokkal könnyebben integrálhatók egy üzleti célú alkalmazásba, ami mondjuk felhasználói felülettel rendelkezik.<br>
Ahogy az <em>Előhang</em>ban már jeleztem, a jegyzet kimondottan a Python statisztikai és adatelemzési funkcióinak alapszintű bemutatásával foglalkozik. Tehát alkalmazást fejleszteni itt nem fogunk, a Pythont szkriptnyelvként működtetjük: elküldjük a programkódban megírt számítási igényeinket a gépállatnak, és az visszaköpi a számítások eredményeit a képernyőre, és mi egyrészt gyönyörködünk bennük, másrészt értelmezzük az eredményeket. Viszont, jó tudni, hogy a Python az eredmények további felhasználására is képes programnyelv. Ebben több, mint egy matematikusi körökben szintén népszerű R vagy Matlab. Hátránya a felsorolt nyelvekkel szemben, hogy mivel általános célú programnyelv, és nem kimondottan a matematikai-statisztikai számításokra optimalizált, így számos számítás lekódolása sokkal körülményesebb Pythonban, mint R-ben vagy Matlabban. De hát <em>valamit valamiért</em>. :)</p>
<p>A Pythont, mi az <strong>Anaconda keretrendszer</strong>ből működtetjük, ami <a href="https://www.anaconda.com/products/distribution">innen letölthető</a>. Az Anaconda számos fejlesztőkörnyezetet biztosít a Python nyelvhez. Itt megjegyzendő, hogy a <strong>Python és a Python fejlesztőkörnyezete nem összekeverendő!</strong> A Python maga a programnyelv, amiben kódot írunk a számítógépünknek, hogy hajtsa végre, míg a fejlesztőkrönyezet az a program, amiben ezt a kódot megírjuk!<br>
Mi a Python kódjainkat <strong>Spyder fejlesztőkörnyezetben</strong> írjuk majd, mivel ez a fejlesztőkörnyezet az, ami leginkább a Python matematikai-statisztikai műveleteket végrehajtó, szkriptnyelv-szerű használatára van optimalizálva.</p>
<p>Miután telepítettük és elindítottuk az Anaconda keretrendszert, a kezdőképernyőről rögtön indíthatjuk is a Spydert:</p>
<center>
<img src="Anaconda.jpg" style="width:80.0%" />
</center>
</div>
<div id="a-spyder-felülete" class="section level2 hasAnchor" number="2.3">
<h2><span class="header-section-number">2.3</span> A Spyder felülete<a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-spyder-felülete" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>A Spyder fejlesztőkörnyezet indítása után az alábbihoz hasonló képernyőkép fogad minket:</p>
<center>
<img src="Spyder.jpg" style="width:90.0%" />
</center>
<p>A Python kódokat a Spyder-ben <em>.py</em> kiterjesztésű szkriptfájokban fogjuk írni.<br>
Egy ilyet az alább látható módon lehet létrehozni:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/cmIhl-w3us0" data-external="1" allowfullscreen>
</iframe>
</center>
<p>A szkriptfájlba írhatjuk a gépállatnak szóló utasításainkat Python nyelven. Az utasítások végrehajtását a Spyder felület felső részén lakó <img src="RunLine.jpg" /> gomb megtaposásával tudjuk kérni a géptől, aki az utasítás eredményét alul, a <em>Console</em> felületen köpi ki. Ekkor a Spyder mindig azt a Python utasítást hajtja végre a gomb megnyomásakor, amiben éppen a villogó kurzorral álltunk.
Egy példában számoltassuk ki a Pythonnal, hogy mennyi <span class="math inline">\(3+2\)</span>:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/uPdTUVb_GWE" data-external="1" allowfullscreen>
</iframe>
</center>
<p>Több utasítást is végre tudunk hajtatni a géppel egyszerre. Csak jelöljük ki a szkriptben a végrehajtandó utasításokat, és így kijelölés után tapossuk meg a Spyíder felső menüsorában található <img src="RunLine.jpg" /> gombot!
Egy utasítást több sorba is írhatunk, de egy új utasítás mindig új sorban kezdődjön! Érdemes egy üres sort is hagyni az előző utasítás vége után!</p>
<p>Számoltassunk akkor most ki a Pythonnal egyszerre két dolgot is: mennyi <span class="math inline">\(3+2\)</span> és mennyi <span class="math inline">\(3 \times 2\)</span>:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/gqIQ2_F05J4" data-external="1" allowfullscreen>
</iframe>
</center>
<p>Ezek után a jegyezetek további részében a feladatok elvégzéséhez szükséges Python kódrészleteket és azok eredményét az alábbi módon jelölöm:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb1-1" tabindex="-1"></a><span class="dv">3</span><span class="op">+</span><span class="dv">2</span></span></code></pre></div>
<pre><code>## 5</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb3-1" tabindex="-1"></a><span class="dv">3</span><span class="op">*</span><span class="dv">2</span></span></code></pre></div>
<pre><code>## 6</code></pre>
<p>Ha az összes <em>.py</em> fájlukban lévő kódot le szeretnénk futtatni abban a sorrendben, ahogy a fájlban szerepelnek, akkor a Spyder felső menüsorán a <img src="RunFile.jpg" /> gombot kell megütni. De vigyázzunk, ilyenkor a Python nem írja ki az utasításaink eredményét a konzolra, csak akkor, ha külön beágyazzuk őket egy <code>print</code> nevű extra utasítás zárójelei közé!</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb5-1" tabindex="-1"></a><span class="bu">print</span>(<span class="dv">3</span><span class="op">+</span><span class="dv">2</span>)</span></code></pre></div>
<pre><code>## 5</code></pre>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb7-1" tabindex="-1"></a><span class="bu">print</span>(<span class="dv">3</span><span class="op">*</span><span class="dv">2</span>)</span></code></pre></div>
<pre><code>## 6</code></pre>
<p>A művelet videón:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/-CHBmAiydu0" data-external="1" allowfullscreen>
</iframe>
</center>
</div>
<div id="working-directory" class="section level2 hasAnchor" number="2.4">
<h2><span class="header-section-number">2.4</span> Working Directory<a href="statisztikához-szükséges-python-nyelvi-alapok.html#working-directory" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Mielőtt belevágunk a Python mélyebb rejtelmeibe van még egy fontos dolog, amiről még szót kell ejteni: a <em>Working Directory</em> kérdéséről.
A <em>Working Directory</em> az a mappa, ahonnan a <em>pitonállat</em> alapértelmezés szerint minden fájlt innen akar a memóriába tölteni és ide akar visszaírni.
A Spyder jobb felső sarkában lévő részen lehet kiválasztani és beállítani, hogy melyik mappa legyen a <em>Working Directory</em>. Ezek után <strong>minden fájlunk alapból ide fog mentődni, és minden adattáblát ide rakjunk be, amivel majd a Pythonban dolgozni akarunk!</strong></p>
<p>A Spyder-ben alapértelmezett <em>Working Directory</em>-t is be tudunk állítani, ha elbandukolunk a <strong>Tools –&gt; Preferences –&gt; Current working directory</strong> menübe, és ott a <strong>Console directory / The following directory</strong> című résznél beállítjuk a kívánt fix mappát alapértelmezett <em>Working Directory</em>-nak.</p>
<p>Az egész alapértelmezett <em>Working Directory</em>-val kapcsolatos okfejtés működésben megnézhető a következő videón:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/s2yVZ5gtBm0" data-external="1" allowfullscreen>
</iframe>
</center>
</div>
<div id="alapvető-python-adattípusok-és-adatszerkezetek" class="section level2 hasAnchor" number="2.5">
<h2><span class="header-section-number">2.5</span> Alapvető Python adattípusok és adatszerkezetek<a href="statisztikához-szükséges-python-nyelvi-alapok.html#alapvető-python-adattípusok-és-adatszerkezetek" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Eddig a Pythonban csak utasításokat hajtattunk végre, de a memóriában (RAM-ban) nem tároltattunk el még vele semmit.<br>
Most itt az idő! Az utasítások eredményét a <code>=</code> szimbólummal tudjuk a memóriába valamilyen szimpatikus néven elmenteni.</p>
<div id="egyszerű-adattípusok" class="section level3 hasAnchor" number="2.5.1">
<h3><span class="header-section-number">2.5.1</span> Egyszerű adattípusok<a href="statisztikához-szükséges-python-nyelvi-alapok.html#egyszerű-adattípusok" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Mentsük el a 3+2 eredményét egy <code>összeg</code> névre hallgató R objektumba: <code>összeg = 3+2</code>. Az utasítás végrehajtásának hatására az <code>összeg</code> objektum megjelenik az Spyder <em>jobb felső</em> sarkában lévő résznél, a <em>Variable Explorer</em> fülön. (A Python alapjáraton karakterkészletben elég bő, így simán tudunk ékezetes objektumneveket is adni. De néha én a biztonság kedvéért megmaradok az ékezet nélküli elnevezéseknél. Öreg vagyok már, na! :)). A Spyder képernyőnek ezen a <em>Variable Explorer</em> részén látjuk mindig azt, hogy éppen milyen Python objektumok élnek a RAM-ban:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/5RaAzgu6380" data-external="1" allowfullscreen>
</iframe>
</center>
<p>A Python memória-objektumoknak több fajtája van. A legegyszerűbbek azok, amik csak egy értéket tartalmaznak (mint nekünk az előbb az <code>osszeg</code>). Ezeket szokás <strong>változó</strong>nak is hívni. Én nem szeretem ezt az elnevezést, mert keverhető a statisztikai értelemben vett változóval, ami mindig egy statisztikai megfigyelést leíró tulajdonságot/ismérvet jelent (pl. munkavállaló jövdeleme). Ennek ellenére én is gyakran használom a Python memória objektumokra a változó elnevezést. :)</p>
<p>A Python objektumoknak mindig van <strong>adattípusa</strong> is, ami <strong>leírja, hogy az adott objektumban számértékű, szöveges, dátum vagy valami egyéb jellegű adatot tárolunk-e</strong>. Ez azért marha fontos, mert az adattípustól függ, hogy mennyi hely szükséges a RAM-ban az objektum tárolásához. Érzésre megmondható talán, hogy egy szöveges adat tárolására több hely kell, mint egy egész szám tárolásához.</p>
<p>Az adattípusokat Pythonban a <code>type</code> névre hallgató <strong>beépített függvénnyel</strong> lehet lekérdezni.</p>
<p>Ezen a ponton érdemes megemlékezni arról, hogy a Pythonban léteznek <strong>függvényként működő beépített utasítások</strong> is. Ezek az úgynevezett Python függvények olyan utasítások, amik a matekban megszokott <span class="math inline">\(f(x)\)</span> függvény alakot veszik fel.<br>
A függvény neve leírja, hogy a függvény milyen műveletet végeztet el a gépállattal, és a zárójelek között pedig megadjuk, hogy milyen bemeneti paramétereken (adatokon) kell elvégezni a kijelölt műveletet. Pl. ilyen függvény volt már a <code>print</code> is.</p>
<p>Gyakorlati példaként lássuk akkor <strong>Python függvények</strong>re a <code>type</code> működését:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb9-1" tabindex="-1"></a>összeg <span class="op">=</span> <span class="dv">3</span><span class="op">+</span><span class="dv">2</span></span>
<span id="cb9-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb9-2" tabindex="-1"></a><span class="bu">type</span>(összeg)</span></code></pre></div>
<pre><code>## &lt;class &#39;int&#39;&gt;</code></pre>
<p>Ez a <code>type</code> nevű jószág azt csiripeli nekünk, hogy ez az <code>összeg</code> című változó egy <code>int</code> adattípusú, azaz <strong>egész szám</strong>, leánykori angolos nevén <code>integer</code>. Tehát, ha egy Python objektum <code>int</code> adattípusú, akkor az azt jelenti, hogy ő bezony csak egész számokat tud elképzelni a világban, tört számokat nem tud tárolni.</p>
<p>Törtszámok tárolására vannak a <code>float</code> adattípusú objektumok.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb11-1" tabindex="-1"></a>tört <span class="op">=</span> <span class="dv">3</span><span class="op">/</span><span class="dv">2</span></span>
<span id="cb11-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb11-2" tabindex="-1"></a><span class="bu">type</span>(tört)</span></code></pre></div>
<pre><code>## &lt;class &#39;float&#39;&gt;</code></pre>
<p>A Statisztika II. tárgyban a kétféle számítpus közti különbségnek nem igazán lesz jelentősége, de ha igazi <em>big data</em>-val foglalkozik az ember, akkor a RAM takarékosság miatt számít, hogy valami csak egy egész számnyi, vagy egy törtszámnyi helyet foglal sok-sok tizedeshellyel!</p>
<p>Néhány egyéb fontosabb adattípus és megadási módjuk:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb13-1" tabindex="-1"></a>szoveg <span class="op">=</span> <span class="st">&quot;Hello There!&quot;</span> <span class="co"># Figyeljünk rá, hogy szöveget a kódban csak idézőjelek közé rakjunk! Mint Excelben! :)</span></span>
<span id="cb13-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb13-2" tabindex="-1"></a><span class="bu">type</span>(szoveg)</span></code></pre></div>
<pre><code>## &lt;class &#39;str&#39;&gt;</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb15-1" tabindex="-1"></a>igazhamis <span class="op">=</span> <span class="va">True</span></span>
<span id="cb15-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb15-2" tabindex="-1"></a><span class="bu">type</span>(igazhamis) <span class="co"># a bool típusnak csak két értéke lehet: True vagy False</span></span></code></pre></div>
<pre><code>## &lt;class &#39;bool&#39;&gt;</code></pre>
<p>A fenti kódrészletben szereplő <strong>#</strong> jel a komment jele a Pythonban. A <strong>#</strong> mögötti részeket a gépállat nem fogja végrehajtani, olyan lesz neki, mintha ott sem lenne. Ezzel magunknak írhatunk a Python szkriptbe hasznos megjegyzéseket.</p>
<p>Az egyes adattípusok között tudunk konvertálni, ha van ennek van értelme. A konverzóra függvényeket tudunk használni, amik neve kivétel nélkül megegyezik azzal a kulcsszóval, amit a <code>type</code> függvény visszaad adattípusnak. Tehát a függvény, ami mondjuk az objektumot szöveggé, azaz stringgé konvertálja az <code>str</code> névre hallgat.</p>
<p>Tehát akkor számból tudunk szöveget csinálni:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb17-1" tabindex="-1"></a>szam <span class="op">=</span> <span class="dv">1992</span></span>
<span id="cb17-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb17-2" tabindex="-1"></a><span class="bu">type</span>(szam)</span></code></pre></div>
<pre><code>## &lt;class &#39;int&#39;&gt;</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb19-1" tabindex="-1"></a>nemszam <span class="op">=</span> <span class="bu">str</span>(szam)</span>
<span id="cb19-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb19-2" tabindex="-1"></a><span class="bu">type</span>(nemszam)</span></code></pre></div>
<pre><code>## &lt;class &#39;str&#39;&gt;</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb21-1" tabindex="-1"></a>nemszam</span></code></pre></div>
<pre><code>## &#39;1992&#39;</code></pre>
<p>Láthjatjuk, hogy amikor kiíratjuk a <code>nemszam</code> változót, akkor ott az <span class="math inline">\(1992\)</span> már aposztrófok között van, ami azt jelöli, hogy ez beza már szöveges, azaz <em>string</em> adat.</p>
<p>Olyan szövegből tudunk számot csinálni, aminek tartalma tényleg egy valid szám:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb23-1" tabindex="-1"></a>szöveg <span class="op">=</span> <span class="st">&quot;1992&quot;</span></span>
<span id="cb23-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb23-2" tabindex="-1"></a><span class="bu">type</span>(szöveg)</span></code></pre></div>
<pre><code>## &lt;class &#39;str&#39;&gt;</code></pre>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb25-1" tabindex="-1"></a>nemszöveg <span class="op">=</span> <span class="bu">int</span>(szöveg)</span>
<span id="cb25-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb25-2" tabindex="-1"></a><span class="bu">type</span>(nemszöveg)</span></code></pre></div>
<pre><code>## &lt;class &#39;int&#39;&gt;</code></pre>
<p>Tizedestörtekkel vigyázzunk! A <strong>Python angol lokalizációt feltételez mindig</strong>, így tizedes pontot kell alkalmazni! A tizedes vesszővel írt számot nem fogja felismerni, és hisztis hibaüzenetet dob. :( A <code>nemjo</code> változó pedig nem jön létre a memóriában.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb27-1" tabindex="-1"></a>nemjo <span class="op">=</span> <span class="bu">float</span>(<span class="st">&quot;3,14&quot;</span>)</span></code></pre></div>
<pre><code>## ValueError: could not convert string to float: &#39;3,14&#39;</code></pre>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb29-1" tabindex="-1"></a>nemjo</span></code></pre></div>
<pre><code>## NameError: name &#39;nemjo&#39; is not defined</code></pre>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb31-1" tabindex="-1"></a><span class="bu">type</span>(nemjo)</span></code></pre></div>
<pre><code>## NameError: name &#39;nemjo&#39; is not defined</code></pre>
<p>De ha a törtszám tizedes ponttal adott a string változóban, akkor az minden további nélkül <code>float</code> adattípusra konvertálható.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb33-1" tabindex="-1"></a>jo <span class="op">=</span> <span class="bu">float</span>(<span class="st">&quot;3.14&quot;</span>)</span>
<span id="cb33-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb33-2" tabindex="-1"></a>jo</span></code></pre></div>
<pre><code>## 3.14</code></pre>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb35-1" tabindex="-1"></a><span class="bu">type</span>(jo)</span></code></pre></div>
<pre><code>## &lt;class &#39;float&#39;&gt;</code></pre>
<p>Ha törtszámot (<code>float</code>) etetünk meg vacsorára az <code>int</code> függvénnyel, akkor annak az egészrészét veszi.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb37-1" tabindex="-1"></a>fura <span class="op">=</span> <span class="bu">int</span>(<span class="fl">3.14</span>)</span>
<span id="cb37-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb37-2" tabindex="-1"></a>fura</span></code></pre></div>
<pre><code>## 3</code></pre>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb39-1" tabindex="-1"></a><span class="bu">type</span>(fura)</span></code></pre></div>
<pre><code>## &lt;class &#39;int&#39;&gt;</code></pre>
<p>Pythonban a rosszul beállított adattípusokból születhet pár baleset. Íme a leggyakoribb példák.</p>
<p>A <code>+</code> két string között az összefűzést jelenti, így az alábbi kód tökéletesen működőképes.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb41-1" tabindex="-1"></a>szoveg1 <span class="op">=</span> <span class="st">&quot;Hello&quot;</span></span>
<span id="cb41-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb41-2" tabindex="-1"></a>szoveg2 <span class="op">=</span> <span class="st">&quot;There&quot;</span></span>
<span id="cb41-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb41-3" tabindex="-1"></a></span>
<span id="cb41-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb41-4" tabindex="-1"></a>szoveg1<span class="op">+</span>szoveg2</span></code></pre></div>
<pre><code>## &#39;HelloThere&#39;</code></pre>
<p>Viszont a string és integer összege nem értelmezhető, így hibaüzi lesz a vége…mily meglepő :)<br>
Ellenben a szorzatuk értelmes eredményt mutat: a stringet összefűzi annyiszor amennyi az integer típusú változó értéke!</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb43-1" tabindex="-1"></a>szoveg <span class="op">=</span> <span class="st">&quot;3&quot;</span></span>
<span id="cb43-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb43-2" tabindex="-1"></a>szam <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb43-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb43-3" tabindex="-1"></a></span>
<span id="cb43-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb43-4" tabindex="-1"></a>szoveg<span class="op">+</span>szam</span></code></pre></div>
<pre><code>## TypeError: can only concatenate str (not &quot;int&quot;) to str</code></pre>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb45-1" tabindex="-1"></a>szoveg<span class="op">*</span>szam</span></code></pre></div>
<pre><code>## &#39;3333&#39;</code></pre>
<p>Érdemes megnézni mi történik, ha egy stringként tárolt egész számot és egy integerként tárolt egész számot úgy “adunk össze” és “szorzunk össze”, hogy előtte a stringet integerré, vagy floattá konvertáljuk.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb47-1" tabindex="-1"></a>szoveg <span class="op">=</span> <span class="st">&quot;3&quot;</span></span>
<span id="cb47-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb47-2" tabindex="-1"></a>szam <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb47-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb47-3" tabindex="-1"></a></span>
<span id="cb47-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb47-4" tabindex="-1"></a><span class="bu">int</span>(szoveg)<span class="op">+</span>szam</span></code></pre></div>
<pre><code>## 7</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb49-1" tabindex="-1"></a><span class="bu">int</span>(szoveg)<span class="op">*</span>szam</span></code></pre></div>
<pre><code>## 12</code></pre>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb51-1" tabindex="-1"></a><span class="bu">float</span>(szoveg)<span class="op">+</span>szam</span></code></pre></div>
<pre><code>## 7.0</code></pre>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb53-1" tabindex="-1"></a><span class="bu">float</span>(szoveg)<span class="op">*</span>szam</span></code></pre></div>
<pre><code>## 12.0</code></pre>
<p>Ekkor igazából semmi galiba nem történik, minden szituáció értelmes eredményre vezet. Annyi, hogy amikor <code>float</code>-ra konvertáltuk a stringben tárolt egész számot, akkor az eredmény is <code>float</code> típusú objektum lesz. Ezt onnan látni a <code>type</code> függvény nélkül, hogy pl. a <code>float(szoveg)+szam</code> eredménye <span class="math inline">\(7.0\)</span> lesz a <code>int(szoveg)+szam</code>-féle <span class="math inline">\(7\)</span> helyett.</p>
<p>Viszont, ha a stringben egy tizedes törtet tárolok el (rendesen tizedes ponttal), akkor az már összeveszik az <code>int</code> függvénnyel, és ezekben a csillagálásokban hibát dob a pitonállat.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb55-1" tabindex="-1"></a>szoveg <span class="op">=</span> <span class="st">&quot;3.5&quot;</span></span>
<span id="cb55-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb55-2" tabindex="-1"></a>szam <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb55-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb55-3" tabindex="-1"></a></span>
<span id="cb55-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb55-4" tabindex="-1"></a>szoveg<span class="op">+</span>szam</span></code></pre></div>
<pre><code>## TypeError: can only concatenate str (not &quot;int&quot;) to str</code></pre>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb57-1" tabindex="-1"></a>szoveg<span class="op">*</span>szam</span></code></pre></div>
<pre><code>## &#39;3.53.53.53.5&#39;</code></pre>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb59-1" tabindex="-1"></a><span class="bu">int</span>(szoveg)<span class="op">+</span>szam</span></code></pre></div>
<pre><code>## ValueError: invalid literal for int() with base 10: &#39;3.5&#39;</code></pre>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb61-1" tabindex="-1"></a><span class="bu">int</span>(szoveg)<span class="op">*</span>szam</span></code></pre></div>
<pre><code>## ValueError: invalid literal for int() with base 10: &#39;3.5&#39;</code></pre>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb63-1" tabindex="-1"></a><span class="bu">float</span>(szoveg)<span class="op">+</span>szam</span></code></pre></div>
<pre><code>## 7.5</code></pre>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb65-1" tabindex="-1"></a><span class="bu">float</span>(szoveg)<span class="op">*</span>szam</span></code></pre></div>
<pre><code>## 14.0</code></pre>
<p>Ha egészrészt szeretnék venni a stringként tárolt törtszámomból, akkor az <code>int</code> alkalmazása előtt beza <code>float</code>-tá kell konvertálni.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb67-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb67-1" tabindex="-1"></a>szoveg <span class="op">=</span> <span class="st">&quot;3.5&quot;</span></span>
<span id="cb67-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb67-2" tabindex="-1"></a>szam <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb67-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb67-3" tabindex="-1"></a></span>
<span id="cb67-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb67-4" tabindex="-1"></a>szoveg<span class="op">+</span>szam</span></code></pre></div>
<pre><code>## TypeError: can only concatenate str (not &quot;int&quot;) to str</code></pre>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb69-1" tabindex="-1"></a>szoveg<span class="op">*</span>szam</span></code></pre></div>
<pre><code>## &#39;3.53.53.53.5&#39;</code></pre>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb71-1" tabindex="-1"></a><span class="bu">int</span>(<span class="bu">float</span>(szoveg))<span class="op">+</span>szam</span></code></pre></div>
<pre><code>## 7</code></pre>
<div class="sourceCode" id="cb73"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb73-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb73-1" tabindex="-1"></a><span class="bu">int</span>(<span class="bu">float</span>(szoveg))<span class="op">*</span>szam</span></code></pre></div>
<pre><code>## 12</code></pre>
<div class="sourceCode" id="cb75"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb75-1" tabindex="-1"></a><span class="bu">float</span>(szoveg)<span class="op">+</span>szam</span></code></pre></div>
<pre><code>## 7.5</code></pre>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb77-1" tabindex="-1"></a><span class="bu">float</span>(szoveg)<span class="op">*</span>szam</span></code></pre></div>
<pre><code>## 14.0</code></pre>
</div>
<div id="összetett-adatszerkezetek" class="section level3 hasAnchor" number="2.5.2">
<h3><span class="header-section-number">2.5.2</span> Összetett adatszerkezetek<a href="statisztikához-szükséges-python-nyelvi-alapok.html#összetett-adatszerkezetek" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="a-python-list" class="section level4 hasAnchor" number="2.5.2.1">
<h4><span class="header-section-number">2.5.2.1</span> A Python <code>list</code><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-python-list" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Egyszerre több értéket tartalmazó objektumot is fel tudunk venni a Python memóriájába, ha <code>[]</code> zárójelek között vesszővel felsoroljuk az eltárolandó értékeket. Ennek az objektumnak a neve <code>list</code>.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb79-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb79-1" tabindex="-1"></a>sokszam <span class="op">=</span> [<span class="fl">3.14</span>, <span class="fl">2.71</span>, <span class="dv">88</span>, <span class="dv">1234</span>]</span>
<span id="cb79-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb79-2" tabindex="-1"></a><span class="bu">type</span>(sokszam)</span></code></pre></div>
<pre><code>## &lt;class &#39;list&#39;&gt;</code></pre>
<p>Írassuk ki a teljes listát egyben az outputra!</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb81-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb81-1" tabindex="-1"></a>sokszam</span></code></pre></div>
<pre><code>## [3.14, 2.71, 88, 1234]</code></pre>
<p>Kérjük le a lista <span class="math inline">\(1.\)</span> és <span class="math inline">\(3.\)</span> elemeit! Egy elemet a listából a sorszámával tudunk kinyerni, ha ezt a sorszámot <code>[]</code> zárójelek között megadjuk. Ugyanakkor figyeljünk, hogy a Pitonállat <span class="math inline">\(0\)</span>-tól indexel! Azaz, az 1. elem a 0.; 2. az 1.; 3. a 2. és stb.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb83-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb83-1" tabindex="-1"></a>sokszam[<span class="dv">0</span>]</span></code></pre></div>
<pre><code>## 3.14</code></pre>
<div class="sourceCode" id="cb85"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb85-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb85-1" tabindex="-1"></a>sokszam[<span class="dv">2</span>]</span></code></pre></div>
<pre><code>## 88</code></pre>
<p>Nézzük meg az adattípusait is ezeknek a listaelemeknek.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb87-1" tabindex="-1"></a><span class="bu">type</span>(sokszam[<span class="dv">0</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;float&#39;&gt;</code></pre>
<div class="sourceCode" id="cb89"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb89-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb89-1" tabindex="-1"></a><span class="bu">type</span>(sokszam[<span class="dv">2</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;int&#39;&gt;</code></pre>
<p>Láthatjuk, hogy a lista megőrzi az elemeinek eredeti adattípusát. Tehát, a <span class="math inline">\(3.14\)</span> adattípusa <code>float</code>, míg a <span class="math inline">\(88\)</span>-é <code>int</code>. Ezzel sokat spórol a memóriánkon, hogy nem kényszeríti át a <span class="math inline">\(88\)</span>-at is <code>float</code>-ba az egységesség jegyében.</p>
<p>Ez a logika szövegekkel is működik. Ha felveszek egy szöveges értéket is a listába, akkor annak az adattípusa string, azaz <code>str</code> lesz. A számértékű adatok pedig maradnak annak rendje és módja szerint <code>float</code> és <code>int</code> típusban, ami éppen kell. :)</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb91-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb91-1" tabindex="-1"></a>sokszam_sokszoveg <span class="op">=</span> [<span class="dv">88</span>, <span class="dv">42</span>, <span class="st">&quot;Hello&quot;</span>, <span class="dv">1992</span>, <span class="dv">9</span>, <span class="st">&quot;There&quot;</span>, <span class="st">&quot;Friend&quot;</span>, <span class="dv">11</span>]</span>
<span id="cb91-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb91-2" tabindex="-1"></a></span>
<span id="cb91-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb91-3" tabindex="-1"></a><span class="bu">type</span>(sokszam_sokszoveg[<span class="dv">0</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;int&#39;&gt;</code></pre>
<div class="sourceCode" id="cb93"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb93-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb93-1" tabindex="-1"></a><span class="bu">type</span>(sokszam_sokszoveg[<span class="dv">2</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;str&#39;&gt;</code></pre>
<p>Kérjük le, hogy egy lista hány elemet tartalmaz. Ezt a <code>len</code> nevű függvény intézi nekünk.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb95-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb95-1" tabindex="-1"></a><span class="bu">len</span>(sokszam_sokszoveg)</span></code></pre></div>
<pre><code>## 8</code></pre>
<p>8 elemű a lista, szupszi!</p>
<p>Viszont, ezt az elemszám lekérdezést meg lehet oldani úgynevezett <strong>metódus</strong> segítségével is! A <strong>metódusok olyan függvények, amik egy konkrét memóriában élő objektumon hajtanak végre műveleteket</strong>. Ez a spéci logika a Python nyelvben úgy jelenik meg, hogy <strong>nem azt mondjuk</strong>, hogy <span class="math inline">\(f(x)\)</span> módon végrehajtom az <span class="math inline">\(f\)</span> műveletet az <span class="math inline">\(x\)</span> objektumon. Mint ahogy a <code>len(sokszam_sokszoveg)</code> is működik, **hanem úgy gondolkodunk, hogy <span class="math inline">\(x.f()\)</span> módon végrehajtjuk az <span class="math inline">\(x\)</span> objektumon az <span class="math inline">\(f\)</span> műveletet.<br>
Ez a gyakorlatban a <code>sokszam_sokszoveg</code> nevű lista elemszámának lekérdezésénél az alábbi módon működik.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb97-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb97-1" tabindex="-1"></a>sokszam_sokszoveg.<span class="fu">__len__</span>()</span></code></pre></div>
<pre><code>## 8</code></pre>
<p>Királyság, az eredmény így is tök <span class="math inline">\(8\)</span>. :) A legtöbb metódus nevében amúgy nincsenek ilyen hosszas <code>__</code> részek. Illetve, a metódusok zárójelei közé lehet majd egyéb paramétereket is írni, amik szabályozzák a metódus működését. Ilyen például a lista elemeinek sorbarendezési művelete.</p>
<p>Egy listát sorba rendezni ugyanis már csak metódussal tudunk, ami <code>sort</code> néven fut. Ezt kell elsütni a listánkon egy kis pontocskával megtámogatva.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb99-1" tabindex="-1"></a>sokszam.sort()</span>
<span id="cb99-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb99-2" tabindex="-1"></a>sokszam</span></code></pre></div>
<pre><code>## [2.71, 3.14, 88, 1234]</code></pre>
<p>Szépen növekvő sorban vannak már itt a számaink. Viszont BRÉKÓ van, mert a <code>sort</code> metódus <strong>felülírta az eredeti listát, tehát az értékek eredeti sorrendje elveszett!</strong> Ha <strong>szükségünk van az eredeti sorrendre</strong>, akkor beza <strong>másolatot kell készíteni az eredeti listából a rendezés előtt!</strong> Ezt a másolat készítést a <code>copy</code> metódussal tudjuk megtenni. Ha ezt nem alkalmazzuk, akkor a gépállat olyan szinten kezeli az új objektumot is, hogy mindent megcsinál vele, amit az eredetivel! Ha ezt a kapcsolatot a másolat és az eredeti objektum között <em>el akarjuk vágni</em>, akkor kell a <code>copy</code> metódus.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb101-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb101-1" tabindex="-1"></a>sokszam <span class="op">=</span> [<span class="fl">3.14</span>, <span class="fl">2.71</span>, <span class="dv">1234</span>, <span class="dv">88</span>]</span>
<span id="cb101-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb101-2" tabindex="-1"></a>sokszam_copy <span class="op">=</span> sokszam.copy()</span>
<span id="cb101-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb101-3" tabindex="-1"></a>sokszam.sort()</span>
<span id="cb101-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb101-4" tabindex="-1"></a>sokszam</span></code></pre></div>
<pre><code>## [2.71, 3.14, 88, 1234]</code></pre>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb103-1" tabindex="-1"></a>sokszam_copy</span></code></pre></div>
<pre><code>## [3.14, 2.71, 1234, 88]</code></pre>
<p>Láthatjuk, hogy a fenti példában minden oké, megvan az eredeti sorrend is a <code>sokszam_copy</code>-ban. De itt lentebb, ha lehagyom a <code>copy</code>-t, akkor GázGéza van!</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb105-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb105-1" tabindex="-1"></a>sokszam <span class="op">=</span> [<span class="fl">3.14</span>, <span class="fl">2.71</span>, <span class="dv">1234</span>, <span class="dv">88</span>]</span>
<span id="cb105-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb105-2" tabindex="-1"></a>sokszam_copy <span class="op">=</span> sokszam</span>
<span id="cb105-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb105-3" tabindex="-1"></a>sokszam.sort()</span>
<span id="cb105-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb105-4" tabindex="-1"></a>sokszam</span></code></pre></div>
<pre><code>## [2.71, 3.14, 88, 1234]</code></pre>
<div class="sourceCode" id="cb107"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb107-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb107-1" tabindex="-1"></a>sokszam_copy</span></code></pre></div>
<pre><code>## [2.71, 3.14, 88, 1234]</code></pre>
<p>Viszont, ha csökkenő és nem növekvő sorrendet akarok a listában, akkor azt a <code>sort</code> metódus zárójelei között, <strong>paraméterként tudom megadni</strong> <code>reverse=True</code> módon.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb109-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb109-1" tabindex="-1"></a>sokszam.sort(reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb109-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb109-2" tabindex="-1"></a>sokszam</span></code></pre></div>
<pre><code>## [1234, 88, 3.14, 2.71]</code></pre>
<p>Oké, ez működik! :) Azt, hogy egy metódusnak vagy általános függvénynek milyen paraméterei vannak, azt pl. a Python nyelv <a href="https://www.w3schools.com/python/ref_list_sort.asp">w3schools-on található online dokumentációjából</a> lehet kideríteni. Itt a metódus/függvény nevére kell rákeresni.<br>
Szép szóval azt szokás mondani, hogy a dokumentáció megadja, hogy az egyes Python függvényeket milyen paraméterezéssel (más néven argumentumokkal) lehet <em>meghívni</em>.</p>
<p>A sorbarendezés működik csak stringeket tartalmazó listára is.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb111-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb111-1" tabindex="-1"></a>soknév <span class="op">=</span> [<span class="st">&quot;Kovács&quot;</span>, <span class="st">&quot;László&quot;</span>, <span class="st">&quot;Balázsné&quot;</span>, <span class="st">&quot;Mócsai&quot;</span>, <span class="st">&quot;Andrea&quot;</span>, <span class="st">&quot;Musa&quot;</span>]</span>
<span id="cb111-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb111-2" tabindex="-1"></a></span>
<span id="cb111-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb111-3" tabindex="-1"></a>soknév.sort()</span>
<span id="cb111-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb111-4" tabindex="-1"></a>soknév</span></code></pre></div>
<pre><code>## [&#39;Andrea&#39;, &#39;Balázsné&#39;, &#39;Kovács&#39;, &#39;László&#39;, &#39;Musa&#39;, &#39;Mócsai&#39;]</code></pre>
<div class="sourceCode" id="cb113"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb113-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb113-1" tabindex="-1"></a>soknév.sort(reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb113-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb113-2" tabindex="-1"></a>soknév</span></code></pre></div>
<pre><code>## [&#39;Mócsai&#39;, &#39;Musa&#39;, &#39;László&#39;, &#39;Kovács&#39;, &#39;Balázsné&#39;, &#39;Andrea&#39;]</code></pre>
<p>Ellenben, ha a listában vegyesen vannak stringek és valami számértéket jelölő adattípusok (<code>int</code> és <code>float</code>), akkor a rendezés vége egy szép kis hibaüzenet lesz.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb115-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb115-1" tabindex="-1"></a>sokszam_sokszoveg <span class="op">=</span> [<span class="dv">88</span>, <span class="dv">42</span>, <span class="st">&quot;Hello&quot;</span>, <span class="dv">1992</span>, <span class="dv">9</span>, <span class="st">&quot;There&quot;</span>, <span class="st">&quot;Friend&quot;</span>, <span class="dv">11</span>]</span>
<span id="cb115-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb115-2" tabindex="-1"></a>sokszam_sokszoveg.sort()</span></code></pre></div>
<pre><code>## TypeError: &#39;&lt;&#39; not supported between instances of &#39;str&#39; and &#39;int&#39;</code></pre>
<p>Na ezt a rendezősdit vegyes adattípusokon már tényleg nem érti a gépállat!<br>
Tanulság: rendezés esetén nem iszunk kevertet! :)</p>
<p>Nézzük meg hogyan tudunk több, mint 1 elemet kiválasztani a listákból!</p>
<p>Kérjünk le minden elemet 2-től 4-ig. Ezt úgy tudjuk megtenni, hogy a lista neve után <code>[]</code> zárójelek között <code>:</code>-tal elválasztva megadjuk a kiválasztás kezdeti és végső sorszámát: <code>kezdet:vége</code>. Azonban <strong>vigyázzunk!</strong> A <strong>kezdeti végpontot zárt, a végsőt nyílt</strong> intervallumként értelmezi a Pitonállat! Tehát ennek szellemében, ha figyelembe vesszük a <span class="math inline">\(0\)</span>-val kezdődő indexszálást is, akkor a 2-től 4-ig tartó listaelemeket <code>(2-1):4 = 1:4</code> módon kell megadni.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb117-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb117-1" tabindex="-1"></a>sokszam_sokszoveg[<span class="dv">1</span>:<span class="dv">4</span>]</span></code></pre></div>
<pre><code>## [42, &#39;Hello&#39;, 1992]</code></pre>
<p>A hecc kedvéért nézzük meg mit ad vissza gépállat, ha nem létező elemet kérünk le.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb119-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb119-1" tabindex="-1"></a>sokszam_sokszoveg[<span class="dv">9</span>]</span></code></pre></div>
<pre><code>## IndexError: list index out of range</code></pre>
<p>Csak, hogy emlékezzünk arra, hogy az <code>IndexError: list index out of range</code> hibaüzenet nem létező listelem kiválasztását jelenti. :)</p>
</div>
<div id="a-python-dictionary" class="section level4 hasAnchor" number="2.5.2.2">
<h4><span class="header-section-number">2.5.2.2</span> A Python <code>Dictionary</code><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-python-dictionary" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>A Python <code>Dictionary</code> típusú (<code>dict</code>) objektuma nemes egyszerűséggel egy olyan <code>list</code>, amiben <strong>szöveges kulcsokkal és nem sorszámmal indexeljük a listaelemeket</strong>.</p>
<p>Létrehozni az értékek és a szöveges azonosítók (azaz kulcsok) megadásával tudjuk <code>"kulcs" : "érték"</code> módon <code>{}</code> zárójelek között.</p>
<p>Hozzunk létre egy <code>Laci</code> nevű <code>dict</code>-et, ami tartalmazza Laci 3 legfontosabb ismérvét: vezeték- és keresztnevét, valamint születési évét.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb121-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb121-1" tabindex="-1"></a>Laci <span class="op">=</span> {<span class="st">&quot;vezetek&quot;</span>: <span class="st">&quot;Kovács&quot;</span>,</span>
<span id="cb121-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb121-2" tabindex="-1"></a><span class="st">&quot;kereszt&quot;</span>: <span class="st">&quot;László&quot;</span>,</span>
<span id="cb121-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb121-3" tabindex="-1"></a><span class="st">&quot;year&quot;</span>: <span class="dv">1992</span>}</span>
<span id="cb121-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb121-4" tabindex="-1"></a>Laci</span></code></pre></div>
<pre><code>## {&#39;vezetek&#39;: &#39;Kovács&#39;, &#39;kereszt&#39;: &#39;László&#39;, &#39;year&#39;: 1992}</code></pre>
<div class="sourceCode" id="cb123"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb123-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb123-1" tabindex="-1"></a><span class="bu">type</span>(Laci)</span></code></pre></div>
<pre><code>## &lt;class &#39;dict&#39;&gt;</code></pre>
<p>Kérjük le a 2. elemet a szótárból.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb125-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb125-1" tabindex="-1"></a>Laci[<span class="dv">1</span>]</span></code></pre></div>
<pre><code>## KeyError: 1</code></pre>
<p>Teljesen jogosan nyávog a pitonkénk, hogy ezt nem érti, hiszen itt a 2. elem nem értelmezhető, mivel nem sorszámmal azonosíthatók a szótár elemei.</p>
<p>De ezt az alábbi hivatkozást a szöveges kulcson keresztül érteni fogja.</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb127-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb127-1" tabindex="-1"></a>Laci[<span class="st">&quot;kereszt&quot;</span>]</span></code></pre></div>
<pre><code>## &#39;László&#39;</code></pre>
<p>Milyenek az adattípusok?</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb129-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb129-1" tabindex="-1"></a><span class="bu">type</span>(Laci[<span class="st">&quot;vezetek&quot;</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;str&#39;&gt;</code></pre>
<div class="sourceCode" id="cb131"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb131-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb131-1" tabindex="-1"></a><span class="bu">type</span>(Laci[<span class="st">&quot;kereszt&quot;</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;str&#39;&gt;</code></pre>
<div class="sourceCode" id="cb133"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb133-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb133-1" tabindex="-1"></a><span class="bu">type</span>(Laci[<span class="st">&quot;year&quot;</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;int&#39;&gt;</code></pre>
<p>Nagyszerű! Mint a listában, minden elem őrzi szépen az eredeti adattípusát. :)</p>
</div>
</div>
<div id="a-numpy-tömb" class="section level3 hasAnchor" number="2.5.3">
<h3><span class="header-section-number">2.5.3</span> A <code>numpy</code> tömb<a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-numpy-tömb" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Nekünk azért jó, mert úgy van optimalizálva ez az adatszerkezet, hogy az elemein a <strong>statisztikai számítások</strong> (átlag, medián, szórás, stb.) <strong>nagy adattömegen is gyorsan</strong> fussanak!</p>
<p>Ehhez már külön csomag kell, ami <code>numpy</code> névre hallgat.</p>
<p>Külső csomagokat a Pythonhoz a <code>pip install</code> utasítás segítségével tudunk telepíteni. A <code>numpy</code> csomagot tehát a következő kóddal lehet felvarázsolni Pitonkánknak.</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb135-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb135-1" tabindex="-1"></a>pip install numpy</span></code></pre></div>
<p>Ezt a <strong>fenti kódot csak egyszer kell lefutatni</strong>, utána a Python mindig <strong>emlékezni fog van már neki egy <code>numpy</code> névre hallgató kiegészítő csomagja</strong>.</p>
<p>Viszont, a <strong>következő kódot mindig futtassuk le mielőtt egy kódban a <code>numpy</code> csomagot használni akarjuk!</strong></p>
<div class="sourceCode" id="cb136"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb136-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb136-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
<p>Minden <code>numpy</code> függvényt a fenti kódsor miatt egy <code>np</code> előtaggal tudunk majd csak használni. Szakkifejezéssel élve, a fenti kódsorral a <code>numpy</code> függvényeket az <code>np</code> <strong>névtér</strong>be töltöttük be a gépállat számára <em>úgymond</em>.</p>
<p>Hozzunk is létre <code>numpy</code> tömböt! Ezt úgy tudjuk megtenni, hogy egy <code>[]</code> zárójelekkel létrehozott listát berakunk egy az <code>np</code> névtérben lakó <code>array</code> nevű függvény zárójelei közé.</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb137-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb137-1" tabindex="-1"></a>tömböcske <span class="op">=</span> np.array([<span class="fl">3.14</span>, <span class="fl">2.67</span>, <span class="dv">88</span>, <span class="dv">1234</span>])</span>
<span id="cb137-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb137-2" tabindex="-1"></a><span class="bu">type</span>(tömböcske)</span></code></pre></div>
<pre><code>## &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre>
<div class="sourceCode" id="cb139"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb139-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb139-1" tabindex="-1"></a>tömböcske</span></code></pre></div>
<pre><code>## array([   3.14,    2.67,   88.  , 1234.  ])</code></pre>
<p>Láthatjuk is, hogy a <code>tömböcske</code> adattípusa <code>numpy</code>-féle <code>ndarray</code>, azaz tömb. :)</p>
<p>Egy <code>numpy</code> tömböt amúgy lehet már létező listából történő klónozással is létrehozni, szintén az <code>np.array</code> függvénnyel.</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb141-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb141-1" tabindex="-1"></a>sokszam <span class="op">=</span> [<span class="fl">3.14</span>, <span class="fl">2.67</span>, <span class="dv">88</span>, <span class="dv">1234</span>]</span>
<span id="cb141-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb141-2" tabindex="-1"></a>tömböcske <span class="op">=</span> np.array(sokszam)</span>
<span id="cb141-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb141-3" tabindex="-1"></a><span class="bu">type</span>(tömböcske)</span></code></pre></div>
<pre><code>## &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre>
<div class="sourceCode" id="cb143"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb143-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb143-1" tabindex="-1"></a>tömböcske</span></code></pre></div>
<pre><code>## array([   3.14,    2.67,   88.  , 1234.  ])</code></pre>
<p>Az elemek kiválasztása szerencsénkre ugyanúgy megy, mint <code>list</code>-ben.</p>
<p>Pl. az első és negyedik elemek lekérdezése az alábbi.</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb145-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb145-1" tabindex="-1"></a>tömböcske[<span class="dv">0</span>]</span></code></pre></div>
<pre><code>## 3.14</code></pre>
<div class="sourceCode" id="cb147"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb147-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb147-1" tabindex="-1"></a>tömböcske[<span class="dv">3</span>]</span></code></pre></div>
<pre><code>## 1234.0</code></pre>
<p>Másodiktól Negyedik elemig történő kiválasztás.</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb149-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb149-1" tabindex="-1"></a>tömböcske[<span class="dv">1</span>:<span class="dv">4</span>]</span></code></pre></div>
<pre><code>## array([   2.67,   88.  , 1234.  ])</code></pre>
<p>És itt olyat is lehet, hogy csak a 2. és 4. elemet szedjük ki! A sima <code>list</code> ezt pl. nem igazán tudja! Ehhez az kell, hogy a kiválasztott sorszámokat egy <code>list</code>-ként, <code>[]</code> zárójelekkel létrehozva adjuk meg az indexszeléshez használt szögletes zárójelek között!</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb151-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb151-1" tabindex="-1"></a>tömböcske[[<span class="dv">1</span>,<span class="dv">3</span>]]</span></code></pre></div>
<pre><code>## array([   2.67, 1234.  ])</code></pre>
<p>Tehát, a fenti példában azért van <code>[[]]</code> használat, mert a külső <code>[]</code> a tömb indexelése miatt van, a belső <code>[]</code> pedig a kiválasztott sorszámok listája miatt kerül a képbe.</p>
<p>De mik itt az egyes elemek adattípusai? Lessük meg őket!</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb153-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb153-1" tabindex="-1"></a>tömböcske[<span class="dv">0</span>]</span></code></pre></div>
<pre><code>## 3.14</code></pre>
<div class="sourceCode" id="cb155"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb155-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb155-1" tabindex="-1"></a>tömböcske[<span class="dv">3</span>]</span></code></pre></div>
<pre><code>## 1234.0</code></pre>
<div class="sourceCode" id="cb157"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb157-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb157-1" tabindex="-1"></a><span class="bu">type</span>(tömböcske[<span class="dv">0</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;numpy.float64&#39;&gt;</code></pre>
<div class="sourceCode" id="cb159"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb159-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb159-1" tabindex="-1"></a><span class="bu">type</span>(tömböcske[<span class="dv">3</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;numpy.float64&#39;&gt;</code></pre>
<p><strong>BRÉKÓ! A <code>numpy</code> tömbök elemeinek mindig azonos adattípusúnak kell lenniük!</strong> Ha alapból nem azok, akkor a gépállat átkonvertál mindent a legáltalánosabb adattípusra. Az <code>int</code>ek és <code>float</code>ok esetében ez a törtszámokat is elviselő <code>float</code>.</p>
<p>Ellenben ha van szöveg is a dologban…</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb161-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb161-1" tabindex="-1"></a>szöveges_tömb <span class="op">=</span> np.array(sokszam_sokszoveg)</span>
<span id="cb161-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb161-2" tabindex="-1"></a><span class="bu">type</span>(szöveges_tömb)</span></code></pre></div>
<pre><code>## &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre>
<div class="sourceCode" id="cb163"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb163-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb163-1" tabindex="-1"></a>szöveges_tömb</span></code></pre></div>
<pre><code>## array([&#39;88&#39;, &#39;42&#39;, &#39;Hello&#39;, &#39;1992&#39;, &#39;9&#39;, &#39;There&#39;, &#39;Friend&#39;, &#39;11&#39;],
##       dtype=&#39;&lt;U11&#39;)</code></pre>
<div class="sourceCode" id="cb165"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb165-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb165-1" tabindex="-1"></a><span class="bu">type</span>(szöveges_tömb[<span class="dv">0</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;numpy.str_&#39;&gt;</code></pre>
<div class="sourceCode" id="cb167"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb167-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb167-1" tabindex="-1"></a><span class="bu">type</span>(szöveges_tömb[<span class="dv">2</span>])</span></code></pre></div>
<pre><code>## &lt;class &#39;numpy.str_&#39;&gt;</code></pre>
<p>…akkor bizony a legáltalánosabb adattípus, amit minden elem megörököl az a string, vagyis <code>str</code>!</p>
</div>
</div>
<div id="vezérlési-szerkezetek" class="section level2 hasAnchor" number="2.6">
<h2><span class="header-section-number">2.6</span> Vezérlési szerkezetek<a href="statisztikához-szükséges-python-nyelvi-alapok.html#vezérlési-szerkezetek" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="elágazás-if" class="section level3 hasAnchor" number="2.6.1">
<h3><span class="header-section-number">2.6.1</span> Elágazás (<code>if</code>)<a href="statisztikához-szükséges-python-nyelvi-alapok.html#elágazás-if" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Az elágazások arra az esetre vannak, ha <strong>bizonyos utasításokat a kódunkban csak akkor akarunk végrehajtani, ha előtte valamiféle logikai feltétel teljesül</strong>.</p>
<p>Például, ha egy egész szám nagyobb, mint <span class="math inline">\(10\)</span> kiírjuk, hogy ‘<em>Hatalmas</em>’.</p>
<p>Vagyis létrehozunk egy új változót <code>szam</code> néven, megnézzük, hogy az értéke nagyobb-e mint <span class="math inline">\(10\)</span>, és ha igen, akkor egy <code>print</code> függvénnyel kiírjuk tényleg a ‘<em>Hatalmas</em>’ szócskát.<br>
Mindez Pitonul az alábbi módon néz ki.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb169-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb169-1" tabindex="-1"></a>szam <span class="op">=</span> <span class="dv">13</span></span>
<span id="cb169-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb169-2" tabindex="-1"></a></span>
<span id="cb169-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb169-3" tabindex="-1"></a><span class="cf">if</span> szam <span class="op">&gt;</span> <span class="dv">10</span>:</span>
<span id="cb169-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb169-4" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">&quot;Hatalmas&quot;</span>)</span></code></pre></div>
<pre><code>## Hatalmas</code></pre>
<p>Mivel a számunk <span class="math inline">\(13\)</span> volt, és <span class="math inline">\(13&gt;10\)</span>, így ki lett írva, hogy ‘<em>Hatalmas</em>’. De ha a számnak <span class="math inline">\(8\)</span>-at adunk meg, akkor értelemszerűen nincs kiírás.</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb171-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb171-1" tabindex="-1"></a>szam <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb171-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb171-2" tabindex="-1"></a></span>
<span id="cb171-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb171-3" tabindex="-1"></a><span class="cf">if</span> szam <span class="op">&gt;</span> <span class="dv">10</span>:</span>
<span id="cb171-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb171-4" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">&quot;Hatalmas&quot;</span>)</span></code></pre></div>
<p>Azt figyeljük meg a fenti két kódrészletben, hogy a vizsgálandó logikai feltételt egy <code>if</code> kulcsszóval adjuk meg, majd utána egy <code>:</code>-ot írunk, és a feltétel esetén futtatandó kódot egy TAB billentyűs behúzással kezdjük a következő sorban.</p>
<p><strong>Figyelem!</strong> Ha <strong>nincs behúzás, akkor a pitonka mindenképp végrehajtja az utasítást, ami következik</strong> az <code>if</code>-el kezdődő sor után!</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb172-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb172-1" tabindex="-1"></a>szam <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb172-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb172-2" tabindex="-1"></a></span>
<span id="cb172-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb172-3" tabindex="-1"></a><span class="cf">if</span> szam <span class="op">&gt;</span> <span class="dv">10</span>:</span>
<span id="cb172-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb172-4" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">&quot;Hatalmas&quot;</span>)</span>
<span id="cb172-5"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb172-5" tabindex="-1"></a></span>
<span id="cb172-6"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb172-6" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Ezt mindenképp kiírjuk!&quot;</span>)</span></code></pre></div>
<pre><code>## Ezt mindenképp kiírjuk!</code></pre>
<p>Még olyat is tudunk csinálni egy <code>else</code> kulcsszóval, hogy ha az <code>if</code>-ben megadott logikai feltétel nem teljesül akkor is kiírunk valamit. Pl. most a feltétel nem teljesülése esetén írjuk ki azt, hogy ‘<em>Törpe</em>’</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb174-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb174-1" tabindex="-1"></a>szam <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb174-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb174-2" tabindex="-1"></a></span>
<span id="cb174-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb174-3" tabindex="-1"></a><span class="cf">if</span> szam <span class="op">&gt;</span> <span class="dv">10</span>:</span>
<span id="cb174-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb174-4" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">&quot;Hatalmas&quot;</span>)</span>
<span id="cb174-5"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb174-5" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb174-6"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb174-6" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">&quot;Törpe&quot;</span>)</span></code></pre></div>
<pre><code>## Törpe</code></pre>
<div class="sourceCode" id="cb176"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb176-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb176-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Ezt mindenképp kiírjuk!&quot;</span>)</span></code></pre></div>
<pre><code>## Ezt mindenképp kiírjuk!</code></pre>
<p>Ahogy a fenti kódrészlet eredménye is mutatja, <strong>az <code>else</code> esetén is kell a behúzás az egyéb esetben végrehajtandó kódokhoz</strong>, hogy azt csinálja nekünk a pitonállat, amit szeretnénk.</p>
<p>Az elvégezhető logikai összehasonlítő műveletek az <code>if</code> feltételekben egy <code>a</code> és <code>b</code> objektum között a következők a Python nyelvén:</p>
<ul>
<li>Egyenlő: <code>a == b</code></li>
<li>Nem egyenlő: <code>a != b</code></li>
<li>Kisebb: <code>a &lt; b</code></li>
<li>Nagyobb: <code>a &gt; b</code></li>
<li>Legalább: <code>a &lt;= b</code></li>
<li>Legfeljebb: <code>a &gt;= b</code></li>
</ul>
<p>Az <em>egyenlő</em> és <em>nem egyenlő</em> természetesen működik <code>str</code>-ek esetében is, a többi viszont csak <code>int</code> és <code>float</code> adattípusú objektumokra értelmes, amúgy <em>hibára futnak</em>.</p>
</div>
<div id="ciklusok-for" class="section level3 hasAnchor" number="2.6.2">
<h3><span class="header-section-number">2.6.2</span> Ciklusok (<code>for</code>)<a href="statisztikához-szükséges-python-nyelvi-alapok.html#ciklusok-for" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Alapvetően többféle ciklus van a programnyelvekben, de minekünk igazából csak a <code>for</code> ciklusra lesz szükségünk.</p>
<p>A <code>for</code> ciklus egy általunk éppen <code>aktualis_elem</code>-nek elnevezett objektumot pörget végig egy lista vagy <code>numpy</code> tömb minden elemén. Ezzel így ki tudjuk olvasni egyesével egy tömb vagy lista minden értékét. A “<em>végigpörgetés</em>” alias “<em>ciklizálás</em>” során végrehajtandó kódot hívjuk <strong>ciklusmag</strong>nak, és ezt a kódrészletet az <code>if</code>-hez hasonló módon <strong>behúzással kell elválasztani</strong> a kód többi részétől!</p>
<p>Lássuk hát a dolgot akció közben!</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb178-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb178-1" tabindex="-1"></a>sokszam_sokszoveg <span class="op">=</span> [<span class="dv">88</span>, <span class="dv">42</span>, <span class="st">&quot;Hello&quot;</span>, <span class="dv">1992</span>, <span class="dv">9</span>, <span class="st">&quot;There&quot;</span>, <span class="st">&quot;Friend&quot;</span>, <span class="dv">11</span>]</span>
<span id="cb178-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb178-2" tabindex="-1"></a></span>
<span id="cb178-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb178-3" tabindex="-1"></a>tömböcske <span class="op">=</span> np.array([<span class="fl">3.14</span>, <span class="fl">2.67</span>, <span class="dv">88</span>, <span class="dv">1234</span>])</span>
<span id="cb178-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb178-4" tabindex="-1"></a></span>
<span id="cb178-5"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb178-5" tabindex="-1"></a><span class="cf">for</span> aktualis_elem <span class="kw">in</span> sokszam_sokszoveg:</span>
<span id="cb178-6"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb178-6" tabindex="-1"></a>  aktualis_elem</span></code></pre></div>
<pre><code>## 88
## 42
## &#39;Hello&#39;
## 1992
## 9
## &#39;There&#39;
## &#39;Friend&#39;
## 11</code></pre>
<div class="sourceCode" id="cb180"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb180-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb180-1" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;--------------&quot;</span>)</span></code></pre></div>
<pre><code>## --------------</code></pre>
<div class="sourceCode" id="cb182"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb182-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb182-1" tabindex="-1"></a><span class="cf">for</span> aktualis_elem <span class="kw">in</span> tömböcske:</span>
<span id="cb182-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb182-2" tabindex="-1"></a>  aktualis_elem</span></code></pre></div>
<pre><code>## 3.14
## 2.67
## 88.0
## 1234.0</code></pre>
<p>Egy <code>range</code> keresztségű függvénnyel bármilyen számsorozatot is ki tudunk íratni egy <code>for</code> ciklusban. Csak arra figyeljünk, hogy ez a függvény is 0-tól kezdi a léptetést, mint a listák és a tömbök! :).</p>
<p>Írjuk ki az egész számokat <span class="math inline">\(0\)</span>-tól <span class="math inline">\(5\)</span>-ig…ehhez a <code>range</code> függvénybe <span class="math inline">\(6\)</span>-ot kell írni paraméternek!</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb184-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb184-1" tabindex="-1"></a><span class="cf">for</span> aktualis_elem <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>):</span>
<span id="cb184-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb184-2" tabindex="-1"></a>  aktualis_elem</span></code></pre></div>
<pre><code>## 0
## 1
## 2
## 3
## 4
## 5</code></pre>
<p>Minden egész szám kiíratása <span class="math inline">\(2\)</span>-től <span class="math inline">\(8\)</span>-ig az alábbi módon lehetséges. Itt a <code>range</code>-ben is a felső határ egy nyílt intervallumként megadható, mint a listaelemek <code>:</code>-os kiolvasása esetén (5.2.1. fejezet).</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb186-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb186-1" tabindex="-1"></a><span class="cf">for</span> aktualis_elem <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,<span class="dv">9</span>):</span>
<span id="cb186-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb186-2" tabindex="-1"></a>  aktualis_elem</span></code></pre></div>
<pre><code>## 2
## 3
## 4
## 5
## 6
## 7
## 8</code></pre>
<p>Tömb elemeit ezzel a <code>range</code> függvénnyel kiolvashatjuk a cikluson belül a sorszámuk (indexszük) segítségével is akár.</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb188-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb188-1" tabindex="-1"></a>elemszám <span class="op">=</span> <span class="bu">len</span>(sokszam)</span>
<span id="cb188-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb188-2" tabindex="-1"></a></span>
<span id="cb188-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb188-3" tabindex="-1"></a><span class="cf">for</span> aktualis_index <span class="kw">in</span> <span class="bu">range</span>(elemszám):</span>
<span id="cb188-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb188-4" tabindex="-1"></a>  sokszam[aktualis_index]</span></code></pre></div>
<pre><code>## 3.14
## 2.67
## 88
## 1234</code></pre>
<p>De remélem érezzük, hogy ez kellően körülményes megoldás ahhoz képest, mintha közvetlenül a tömböt járnánk be a ciklussal. :)</p>
</div>
</div>
<div id="a-pandas-data-frame-objektum" class="section level2 hasAnchor" number="2.7">
<h2><span class="header-section-number">2.7</span> A Pandas data frame objektum<a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-pandas-data-frame-objektum" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Adattáblákat Pythonban <code>pandas</code> csomag <strong>data frame</strong> struktúrájában kezeljük!</p>
<p>Ezt, mint külön csomagot egyszer telepíteni kell.</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb190-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb190-1" tabindex="-1"></a>pip install pandas</span></code></pre></div>
<p>Aztán minden kódunk elején behivatkozni, ha használni akarjuk.</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb191-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb191-1" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span></code></pre></div>
<p>Adatvizualizációhoz a <code>pandas</code> csomaggal együttműködni képes <code>matplotlib</code> csomagra lesz szükség.</p>
<p>Itt is egyszer telepíteni kell.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb192-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb192-1" tabindex="-1"></a>pip install matplotlib</span></code></pre></div>
<p>Aztán minden kódunk elején behivatkozzuk, ahol használni akarjuk.</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb193-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb193-1" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span></code></pre></div>
<p>Itt is figyeljünk a <strong>névterekre</strong>, amikbe elraktuk a csomagok függvényeit!</p>
<p>Ezen a ponton jegyezném meg, hogy a <code>pandas</code> csomag olyan hatalmas, hogy függvényeinek és metódusainak <a href="https://pandas.pydata.org/docs/reference/index.html">külön dokumentációja érhető el</a>. <strong>Ha egy függvény vagy metódus használatakor elakad az ember, érdemes először ebben a dokumentációban utána nézni a proglémás cucc működésének!</strong></p>
<p>Olvassuk be a <a href="https://github.com/KoLa992/Statisztika-II-Python-Alapok/blob/main/covid_19_clean_complete.csv" target="_blank">covid_19_clean_complete.csv</a> fájlt, és tároljuk le az adatait egy <strong>corona</strong> nevű Pandas data frame-ben!</p>
<p>Az adatfájl egy WHO által készített historikus kimutatás a COVID-19 vírus esetszámairól a Föld országaiban 2020. április 30-cal bezárólag.</p>
<p>A <code>pandas</code> data frame-ekbe a legkönnyebben talán <strong>csv</strong> kiterjesztésű állományként tárolt adattáblákat lehet beolvasni a <code>read_csv</code> függvény segítségével. A <strong>csv</strong> állományok valójában olyan <strong>txt</strong> fájlok, amikben egy táblázat szerepel úgy, hogy az oszlophatárokat <strong>vesszők</strong> jelzik! Innen is a név: <em>comma separated values = csv</em></p>
<p><strong>Figyelem!</strong> Az alábbi beolvasó kód csak akkor működik, ha a <em>csv</em> fájlt az aktuálisan beállított <strong>Working Directory</strong>-ba másoltuk be!!</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb194-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb194-1" tabindex="-1"></a>corona <span class="op">=</span> pd.read_csv(<span class="st">&#39;covid_19_clean_complete.csv&#39;</span>)</span></code></pre></div>
<p>A <strong>data frame</strong> logikailag úgy kezelhető, mint egy <strong>numpy tömbökből álló lista, de a listaelemeket névvel is tudjuk azonosítani, mint egy Dictionary-ben</strong>!! Ezek a <strong>listaelem nevek az oszlopok = változók = ismérvek nevei</strong>! Gondoljunk bele, hogy ez mennyire logikus, hiszen a <code>numpy</code> tömbök elemeire vonatkozó azonos adattípus követelmény megfeleltethető a statisztikai ismérvek mérési skáláinak fogalmával!</p>
<p>Az előző bekezdésben írtakból kifolyólag a betöltendő <em>csv</em> fájjal szemben vannak a <code>pandas</code> csomagnak fontos előkövetelményei:</p>
<ul>
<li>az oszlopok vesszővel elválasztottak</li>
<li>a tört számok tizedes pontot használnak</li>
<li>a szöveges adatok idézőjelek között vannak</li>
</ul>
<p>Ha angol nyelvű oldalról töltünk le adatokat <em>csv</em>-ben (pl. <a href="https://www.kaggle.com/">Kaggle</a>), akkor a fenti követelményeknek szinte biztosan meg fognak felelni.<br>
Rosszul viselkedő <em>csv</em>-k esetén pedig a <code>read_csv</code> függvény különböző paramétereivel kezelhetők a problémák (tizedespont vs tizedes vessző pl.). Részletek a függvény <a href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">dokumentációjában</a>.</p>
<p>A beolvasandó adattáblától a <code>pandas</code> elvárja azt a logikai felépítést, hogy a tábla soraiban legyenek a statisztikai megfigyelési egységeink (emberek, országok, lakások, autók stb.) és az oszlopokban pedig a megfigyeléseket leíró tulajdonságok, azaz változók (ember kora, ország GDP-je, autó márkája stb.).</p>
<p>Nézzük meg ezt az adatstruktúrát a <strong>data frame</strong> <code>info</code> metódusának segítségével!</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb195-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb195-1" tabindex="-1"></a>corona.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 26400 entries, 0 to 26399
## Data columns (total 8 columns):
##  #   Column          Non-Null Count  Dtype  
## ---  ------          --------------  -----  
##  0   Province/State  8000 non-null   object 
##  1   Country/Region  26400 non-null  object 
##  2   Lat             26400 non-null  float64
##  3   Long            26400 non-null  float64
##  4   Date            26400 non-null  object 
##  5   Confirmed       26400 non-null  int64  
##  6   Deaths          26400 non-null  int64  
##  7   Recovered       26400 non-null  int64  
## dtypes: float64(2), int64(3), object(3)
## memory usage: 1.6+ MB</code></pre>
<p>Itt tehát úgy néz ki, hogy <em>egy sor = egy földrajzi alrégió (mivel a Province kisebb egység, mint a Country) egy adott napon mért koronavírus adatai</em>. Ezek az adatok az adott napig <em>kumulált</em> esetszám, elhunytak száma és gyógyultak száma. Ez a fenti adatokból már nem derül ki, ez a WHO dokumentációjából jön az adattáblához. :) Amint látszik összesen <span class="math inline">\(26400\)</span> sorunk és <span class="math inline">\(8\)</span> oszlopunk, azaz ismérvünk/változónk van.</p>
<p>Az <code>info</code> metódus eredményéből viszont látszik az is, hogy a <strong>Province/State</strong> oszlopban csak <span class="math inline">\(8000\)</span> nem <em>null</em> (hiányzó érték) bejegyzés (azaz sor) van! Ez amiatt lehet, mert a kisebb országokat nem bontották szét az adatgyűjtők a WHO-nál alrégiókra, és így ezeknél az országoknál a <strong>Province/State</strong> oszlopot üresen hagyták.</p>
<p>Ami az <code>info</code> metódus eredményéből még érdekes, hogy a <strong>string adattípust a <code>pandas</code> data frame <code>object</code>-nek hívja!</strong> Ehhez hozzá kell szokni. :) Onnan jön az elnevezés, hogy általános programnyelvekben az <code>object</code> a legáltalánosabb adattípus, adatelemzésben pedig a legáltalánosabb mérési skála, amire mindent át lehet konvertálni az a szöveges adatok (<em>stringek</em>) nominális mérési skálája.</p>
<p>Nézzük meg a betöltött <em>adattábla = data frame</em> első pár rekordját A <code>head</code> metódusával. Alapból az első 5 sort írja ki.</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb197-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb197-1" tabindex="-1"></a>corona.head()</span></code></pre></div>
<pre><code>##   Province/State Country/Region      Lat  ...  Confirmed Deaths  Recovered
## 0            NaN    Afghanistan  33.0000  ...          0      0          0
## 1            NaN        Albania  41.1533  ...          0      0          0
## 2            NaN        Algeria  28.0339  ...          0      0          0
## 3            NaN        Andorra  42.5063  ...          0      0          0
## 4            NaN         Angola -11.2027  ...          0      0          0
## 
## [5 rows x 8 columns]</code></pre>
<p>Itt az elején még valószínűleg nagyon 2020 elején vagyunk, így ne meglepő, hogy Afganisztánban és ilyen A betűs afrikai országokban még 0 eset (és így 0 halott, 0 gyógyult) van.</p>
<p>Ami érdekes még, hogy a <strong>Province/State</strong> oszlopban ilyen <code>NaN</code> kódok vannak, amik a hiányzó értékeket jelölik. Ugye az <code>info</code> metódusból tudjuk ugyebár, hogy ebben az oszlopban jó sok, <span class="math inline">\(26400-8000=18400\)</span> érték szerepel, így nem meglepő, amit itt a <code>head</code>-ben látunk. :)</p>
<p>A data frame-nek nem csak metódusai vannak, hanem tulajdonságai, <strong>property</strong>-jei is! Ezeket is ponttal tudjuk lekérni, csak nem kell a végére zárójel.</p>
<p>Pl. egy tulajdonság az oszlopnevek listája. Ezt egy numpy tömbben adja majd vissza a gépszellem.</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb199-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb199-1" tabindex="-1"></a>corona.columns</span></code></pre></div>
<pre><code>## Index([&#39;Province/State&#39;, &#39;Country/Region&#39;, &#39;Lat&#39;, &#39;Long&#39;, &#39;Date&#39;, &#39;Confirmed&#39;,
##        &#39;Deaths&#39;, &#39;Recovered&#39;],
##       dtype=&#39;object&#39;)</code></pre>
<p>Kérjük le, hogy mi az első és a hatodik oszlop neve!</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb201-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb201-1" tabindex="-1"></a>corona.columns[<span class="dv">0</span>]</span></code></pre></div>
<pre><code>## &#39;Province/State&#39;</code></pre>
<div class="sourceCode" id="cb203"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb203-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb203-1" tabindex="-1"></a>corona.columns[<span class="dv">5</span>]</span></code></pre></div>
<pre><code>## &#39;Confirmed&#39;</code></pre>
<div id="hivatkozási-lehetőségek-data-frame-ben" class="section level3 hasAnchor" number="2.7.1">
<h3><span class="header-section-number">2.7.1</span> Hivatkozási lehetőségek data frame-ben<a href="statisztikához-szükséges-python-nyelvi-alapok.html#hivatkozási-lehetőségek-data-frame-ben" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Egy-egy konkrét oszlopot, mint <em>property</em> is ki tudunk választani a nevén keresztül.</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb205-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb205-1" tabindex="-1"></a>corona.Confirmed</span></code></pre></div>
<pre><code>## 0         0
## 1         0
## 2         0
## 3         0
## 4         0
##          ..
## 26395     6
## 26396    14
## 26397     6
## 26398     1
## 26399    15
## Name: Confirmed, Length: 26400, dtype: int64</code></pre>
<p>De az is működik, ha azt mondjuk, hogy a data frame nem más, mint egy Dictionary, aminek az elemei <code>numpy</code> tömbök, és kiválasztjuk az elemet a listából a nevén (oszlopnév) keresztül.</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb207-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb207-1" tabindex="-1"></a>corona[<span class="st">&quot;Confirmed&quot;</span>]</span></code></pre></div>
<pre><code>## 0         0
## 1         0
## 2         0
## 3         0
## 4         0
##          ..
## 26395     6
## 26396    14
## 26397     6
## 26398     1
## 26399    15
## Name: Confirmed, Length: 26400, dtype: int64</code></pre>
<p>Itt jegyzem meg, hogy a <code>pandas</code> egy-egy oszlop adattípusát nem <code>numpy</code> tömbnek, hanem <code>Series</code>-nek hívja, de logikailag és technikailag is ez a <code>Series</code> ugyan úgy műkszik, mint a <code>numpy</code> tömbök.</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb209-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb209-1" tabindex="-1"></a><span class="bu">type</span>(corona.Confirmed)</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.series.Series&#39;&gt;</code></pre>
<p>Ha egy konkrét elem, pl. a 19000. sor értéke érdekel minket, akkor azt a megfelelő oszlop kiválasztása után szintén []-vel tudjuk kikeresni, hiszen a kiválasztott oszlop maga egy <code>numpy</code> tömbként kezelhető <code>Series</code>, mint láttuk korábban.</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb211-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb211-1" tabindex="-1"></a>corona.Confirmed[<span class="dv">19000</span><span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<pre><code>## 3</code></pre>
<div class="sourceCode" id="cb213"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb213-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb213-1" tabindex="-1"></a>corona[<span class="st">&quot;Confirmed&quot;</span>][<span class="dv">19000</span><span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<pre><code>## 3</code></pre>
<p>De a data frame-et <code>[kiválasztott sor, kiválasztott oszlop]</code> módon is tudjuk hivatkozni a <code>loc</code> és <code>iloc</code> metódusokkal. A különbség a kettő között, hogy az <code>iloc</code> esetben az oszlopot a sorszámával, míg a <code>loc</code> esetben a nevével tudjuk kicsalogatni a jégre.</p>
<p>Szóval, a következő két kód <em>ugyan azt az elemet olvassa ki</em> a data frame-ből.</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb215-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb215-1" tabindex="-1"></a>corona.iloc[<span class="dv">19000</span><span class="op">-</span><span class="dv">1</span>, <span class="dv">5</span>]</span></code></pre></div>
<pre><code>## 3</code></pre>
<div class="sourceCode" id="cb217"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb217-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb217-1" tabindex="-1"></a>corona.loc[<span class="dv">19000</span><span class="op">-</span><span class="dv">1</span>, <span class="st">&quot;Confirmed&quot;</span>]</span></code></pre></div>
<pre><code>## 3</code></pre>
<p>A <code>loc</code> és <code>iloc</code> hivatkozási módokban a <code>:</code> szimbólummal ki tudunk választani egész sorokat és oszlopokat is.</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb219-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb219-1" tabindex="-1"></a>corona.iloc[:, <span class="dv">5</span>]</span></code></pre></div>
<pre><code>## 0         0
## 1         0
## 2         0
## 3         0
## 4         0
##          ..
## 26395     6
## 26396    14
## 26397     6
## 26398     1
## 26399    15
## Name: Confirmed, Length: 26400, dtype: int64</code></pre>
<div class="sourceCode" id="cb221"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb221-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb221-1" tabindex="-1"></a>corona.loc[<span class="dv">19000</span><span class="op">-</span><span class="dv">1</span>, :]</span></code></pre></div>
<pre><code>## Province/State          NaN
## Country/Region       Malawi
## Lat              -13.254308
## Long              34.301525
## Date                 4/2/20
## Confirmed                 3
## Deaths                    0
## Recovered                 0
## Name: 18999, dtype: object</code></pre>
<p>A <code>loc</code> és <code>iloc</code> segítségével egyszerre több oszlopot is ki tudunk választani pl.</p>
<p>Készítsünk egy dataframe-t a corona-ból, ami csak az országok nevét, a dátumot és a COVID-19 megerősített eseteinek, halottainak és gyógyultjainak számát tartalmazza.</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb223-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb223-1" tabindex="-1"></a>corona.loc[:,[<span class="st">&#39;Country/Region&#39;</span>, <span class="st">&#39;Date&#39;</span>, <span class="st">&#39;Confirmed&#39;</span>, <span class="st">&#39;Deaths&#39;</span>, <span class="st">&#39;Recovered&#39;</span>]]</span></code></pre></div>
<pre><code>##               Country/Region     Date  Confirmed  Deaths  Recovered
## 0                Afghanistan  1/22/20          0       0          0
## 1                    Albania  1/22/20          0       0          0
## 2                    Algeria  1/22/20          0       0          0
## 3                    Andorra  1/22/20          0       0          0
## 4                     Angola  1/22/20          0       0          0
## ...                      ...      ...        ...     ...        ...
## 26395         Western Sahara  4/30/20          6       0          5
## 26396  Sao Tome and Principe  4/30/20         14       0          4
## 26397                  Yemen  4/30/20          6       2          0
## 26398                Comoros  4/30/20          1       0          0
## 26399             Tajikistan  4/30/20         15       0          0
## 
## [26400 rows x 5 columns]</code></pre>
<div class="sourceCode" id="cb225"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb225-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb225-1" tabindex="-1"></a>corona.iloc[:,[<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>]]</span></code></pre></div>
<pre><code>##               Country/Region     Date  Confirmed  Deaths  Recovered
## 0                Afghanistan  1/22/20          0       0          0
## 1                    Albania  1/22/20          0       0          0
## 2                    Algeria  1/22/20          0       0          0
## 3                    Andorra  1/22/20          0       0          0
## 4                     Angola  1/22/20          0       0          0
## ...                      ...      ...        ...     ...        ...
## 26395         Western Sahara  4/30/20          6       0          5
## 26396  Sao Tome and Principe  4/30/20         14       0          4
## 26397                  Yemen  4/30/20          6       2          0
## 26398                Comoros  4/30/20          1       0          0
## 26399             Tajikistan  4/30/20         15       0          0
## 
## [26400 rows x 5 columns]</code></pre>
<p>Kérjük le a Province/State változó lehetséges értékeinek listáját az oszlopok <code>unique</code> metódusával!</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb227-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb227-1" tabindex="-1"></a>corona[<span class="st">&#39;Province/State&#39;</span>].unique()</span></code></pre></div>
<pre><code>## array([nan, &#39;Australian Capital Territory&#39;, &#39;New South Wales&#39;,
##        &#39;Northern Territory&#39;, &#39;Queensland&#39;, &#39;South Australia&#39;, &#39;Tasmania&#39;,
##        &#39;Victoria&#39;, &#39;Western Australia&#39;, &#39;Alberta&#39;, &#39;British Columbia&#39;,
##        &#39;Grand Princess&#39;, &#39;Manitoba&#39;, &#39;New Brunswick&#39;,
##        &#39;Newfoundland and Labrador&#39;, &#39;Nova Scotia&#39;, &#39;Ontario&#39;,
##        &#39;Prince Edward Island&#39;, &#39;Quebec&#39;, &#39;Saskatchewan&#39;, &#39;Anhui&#39;,
##        &#39;Beijing&#39;, &#39;Chongqing&#39;, &#39;Fujian&#39;, &#39;Gansu&#39;, &#39;Guangdong&#39;, &#39;Guangxi&#39;,
##        &#39;Guizhou&#39;, &#39;Hainan&#39;, &#39;Hebei&#39;, &#39;Heilongjiang&#39;, &#39;Henan&#39;, &#39;Hong Kong&#39;,
##        &#39;Hubei&#39;, &#39;Hunan&#39;, &#39;Inner Mongolia&#39;, &#39;Jiangsu&#39;, &#39;Jiangxi&#39;, &#39;Jilin&#39;,
##        &#39;Liaoning&#39;, &#39;Macau&#39;, &#39;Ningxia&#39;, &#39;Qinghai&#39;, &#39;Shaanxi&#39;, &#39;Shandong&#39;,
##        &#39;Shanghai&#39;, &#39;Shanxi&#39;, &#39;Sichuan&#39;, &#39;Tianjin&#39;, &#39;Tibet&#39;, &#39;Xinjiang&#39;,
##        &#39;Yunnan&#39;, &#39;Zhejiang&#39;, &#39;Faroe Islands&#39;, &#39;Greenland&#39;,
##        &#39;French Guiana&#39;, &#39;French Polynesia&#39;, &#39;Guadeloupe&#39;, &#39;Mayotte&#39;,
##        &#39;New Caledonia&#39;, &#39;Reunion&#39;, &#39;Saint Barthelemy&#39;, &#39;St Martin&#39;,
##        &#39;Martinique&#39;, &#39;Aruba&#39;, &#39;Curacao&#39;, &#39;Sint Maarten&#39;, &#39;Bermuda&#39;,
##        &#39;Cayman Islands&#39;, &#39;Channel Islands&#39;, &#39;Gibraltar&#39;, &#39;Isle of Man&#39;,
##        &#39;Montserrat&#39;, &#39;Diamond Princess&#39;, &#39;Northwest Territories&#39;, &#39;Yukon&#39;,
##        &#39;Anguilla&#39;, &#39;British Virgin Islands&#39;, &#39;Turks and Caicos Islands&#39;,
##        &#39;Falkland Islands (Malvinas)&#39;, &#39;Saint Pierre and Miquelon&#39;],
##       dtype=object)</code></pre>
</div>
<div id="data-frame-k-módosítása" class="section level3 hasAnchor" number="2.7.2">
<h3><span class="header-section-number">2.7.2</span> Data frame-k módosítása<a href="statisztikához-szükséges-python-nyelvi-alapok.html#data-frame-k-módosítása" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Nézzük meg újra a corona dataframe változóinak az adattípusát!</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb229-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb229-1" tabindex="-1"></a>corona.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 26400 entries, 0 to 26399
## Data columns (total 8 columns):
##  #   Column          Non-Null Count  Dtype  
## ---  ------          --------------  -----  
##  0   Province/State  8000 non-null   object 
##  1   Country/Region  26400 non-null  object 
##  2   Lat             26400 non-null  float64
##  3   Long            26400 non-null  float64
##  4   Date            26400 non-null  object 
##  5   Confirmed       26400 non-null  int64  
##  6   Deaths          26400 non-null  int64  
##  7   Recovered       26400 non-null  int64  
## dtypes: float64(2), int64(3), object(3)
## memory usage: 1.6+ MB</code></pre>
<p>Mindenképp érdemes a Dátum oszlopot object (kvázi string) típusról ténylegesen dátum típusúvá alakítani! Így az időbeli kimutatásokat könnyebben lehet aggregálni év, negyedév, hónap, hét, nap szintekre.</p>
<p>Ezzel láthatjuk, hogy tudunk egy teljes oszlopot módosítani. A kulcs, hogy az oszlop korábbi önmagát felül kell írni a módosított (esetünkben a <code>to_datetime</code> csomag <code>to_datetime</code> függvénye jóvoltából egy dátummá konvertáláson átesett) verziójával.</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb231-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb231-1" tabindex="-1"></a>corona.Date <span class="op">=</span> pd.to_datetime(corona.Date)</span></code></pre></div>
<pre><code>## &lt;string&gt;:1: UserWarning: Could not infer format, so each element will be parsed individually, falling back to `dateutil`. To ensure parsing is consistent and as-expected, please specify a format.</code></pre>
<div class="sourceCode" id="cb233"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb233-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb233-1" tabindex="-1"></a>corona.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 26400 entries, 0 to 26399
## Data columns (total 8 columns):
##  #   Column          Non-Null Count  Dtype         
## ---  ------          --------------  -----         
##  0   Province/State  8000 non-null   object        
##  1   Country/Region  26400 non-null  object        
##  2   Lat             26400 non-null  float64       
##  3   Long            26400 non-null  float64       
##  4   Date            26400 non-null  datetime64[ns]
##  5   Confirmed       26400 non-null  int64         
##  6   Deaths          26400 non-null  int64         
##  7   Recovered       26400 non-null  int64         
## dtypes: datetime64[ns](1), float64(2), int64(3), object(2)
## memory usage: 1.6+ MB</code></pre>
<p>Hozzunk létre egy teljesen új változót (leánykori nevén oszlopot :)) a corona dataframe-ben, ami az adott dátumon továbbra is aktív koronavírusos esetek számát tartalmazza!</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb235-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb235-1" tabindex="-1"></a>corona[<span class="st">&#39;Active&#39;</span>] <span class="op">=</span> corona.Confirmed <span class="op">-</span> corona.Deaths <span class="op">-</span> corona.Recovered</span>
<span id="cb235-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb235-2" tabindex="-1"></a></span>
<span id="cb235-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb235-3" tabindex="-1"></a>corona.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 26400 entries, 0 to 26399
## Data columns (total 9 columns):
##  #   Column          Non-Null Count  Dtype         
## ---  ------          --------------  -----         
##  0   Province/State  8000 non-null   object        
##  1   Country/Region  26400 non-null  object        
##  2   Lat             26400 non-null  float64       
##  3   Long            26400 non-null  float64       
##  4   Date            26400 non-null  datetime64[ns]
##  5   Confirmed       26400 non-null  int64         
##  6   Deaths          26400 non-null  int64         
##  7   Recovered       26400 non-null  int64         
##  8   Active          26400 non-null  int64         
## dtypes: datetime64[ns](1), float64(2), int64(4), object(2)
## memory usage: 1.8+ MB</code></pre>
<div class="sourceCode" id="cb237"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb237-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb237-1" tabindex="-1"></a>corona.head()</span></code></pre></div>
<pre><code>##   Province/State Country/Region      Lat  ...  Deaths Recovered  Active
## 0            NaN    Afghanistan  33.0000  ...       0         0       0
## 1            NaN        Albania  41.1533  ...       0         0       0
## 2            NaN        Algeria  28.0339  ...       0         0       0
## 3            NaN        Andorra  42.5063  ...       0         0       0
## 4            NaN         Angola -11.2027  ...       0         0       0
## 
## [5 rows x 9 columns]</code></pre>
</div>
<div id="szűrés-data-frame-ben-logikai-indexszálás" class="section level3 hasAnchor" number="2.7.3">
<h3><span class="header-section-number">2.7.3</span> Szűrés data frame-ben: logikai indexszálás<a href="statisztikához-szükséges-python-nyelvi-alapok.html#szűrés-data-frame-ben-logikai-indexszálás" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Ha valami logikai feltételt írunk egy data frame után [] jelek közé, akkor a logikai feltételnek megfelelő sorokat fogja nekünk kiválasztani a gép! Ez a <strong>logikai indexszálás</strong> c. művelet!</p>
<p>Pl. kérjük le azokat a rekordokat, ahol a halálozás 10000 feletti.</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb239-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb239-1" tabindex="-1"></a>corona[corona.Deaths <span class="op">&gt;</span> <span class="dv">10000</span>]</span></code></pre></div>
<pre><code>##       Province/State  Country/Region      Lat  ...  Deaths Recovered  Active
## 17561            NaN           Italy  43.0000  ...   10023     12384   70065
## 17825            NaN           Italy  43.0000  ...   10779     13030   73880
## 18089            NaN           Italy  43.0000  ...   11591     14620   75528
## 18353            NaN           Italy  43.0000  ...   12428     15729   77635
## 18617            NaN           Italy  43.0000  ...   13155     16847   80572
## ...              ...             ...      ...  ...     ...       ...     ...
## 26252            NaN          France  46.2276  ...   24376     49476   91912
## 26273            NaN           Italy  43.0000  ...   27967     75945  101551
## 26337            NaN           Spain  40.0000  ...   24543    112050   76842
## 26359            NaN  United Kingdom  55.3781  ...   26771         0  144482
## 26361            NaN              US  37.0902  ...   62996    153947  852481
## 
## [135 rows x 9 columns]</code></pre>
<p>Ha csak az ország és a dátum oszlopok kellenek az eredményből, akkor be lehet vetni a <code>loc</code> és <code>iloc</code>-ot.</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb241-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb241-1" tabindex="-1"></a>corona.loc[corona.Deaths <span class="op">&gt;</span> <span class="dv">10000</span>, [<span class="st">&quot;Country/Region&quot;</span>, <span class="st">&quot;Date&quot;</span>]]</span></code></pre></div>
<pre><code>##        Country/Region       Date
## 17561           Italy 2020-03-28
## 17825           Italy 2020-03-29
## 18089           Italy 2020-03-30
## 18353           Italy 2020-03-31
## 18617           Italy 2020-04-01
## ...               ...        ...
## 26252          France 2020-04-30
## 26273           Italy 2020-04-30
## 26337           Spain 2020-04-30
## 26359  United Kingdom 2020-04-30
## 26361              US 2020-04-30
## 
## [135 rows x 2 columns]</code></pre>
<p>Ugyan azok a logikai műveletek és szimbólumok érvényesek itt is, mint az <code>if</code> elágazásoknál is.</p>
<p>Az eredmény menthető külön új data frame-be is:</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb243-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb243-1" tabindex="-1"></a>szűrttészta <span class="op">=</span> corona.loc[corona.Deaths <span class="op">&gt;</span> <span class="dv">10000</span>, [<span class="st">&quot;Country/Region&quot;</span>, <span class="st">&quot;Date&quot;</span>]]</span>
<span id="cb243-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb243-2" tabindex="-1"></a>szűrttészta.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## Index: 135 entries, 17561 to 26361
## Data columns (total 2 columns):
##  #   Column          Non-Null Count  Dtype         
## ---  ------          --------------  -----         
##  0   Country/Region  135 non-null    object        
##  1   Date            135 non-null    datetime64[ns]
## dtypes: datetime64[ns](1), object(1)
## memory usage: 3.2+ KB</code></pre>
<p>Vigyázzunk a sorindexek, még az eredeti data frame-ből jönnek. Pl. az első sor az az eredetiben a 17561-ik, így ezzel tudom kiválasztani, ha a <code>loc</code>-ot használom, mert ez a sorokat is a <strong>nevükkel</strong> azonosítja, mint az oszlopokat. A sor “neve”, pedig az eredeti data frame-ből örökölt index az ő kifacsart géplogikájában:</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb245-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb245-1" tabindex="-1"></a>szűrttészta.loc[<span class="dv">0</span>,:]</span></code></pre></div>
<pre><code>## KeyError: 0</code></pre>
<div class="sourceCode" id="cb247"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb247-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb247-1" tabindex="-1"></a>szűrttészta.loc[<span class="dv">17561</span>,:]</span></code></pre></div>
<pre><code>## Country/Region                  Italy
## Date              2020-03-28 00:00:00
## Name: 17561, dtype: object</code></pre>
<p>Viszont az <code>iloc</code> az mindent folytonosan sorszámmal azonosít, sort és oszlopot is, így az érteni fogja a <span class="math inline">\(0\)</span>-t.</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb249-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb249-1" tabindex="-1"></a>szűrttészta.iloc[<span class="dv">0</span>,:]</span></code></pre></div>
<pre><code>## Country/Region                  Italy
## Date              2020-03-28 00:00:00
## Name: 17561, dtype: object</code></pre>
<p>Ha erre a sima <code>loc</code>-ot is rá akarjuk venni, akkor a <code>reset.index</code> metódust kell elsütni. Figyeljük, hogy az eredménnyel felül kell írni az eredeti <strong>szűrttészta</strong> data frame-t!</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb251-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb251-1" tabindex="-1"></a>szűrttészta <span class="op">=</span> szűrttészta.reset_index()</span>
<span id="cb251-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb251-2" tabindex="-1"></a>szűrttészta.loc[<span class="dv">0</span>,:]</span></code></pre></div>
<pre><code>## index                           17561
## Country/Region                  Italy
## Date              2020-03-28 00:00:00
## Name: 0, dtype: object</code></pre>
<p>Viszont figyeljük meg, hogy a régi sorindexek beköltöztek egy új <code>index</code> nevű oszlopba.</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb253-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb253-1" tabindex="-1"></a>szűrttészta.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 135 entries, 0 to 134
## Data columns (total 3 columns):
##  #   Column          Non-Null Count  Dtype         
## ---  ------          --------------  -----         
##  0   index           135 non-null    int64         
##  1   Country/Region  135 non-null    object        
##  2   Date            135 non-null    datetime64[ns]
## dtypes: datetime64[ns](1), int64(1), object(1)
## memory usage: 3.3+ KB</code></pre>
<p>Ha nem kellenek ezek az index adatok, törölhetjük is az oszlopot a <code>drop</code> metódus segítségével. A metódus első paraméterében megadjuk, hogy mely oszlopot akarjuk törölni a data frame-ből (ha listát adunk meg ide, akkor egyszerre több oszlopot is tudunk törölni), míg a második paraméterben megadjuk, hogy oszlopokat akarunk törölni, nem pedig sorokat.</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb255-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb255-1" tabindex="-1"></a>szűrttészta <span class="op">=</span> szűrttészta.drop(<span class="st">&quot;index&quot;</span>, axis <span class="op">=</span> <span class="st">&quot;columns&quot;</span>)</span>
<span id="cb255-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb255-2" tabindex="-1"></a>szűrttészta.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 135 entries, 0 to 134
## Data columns (total 2 columns):
##  #   Column          Non-Null Count  Dtype         
## ---  ------          --------------  -----         
##  0   Country/Region  135 non-null    object        
##  1   Date            135 non-null    datetime64[ns]
## dtypes: datetime64[ns](1), object(1)
## memory usage: 2.2+ KB</code></pre>
<p>Az <code>axis = "index"</code> beállítással sorszám alapján sorokat lehet törölni a data frame-ből.</p>
<p>Nézzünk még pár szűrést logikai indexszálás segítségével végrehajtva!</p>
<p>Szűrjük le a corona dataframe-ből csak azokat a rekordokat, amik az USA, Olaszország és Irán adatait tartalmazzák!<br>
Egy <code>numpy</code> tömb elemeinek listába való tartozását a tömb (tehát data frame-ben az oszlop) <code>isin</code> metódusával tudunk vizsgálni.</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb257-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb257-1" tabindex="-1"></a>corona[corona[<span class="st">&#39;Country/Region&#39;</span>].isin([<span class="st">&#39;US&#39;</span>, <span class="st">&#39;Italy&#39;</span>, <span class="st">&#39;Iran&#39;</span>])]</span></code></pre></div>
<pre><code>##       Province/State Country/Region      Lat  ...  Deaths Recovered  Active
## 133              NaN           Iran  32.0000  ...       0         0       0
## 137              NaN          Italy  43.0000  ...       0         0       0
## 225              NaN             US  37.0902  ...       0         0       1
## 397              NaN           Iran  32.0000  ...       0         0       0
## 401              NaN          Italy  43.0000  ...       0         0       0
## ...              ...            ...      ...  ...     ...       ...     ...
## 26009            NaN          Italy  43.0000  ...   27682     71252  104657
## 26097            NaN             US  37.0902  ...   60967    120720  858222
## 26269            NaN           Iran  32.0000  ...    6028     75103   13509
## 26273            NaN          Italy  43.0000  ...   27967     75945  101551
## 26361            NaN             US  37.0902  ...   62996    153947  852481
## 
## [300 rows x 9 columns]</code></pre>
<p>Ha az egész elé teszünk egy <code>~</code> jelet, akkor pedig tagadást végzünk, tehát megkapunk minden sort, ami NEM USA, Olaszország és Irán adata.</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb259-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb259-1" tabindex="-1"></a>corona[<span class="op">~</span>corona[<span class="st">&#39;Country/Region&#39;</span>].isin([<span class="st">&#39;US&#39;</span>, <span class="st">&#39;Italy&#39;</span>, <span class="st">&#39;Iran&#39;</span>])]</span></code></pre></div>
<pre><code>##       Province/State         Country/Region  ...  Recovered  Active
## 0                NaN            Afghanistan  ...          0       0
## 1                NaN                Albania  ...          0       0
## 2                NaN                Algeria  ...          0       0
## 3                NaN                Andorra  ...          0       0
## 4                NaN                 Angola  ...          0       0
## ...              ...                    ...  ...        ...     ...
## 26395            NaN         Western Sahara  ...          5       1
## 26396            NaN  Sao Tome and Principe  ...          4      10
## 26397            NaN                  Yemen  ...          0       4
## 26398            NaN                Comoros  ...          0       1
## 26399            NaN             Tajikistan  ...          0      15
## 
## [26100 rows x 9 columns]</code></pre>
</div>
<div id="hiányzó-értékek-kezelése-data-frame-ben" class="section level3 hasAnchor" number="2.7.4">
<h3><span class="header-section-number">2.7.4</span> Hiányzó értékek kezelése data frame-ben<a href="statisztikához-szükséges-python-nyelvi-alapok.html#hiányzó-értékek-kezelése-data-frame-ben" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Az oszlopok <code>isnull</code> metódusával <code>True/False</code> módon megjelölhetők az oszlopon belüli hiányzó értékek.</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb261-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb261-1" tabindex="-1"></a>corona[<span class="st">&#39;Province/State&#39;</span>].isnull()</span></code></pre></div>
<pre><code>## 0        True
## 1        True
## 2        True
## 3        True
## 4        True
##          ... 
## 26395    True
## 26396    True
## 26397    True
## 26398    True
## 26399    True
## Name: Province/State, Length: 26400, dtype: bool</code></pre>
<p>Aminek felhasználásával le is lehet őket kérdezni.</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb263-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb263-1" tabindex="-1"></a>corona[corona[<span class="st">&#39;Province/State&#39;</span>].isnull()<span class="op">==</span><span class="va">True</span>]</span></code></pre></div>
<pre><code>##       Province/State         Country/Region  ...  Recovered  Active
## 0                NaN            Afghanistan  ...          0       0
## 1                NaN                Albania  ...          0       0
## 2                NaN                Algeria  ...          0       0
## 3                NaN                Andorra  ...          0       0
## 4                NaN                 Angola  ...          0       0
## ...              ...                    ...  ...        ...     ...
## 26395            NaN         Western Sahara  ...          5       1
## 26396            NaN  Sao Tome and Principe  ...          4      10
## 26397            NaN                  Yemen  ...          0       4
## 26398            NaN                Comoros  ...          0       1
## 26399            NaN             Tajikistan  ...          0      15
## 
## [18400 rows x 9 columns]</code></pre>
<p>Az oszlopoknak van egy <code>fillna</code> metódusa, amivel tetszőleges értékre le tudjuk cserélni a hiányzó értékeket. Most ez marha kreatív módon egy üres <code>str</code> lesz. :)<br>
Figyeljünk, hogy itt is felül kell írni az eredménnyel az eredeti oszlopot!</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb265-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb265-1" tabindex="-1"></a>corona[<span class="st">&#39;Province/State&#39;</span>] <span class="op">=</span> corona[<span class="st">&#39;Province/State&#39;</span>].fillna(<span class="st">&#39;&#39;</span>)</span>
<span id="cb265-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb265-2" tabindex="-1"></a></span>
<span id="cb265-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb265-3" tabindex="-1"></a>corona.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 26400 entries, 0 to 26399
## Data columns (total 9 columns):
##  #   Column          Non-Null Count  Dtype         
## ---  ------          --------------  -----         
##  0   Province/State  26400 non-null  object        
##  1   Country/Region  26400 non-null  object        
##  2   Lat             26400 non-null  float64       
##  3   Long            26400 non-null  float64       
##  4   Date            26400 non-null  datetime64[ns]
##  5   Confirmed       26400 non-null  int64         
##  6   Deaths          26400 non-null  int64         
##  7   Recovered       26400 non-null  int64         
##  8   Active          26400 non-null  int64         
## dtypes: datetime64[ns](1), float64(2), int64(4), object(2)
## memory usage: 1.8+ MB</code></pre>
<div class="sourceCode" id="cb267"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb267-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb267-1" tabindex="-1"></a>corona.head()</span></code></pre></div>
<pre><code>##   Province/State Country/Region      Lat  ...  Deaths Recovered  Active
## 0                   Afghanistan  33.0000  ...       0         0       0
## 1                       Albania  41.1533  ...       0         0       0
## 2                       Algeria  28.0339  ...       0         0       0
## 3                       Andorra  42.5063  ...       0         0       0
## 4                        Angola -11.2027  ...       0         0       0
## 
## [5 rows x 9 columns]</code></pre>
</div>
<div id="adatvizualizáció-data-frame-en-keresztül" class="section level3 hasAnchor" number="2.7.5">
<h3><span class="header-section-number">2.7.5</span> Adatvizualizáció data frame-en keresztül<a href="statisztikához-szükséges-python-nyelvi-alapok.html#adatvizualizáció-data-frame-en-keresztül" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Mentsük el a magyar adatokat egy új, <strong>Hungary</strong> nevű data frame-be!<br>
Ismét használjuk ki a dataframe logikai indexszálásának lehetőségét!</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb269-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb269-1" tabindex="-1"></a>Hungary <span class="op">=</span> corona[corona[<span class="st">&#39;Country/Region&#39;</span>]<span class="op">==</span><span class="st">&quot;Hungary&quot;</span>]</span>
<span id="cb269-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb269-2" tabindex="-1"></a>Hungary.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## Index: 100 entries, 129 to 26265
## Data columns (total 9 columns):
##  #   Column          Non-Null Count  Dtype         
## ---  ------          --------------  -----         
##  0   Province/State  100 non-null    object        
##  1   Country/Region  100 non-null    object        
##  2   Lat             100 non-null    float64       
##  3   Long            100 non-null    float64       
##  4   Date            100 non-null    datetime64[ns]
##  5   Confirmed       100 non-null    int64         
##  6   Deaths          100 non-null    int64         
##  7   Recovered       100 non-null    int64         
##  8   Active          100 non-null    int64         
## dtypes: datetime64[ns](1), float64(2), int64(4), object(2)
## memory usage: 7.8+ KB</code></pre>
<p>Szűrjük le az újonnan létrehozott dataframe-ből a március előtti napokat! A jó hír, hogy <code>datetime</code> adattípusú oszlopokra ugyan úgy működnek a relációs jelek, mint számokra.</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb271-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb271-1" tabindex="-1"></a>Hungary <span class="op">=</span> Hungary[Hungary[<span class="st">&#39;Date&#39;</span>] <span class="op">&gt;</span> <span class="st">&#39;2020-03-01&#39;</span>]</span>
<span id="cb271-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb271-2" tabindex="-1"></a>Hungary.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## Index: 60 entries, 10689 to 26265
## Data columns (total 9 columns):
##  #   Column          Non-Null Count  Dtype         
## ---  ------          --------------  -----         
##  0   Province/State  60 non-null     object        
##  1   Country/Region  60 non-null     object        
##  2   Lat             60 non-null     float64       
##  3   Long            60 non-null     float64       
##  4   Date            60 non-null     datetime64[ns]
##  5   Confirmed       60 non-null     int64         
##  6   Deaths          60 non-null     int64         
##  7   Recovered       60 non-null     int64         
##  8   Active          60 non-null     int64         
## dtypes: datetime64[ns](1), float64(2), int64(4), object(2)
## memory usage: 4.7+ KB</code></pre>
<p>Ábrázoljuk a COVID-19 magyar halottainak, gyógyultjainak és aktív eseteinek számát idő függvényében, halmozott területdiagramon a <code>matplotlib</code> segítségével!</p>
<p>Mivel a <code>matplotlib</code> együttműködik a <code>pandas</code>-al, így minden data frame-nek van külön metódusa a különböző diagramtípusokra. Pl. területdiagramra nem meglepő módon a <code>plot.area</code>. Ezek után csak a metódusban paraméterként meg kell adni, hogy mely oszlopok kerüljenek a diagram <span class="math inline">\(x\)</span> és <span class="math inline">\(y\)</span> tengelyeire. Illetve még egy extra paraméterben megadjuk, hogy <em>halmozott</em> diagramot szeretnénk készíteni: ez lesz a <code>stacked=True</code> paraméterbeállítás.</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb273-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb273-1" tabindex="-1"></a>Hungary.plot.area(x<span class="op">=</span><span class="st">&quot;Date&quot;</span>, y<span class="op">=</span>[<span class="st">&quot;Deaths&quot;</span>, <span class="st">&quot;Recovered&quot;</span>, <span class="st">&quot;Active&quot;</span>], stacked<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-87-1.png" width="672" /></p>
</div>
</div>
<div id="aggregálás-data-frame-ben" class="section level2 hasAnchor" number="2.8">
<h2><span class="header-section-number">2.8</span> Aggregálás data frame-ben<a href="statisztikához-szükséges-python-nyelvi-alapok.html#aggregálás-data-frame-ben" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Szűrjük le a corona dataframe-ből a legfrissebb adatokat minden országra egy új, corona_latest dataframe-be!<br>
Maximum függvényünk a <code>numpy</code> csomagból, tehát az <code>np</code> névtérből van.</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb274-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb274-1" tabindex="-1"></a>corona_latest <span class="op">=</span> corona[corona[<span class="st">&#39;Date&#39;</span>]<span class="op">==</span>np.<span class="bu">max</span>(corona[<span class="st">&#39;Date&#39;</span>])]</span>
<span id="cb274-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb274-2" tabindex="-1"></a>corona_latest.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## Index: 264 entries, 26136 to 26399
## Data columns (total 9 columns):
##  #   Column          Non-Null Count  Dtype         
## ---  ------          --------------  -----         
##  0   Province/State  264 non-null    object        
##  1   Country/Region  264 non-null    object        
##  2   Lat             264 non-null    float64       
##  3   Long            264 non-null    float64       
##  4   Date            264 non-null    datetime64[ns]
##  5   Confirmed       264 non-null    int64         
##  6   Deaths          264 non-null    int64         
##  7   Recovered       264 non-null    int64         
##  8   Active          264 non-null    int64         
## dtypes: datetime64[ns](1), float64(2), int64(4), object(2)
## memory usage: 20.6+ KB</code></pre>
<p>Itt mivel egy ország akár lehet több régióval is jelen a sorok között országnév szerint össze tudjuk adni az összes megerősített koronavírusos esetet (<em>Confirmed</em> oszlop elemei). Magyarul <strong>ország szintre szeretnénk összeg segítségével aggregálni</strong> a megerősített koronavírus esetek számát.</p>
<p>Ehhez először a data frame <code>groupby</code> metódusával csoportosítani kell a sorokat ország szintre, majd megadni az összegzendő oszlopot és elsütni ezen oszlop <code>sum</code> metódusát az összegzéshez. Ha a <code>sum</code>-ot <code>avg</code>-re vagy <code>median</code>-ra cseréljük, akkor a kiválasztott oszlopnak nem az összegét, hanem az átlagát, illetve mediánját tudjuk nézni országok szerint. Azaz <strong>átlaggal/mediánnal is aggregálhatunk az országok szintjére</strong>.</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb276-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb276-1" tabindex="-1"></a>corona_country <span class="op">=</span> corona_latest.groupby(<span class="st">&#39;Country/Region&#39;</span>)[<span class="st">&#39;Confirmed&#39;</span>].<span class="bu">sum</span>()</span>
<span id="cb276-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb276-2" tabindex="-1"></a></span>
<span id="cb276-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb276-3" tabindex="-1"></a>corona_country.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.series.Series&#39;&gt;
## Index: 187 entries, Afghanistan to Zimbabwe
## Series name: Confirmed
## Non-Null Count  Dtype
## --------------  -----
## 187 non-null    int64
## dtypes: int64(1)
## memory usage: 2.9+ KB</code></pre>
<div class="sourceCode" id="cb278"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb278-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb278-1" tabindex="-1"></a>corona_country.head()</span></code></pre></div>
<pre><code>## Country/Region
## Afghanistan    2171
## Albania         773
## Algeria        4006
## Andorra         745
## Angola           27
## Name: Confirmed, dtype: int64</code></pre>
<p>Az eredmény nem egy data frame, hanem mint láthatjuk egy <code>Series</code> lett, ami ugyebár logikailag egy <code>numpy</code> tömb! Mivel a <code>groupby</code> során az országok nevéből lett az új sorindex, így csak 1 oszlopunk maradt, az összegzett megerősített esetszám.</p>
<p>Ha azt szeretnénk, hogy a <strong>corona_country</strong>-ben az országok neve ne indexként, hanem külön oszlopként szerepeljen, akkor használjuk a <code>reset_index()</code> metódust!</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb280-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb280-1" tabindex="-1"></a>corona_country <span class="op">=</span> corona_country.reset_index()</span>
<span id="cb280-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb280-2" tabindex="-1"></a></span>
<span id="cb280-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb280-3" tabindex="-1"></a>corona_country.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 187 entries, 0 to 186
## Data columns (total 2 columns):
##  #   Column          Non-Null Count  Dtype 
## ---  ------          --------------  ----- 
##  0   Country/Region  187 non-null    object
##  1   Confirmed       187 non-null    int64 
## dtypes: int64(1), object(1)
## memory usage: 3.1+ KB</code></pre>
<div class="sourceCode" id="cb282"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb282-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb282-1" tabindex="-1"></a>corona_country.head()</span></code></pre></div>
<pre><code>##   Country/Region  Confirmed
## 0    Afghanistan       2171
## 1        Albania        773
## 2        Algeria       4006
## 3        Andorra        745
## 4         Angola         27</code></pre>
<p>Amennyiben a <code>groupby</code> metódus után egy általánosabb <code>agg</code> metódust használunk, akkor a <code>groupby</code>-ban megadott csoportosítás szerint egyszerre több művelet segítségével is összesíthetjük, azaz aggregálhatjuk a számértékű oszlop értékeit (pl. egyszerre nézünk átlagos és medián esetszámokat), Vagy akár több számértékű oszlopot is aggregálhatunk a <code>groupby</code> paraméterei szerint (pl. egyszerre nézünk átlagos esetszámot és halálozást is). Ráadásul, el is tudjuk nevezni az <code>agg</code> függvényen belül az újonnan létrehozott összesítő, azaz aggregált oszlopokat!<br>
Annyi trükk van a dologban, hogy az aggregáláshoz használt függvényeket (medián, átlag, szórás, stb.) a <code>numpy</code> csomagból szedjük ki az <code>np.</code> előtaggal!</p>
<p>Szóval a következő kódrészletben az <code>AtlagAktiv = ("Active", np.mean)</code> rész azt jelenti majd pl, hogy az <em>AtlagAktiv</em> oszlop a létrehozandó kimutatástáblában az eredeti data frame <em>Active</em> oszlopának átlaggal, azaz <code>np.mean</code> függvényével országos szintre összesített (“<em>groupby</em>”-olt) értékeit tartalmazza.</p>
<p>Na, akkor mostmár tényleg készítsünk el egy ország szintű kimutatást az átlagos és medián aktív koronavírus eseteiről, illetve átlagos és medián halálozási számairól a legfrisebb dátumra! Azt is megtehetjük, hogy már az aggregáló kód végére rögtön odatoljuk a <code>reset_index</code>-et.</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb284-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb284-1" tabindex="-1"></a>corona_kimutatas <span class="op">=</span> corona_latest.groupby(<span class="st">&#39;Country/Region&#39;</span>).agg(</span>
<span id="cb284-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb284-2" tabindex="-1"></a>  AtlagAktiv <span class="op">=</span> (<span class="st">&quot;Active&quot;</span>, np.mean),</span>
<span id="cb284-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb284-3" tabindex="-1"></a>  MedianAktiv <span class="op">=</span> (<span class="st">&quot;Active&quot;</span>, np.median),</span>
<span id="cb284-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb284-4" tabindex="-1"></a>  AtlagHalal <span class="op">=</span> (<span class="st">&quot;Deaths&quot;</span>, np.mean),</span>
<span id="cb284-5"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb284-5" tabindex="-1"></a>  MedianHalal <span class="op">=</span> (<span class="st">&quot;Deaths&quot;</span>, np.median)</span>
<span id="cb284-6"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb284-6" tabindex="-1"></a>).reset_index()</span></code></pre></div>
<pre><code>## &lt;string&gt;:1: FutureWarning: The provided callable &lt;function mean at 0x0000021B1B4313A0&gt; is currently using SeriesGroupBy.mean. In a future version of pandas, the provided callable will be used directly. To keep current behavior pass the string &quot;mean&quot; instead.
## &lt;string&gt;:1: FutureWarning: The provided callable &lt;function median at 0x0000021B1B5F8720&gt; is currently using SeriesGroupBy.median. In a future version of pandas, the provided callable will be used directly. To keep current behavior pass the string &quot;median&quot; instead.
## &lt;string&gt;:1: FutureWarning: The provided callable &lt;function mean at 0x0000021B1B4313A0&gt; is currently using SeriesGroupBy.mean. In a future version of pandas, the provided callable will be used directly. To keep current behavior pass the string &quot;mean&quot; instead.</code></pre>
<div class="sourceCode" id="cb286"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb286-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb286-1" tabindex="-1"></a>corona_kimutatas</span></code></pre></div>
<pre><code>##          Country/Region  AtlagAktiv  MedianAktiv  AtlagHalal  MedianHalal
## 0           Afghanistan      1847.0       1847.0        64.0         64.0
## 1               Albania       272.0        272.0        31.0         31.0
## 2               Algeria      1777.0       1777.0       450.0        450.0
## 3               Andorra       235.0        235.0        42.0         42.0
## 4                Angola        18.0         18.0         2.0          2.0
## ..                  ...         ...          ...         ...          ...
## 182  West Bank and Gaza       266.0        266.0         2.0          2.0
## 183      Western Sahara         1.0          1.0         0.0          0.0
## 184               Yemen         4.0          4.0         2.0          2.0
## 185              Zambia        48.0         48.0         3.0          3.0
## 186            Zimbabwe        31.0         31.0         4.0          4.0
## 
## [187 rows x 5 columns]</code></pre>
<p>Azt látjuk, hogy az átlag és medián értékek mind az aktív esetek számára, mind a halálozási számokra megegyeznek. Ez azért van, mert a legtöbb ország ugyebár nem volt lebontva államokra és provinciákra, szóval egy nap csak egy érték érkezett a táblába rájuk mindenből. Egy értéknek pedig nyilván ugyan az az átlaga és a mediánja is! :)</p>
<p>Na, de lessünk meg pár olyan országot, ahol az adatok belső régiókra, provinciákra is le voltak bontva. Pl. Franciaország és az Egyesült Királyság ilyen országok voltak:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb288-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb288-1" tabindex="-1"></a>corona_kimutatas[corona_kimutatas[<span class="st">&quot;Country/Region&quot;</span>].isin([<span class="st">&quot;France&quot;</span>, <span class="st">&quot;United Kingdom&quot;</span>])]</span></code></pre></div>
<pre><code>##      Country/Region    AtlagAktiv  MedianAktiv   AtlagHalal  MedianHalal
## 62           France   8409.909091         31.0  2219.090909          1.0
## 177  United Kingdom  13161.818182         13.0  2440.181818          1.0</code></pre>
<p>Na itt már látszik az eltérés! Pl. a francia tartományok felében legfeljebb <span class="math inline">\(31\)</span> aktív koronavírusos eset volt csak 2020.04.30-án, de a tartományok átlagában az érték már kerektíve <span class="math inline">\(8410\)</span> eset! Ezt valószínűleg egy vagy kettő kiugróan sok esettel rendlkező tartomány okozza csak!</p>
</div>
<div id="egyszerű-leíró-statisztika-data-frame-ben" class="section level2 hasAnchor" number="2.9">
<h2><span class="header-section-number">2.9</span> Egyszerű leíró statisztika data frame-ben<a href="statisztikához-szükséges-python-nyelvi-alapok.html#egyszerű-leíró-statisztika-data-frame-ben" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>No, de most térjünk vissza a <strong>corona_country</strong> data frame-hez! Egyszerűsítsük az oszlopneveket! A data frame-k <code>columns</code> tulajdonságának felülírásával az oszlopnevek könnyen módosíthatók. Mivel ugye a <code>columns</code> tulajdonságban az összes oszlopnév szerepel listaként, így az új oszlopneveket listaként felsorolva [] jellel kell megadni.</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb290-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb290-1" tabindex="-1"></a>corona_country.columns<span class="op">=</span>[<span class="st">&#39;Country&#39;</span>, <span class="st">&#39;COVID_Cases&#39;</span>]</span>
<span id="cb290-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb290-2" tabindex="-1"></a></span>
<span id="cb290-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb290-3" tabindex="-1"></a>corona_country.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 187 entries, 0 to 186
## Data columns (total 2 columns):
##  #   Column       Non-Null Count  Dtype 
## ---  ------       --------------  ----- 
##  0   Country      187 non-null    object
##  1   COVID_Cases  187 non-null    int64 
## dtypes: int64(1), object(1)
## memory usage: 3.1+ KB</code></pre>
<p>Nézzünk egy komplett leíró statisztikát a <em>COVID_Cases</em> változóra/ismérvre/oszlopra a <code>describe</code> metódus segítségével. Kerekítsük az eredményeket 2 tizedesjegyre (<code>round</code> függvény).</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb292-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb292-1" tabindex="-1"></a><span class="bu">round</span>(corona_country.COVID_Cases.describe(),<span class="dv">2</span>)</span></code></pre></div>
<pre><code>## count        187.00
## mean       17416.26
## std        84414.11
## min            1.00
## 25%           97.50
## 50%          746.00
## 75%         6254.50
## max      1069424.00
## Name: COVID_Cases, dtype: float64</code></pre>
<p>Nézzük meg ezt az ordenáré módon jobbra elnyúló eloszlást hisztogramon és doboz ábrán is!</p>
<p>A hisztogramot simán a vizsgált oszlop <code>hist</code> metódusával le lehet kérni.</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb294-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb294-1" tabindex="-1"></a>corona_country.COVID_Cases.hist()</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-95-3.png" width="672" /></p>
<p>Alapból egyenlő hosszúságú osztályközötket képez a pitonállat a hisztogramokhoz, aminek a számát a <code>hist</code> függvényben a <code>bins</code> paraméteren keresztül tudjuk szabályozni.</p>
<p>Vigyük le pl. az osztályközök számát <span class="math inline">\(5\)</span>-re.</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb295-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb295-1" tabindex="-1"></a>corona_country.COVID_Cases.hist(bins<span class="op">=</span><span class="dv">5</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-96-5.png" width="672" /></p>
<p>A <code>boxplot</code> metódus már alapvetően data frame, és nem oszlop szinten működik, és a metódus paraméterében kell megadni, hogy mely oszlopra vagy oszlopokra (neveket listaként felsorolva [] jellel) akarjuk az ábrát. Tehát, a doboz ábrát egyszerre több oszlopra is lekérhetjük egy ábrán belülre akár. Majd mindjárt nézünk ilyet is. Ennek a doboz ábránál van értelme, hiszen doboz ábránál nincsenek osztályközök, amiknek a számát esetlegesen az ismérvünk (oszlopunk) eloszlására kell szabni.</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb296-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb296-1" tabindex="-1"></a>corona_country.boxplot(column<span class="op">=</span><span class="st">&quot;COVID_Cases&quot;</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-97-7.png" width="672" /></p>
</div>
<div id="adatminőségi-problémák-felismerése-és-kezelése-leíró-statisztika-segítségével" class="section level2 hasAnchor" number="2.10">
<h2><span class="header-section-number">2.10</span> Adatminőségi problémák felismerése és kezelése leíró statisztika segítségével<a href="statisztikához-szükséges-python-nyelvi-alapok.html#adatminőségi-problémák-felismerése-és-kezelése-leíró-statisztika-segítségével" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Olvassuk be a <a href="https://github.com/KoLa992/Statisztika-II-Python-Alapok/blob/main/population_by_country_2020.csv" target="_blank">population_by_country_2020.csv</a> nevű fájlt, és mentsük el a beolvasott adatokat egy <strong>population</strong> nevű data frame-be!</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb297-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb297-1" tabindex="-1"></a>population <span class="op">=</span> pd.read_csv(<span class="st">&#39;population_by_country_2020.csv&#39;</span>)</span>
<span id="cb297-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb297-2" tabindex="-1"></a>population.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 235 entries, 0 to 234
## Data columns (total 11 columns):
##  #   Column                   Non-Null Count  Dtype  
## ---  ------                   --------------  -----  
##  0   Country (or dependency)  235 non-null    object 
##  1   Population (2020)        235 non-null    int64  
##  2   Yearly Change            235 non-null    object 
##  3   Net Change               235 non-null    int64  
##  4   Density (P/Km²)          235 non-null    int64  
##  5   Land Area (Km²)          235 non-null    int64  
##  6   Migrants (net)           201 non-null    float64
##  7   Fert. Rate               235 non-null    object 
##  8   Med. Age                 235 non-null    object 
##  9   Urban Pop %              235 non-null    object 
##  10  World Share              235 non-null    object 
## dtypes: float64(1), int64(4), object(6)
## memory usage: 20.3+ KB</code></pre>
<p>A <strong>population</strong> dataframe-ből csak az országnév, népesség, népsűrűség és városi népesség aránya változókra lesz szükségünk.<br>
A többit törölhetjük is a data frame-ből! Mivel az oszlopnevekben mint fentebb láthatjuk elég sok a hányadék módon speciális karakter, így biztonságosabb most az oszlopokra a sorszámukkal hivatkozni. Láthatjuk az <code>info</code> metódus eredményéből, hogy a szükséges országnév, népesség, népsűrűség és városi népesség aránya oszlopok rendre a <span class="math inline">\(0,1,4,9\)</span> indexekkel bírnak.</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb299-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb299-1" tabindex="-1"></a>population <span class="op">=</span> population.iloc[:,[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">9</span>]]</span>
<span id="cb299-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb299-2" tabindex="-1"></a></span>
<span id="cb299-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb299-3" tabindex="-1"></a>population.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 235 entries, 0 to 234
## Data columns (total 4 columns):
##  #   Column                   Non-Null Count  Dtype 
## ---  ------                   --------------  ----- 
##  0   Country (or dependency)  235 non-null    object
##  1   Population (2020)        235 non-null    int64 
##  2   Density (P/Km²)          235 non-null    int64 
##  3   Urban Pop %              235 non-null    object
## dtypes: int64(2), object(2)
## memory usage: 7.5+ KB</code></pre>
<p>Egyszerűsítsük az oszlopneveket a population dataframe-ben!</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb301-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb301-1" tabindex="-1"></a>population.columns <span class="op">=</span> [<span class="st">&#39;Country&#39;</span>, <span class="st">&#39;Pop&#39;</span>, <span class="st">&#39;PopDensity&#39;</span>, <span class="st">&#39;UrbanPop&#39;</span>]</span>
<span id="cb301-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb301-2" tabindex="-1"></a></span>
<span id="cb301-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb301-3" tabindex="-1"></a>population.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 235 entries, 0 to 234
## Data columns (total 4 columns):
##  #   Column      Non-Null Count  Dtype 
## ---  ------      --------------  ----- 
##  0   Country     235 non-null    object
##  1   Pop         235 non-null    int64 
##  2   PopDensity  235 non-null    int64 
##  3   UrbanPop    235 non-null    object
## dtypes: int64(2), object(2)
## memory usage: 7.5+ KB</code></pre>
<p>Nézzük meg a population dataframe egyszerű leíró statisztikai mutatóit! Ha a <code>describe</code> metódust az egész data frame-n engedjük el, akkor minden numerikus (<code>int</code> vagy <code>float</code>) oszlopra megadja az alap leíró mutatókat.</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb303-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb303-1" tabindex="-1"></a><span class="bu">round</span>(population.describe(), <span class="dv">2</span>)</span></code></pre></div>
<pre><code>##                 Pop  PopDensity
## count  2.350000e+02      235.00
## mean   3.316936e+07      475.77
## std    1.351374e+08     2331.29
## min    8.010000e+02        0.00
## 25%    3.988760e+05       37.00
## 50%    5.459642e+06       95.00
## 75%    2.057705e+07      239.50
## max    1.439324e+09    26337.00</code></pre>
<p>Az <em>UrbanPop</em> változónak mi baja? Elviekben az egy arányszám, annak is számnak kéne lennie, és meg kéne jelennie a <code>describe</code> metódus eredményében!</p>
<p>Kukkantsunk csak bele a data frame első 5 sorába!</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb305-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb305-1" tabindex="-1"></a>population.head()</span></code></pre></div>
<pre><code>##          Country         Pop  PopDensity UrbanPop
## 0          China  1439323776         153      61%
## 1          India  1380004385         464      35%
## 2  United States   331002651          36      83%
## 3      Indonesia   273523615         151      56%
## 4       Pakistan   220892340         287      35%</code></pre>
<p>Áhhá! Százalékjel van benne! Ezért veszi szöveges adatnak a pitonállat!</p>
<p>Szedjük le ezt a százalékjelet! Erre szerencsére az egyes data frame oszlopoknak van egy <code>str.replace</code> metódusa, amiben megadhatjuk paraméterekkel, hogy az oszlopban milyen szövegrészleteket mire akarunk cserélni. Itt most ugyebár százalékjelet fogunk üres stringre cserélni.</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb307-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb307-1" tabindex="-1"></a>population[<span class="st">&#39;UrbanPop&#39;</span>] <span class="op">=</span> population[<span class="st">&#39;UrbanPop&#39;</span>].<span class="bu">str</span>.replace(<span class="st">&#39;%&#39;</span>, <span class="st">&#39;&#39;</span>)</span>
<span id="cb307-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb307-2" tabindex="-1"></a></span>
<span id="cb307-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb307-3" tabindex="-1"></a>population.head()</span></code></pre></div>
<pre><code>##          Country         Pop  PopDensity UrbanPop
## 0          China  1439323776         153       61
## 1          India  1380004385         464       35
## 2  United States   331002651          36       83
## 3      Indonesia   273523615         151       56
## 4       Pakistan   220892340         287       35</code></pre>
<p>Ez jó, de sajnos vannak benne hiányzó értékek, amik nem a szabványos Python <code>NaN</code> kóddal vannak jelölve, hanem ilyen spéci <em>“N.A.”</em> stringgel, amit a gépállat nem ismer fel, így az egész oszlopot <code>str</code>-nek (<code>object</code>) veszi a <code>numpy</code> tömbök egységes adattípus logikája alapján.</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb309-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb309-1" tabindex="-1"></a>population.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 235 entries, 0 to 234
## Data columns (total 4 columns):
##  #   Column      Non-Null Count  Dtype 
## ---  ------      --------------  ----- 
##  0   Country     235 non-null    object
##  1   Pop         235 non-null    int64 
##  2   PopDensity  235 non-null    int64 
##  3   UrbanPop    235 non-null    object
## dtypes: int64(2), object(2)
## memory usage: 7.5+ KB</code></pre>
<p>Azt, hogy az <code>object</code> adattípus turpisságát az “N.A.”-k okozzák az UrbanPop oszlopban, arra leginkább az oszlop gyakorisági táblájából lehet felismerni. Ezt a gyakorisági táblát az oszlop <code>value_counts</code> metódusával tudjuk lekérni.</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb311-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb311-1" tabindex="-1"></a>population.UrbanPop.value_counts()</span></code></pre></div>
<pre><code>## UrbanPop
## N.A.    13
## 57       7
## 88       7
## 63       6
## 87       6
##         ..
## 50       1
## 81       1
## 28       1
## 37       1
## 10       1
## Name: count, Length: 81, dtype: int64</code></pre>
<p>Láthatjuk, hogy a sok számérték mellett, 13 ország esetén hiányzó értékünk van ezzel a csúnya “N.A.” kóddal.</p>
<p>Na, akkor! Most csináljuk azt, hogy leszűrjük azt a 13 országot, ahol hiányzik a városi népesség arányára vonatkozó adat!</p>
<p>Ezek után próbáljuk meg a városi népesség arányára vonatkozó adatot <code>int</code> típusúvá konvertálni! Ha sikerült, nézzük meg a változó alap leíró statisztikai mutatóit is!</p>
<p>Először logikai indexszeléssel leszűrjük az “N.A.”-kat.</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb313-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb313-1" tabindex="-1"></a>population <span class="op">=</span> population[population[<span class="st">&#39;UrbanPop&#39;</span>]<span class="op">!=</span><span class="st">&quot;N.A.&quot;</span>]</span></code></pre></div>
<p>Majd az oszlop <code>astype</code> metódusával <code>int</code>-é konvertáljuk az egész oszlopot. A metódus paraméterében kell megadni, hogy milyen adattípusra akarjuk konvertálni kiszemelt kis oszlopunk! :) Végül jöhet a <code>describe</code>.</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb314-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb314-1" tabindex="-1"></a>population[<span class="st">&#39;UrbanPop&#39;</span>] <span class="op">=</span> population[<span class="st">&#39;UrbanPop&#39;</span>].astype(<span class="bu">int</span>)</span>
<span id="cb314-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb314-2" tabindex="-1"></a></span>
<span id="cb314-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb314-3" tabindex="-1"></a>population.describe()</span></code></pre></div>
<pre><code>##                 Pop   PopDensity    UrbanPop
## count  2.220000e+02   222.000000  222.000000
## mean   3.488611e+07   186.373874   59.234234
## std    1.388508e+08   288.271695   24.230400
## min    1.357000e+03     0.000000    0.000000
## 25%    5.444048e+05    35.000000   43.000000
## 50%    5.911701e+06    89.000000   60.500000
## 75%    2.321589e+07   224.500000   79.000000
## max    1.439324e+09  2239.000000  100.000000</code></pre>
<p>Úgy tűnik, helyreállt a világ rendje! Már nagyon szépen le tudjuk olvasni pl., hogy a Föld országainak legzsúfoltabb <span class="math inline">\(25\%\)</span>-ban legalább <span class="math inline">\(79\)</span> fő/Km² a népsűrűség. És azt is látni a <code>count</code>ból, hogy már csak <span class="math inline">\(222\)</span> országunk van a kezdeti <span class="math inline">\(235\)</span> helyett, szóval nincsen itt a <span class="math inline">\(13\)</span> “N.A.”.</p>
</div>
<div id="data-frame-k-összekapcsolása" class="section level2 hasAnchor" number="2.11">
<h2><span class="header-section-number">2.11</span> Data frame-k összekapcsolása<a href="statisztikához-szükséges-python-nyelvi-alapok.html#data-frame-k-összekapcsolása" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Akkor most álmodjunk egy nagyot! Kössük össze a <strong>population</strong> data frame-ben található országonkénti alapvető demográfiai ismérveket a <strong>corona_country</strong> data frame-ben lakó országonkénti koronavírus esetszámokkal.</p>
<p>Nyilván ezt az összekötést az országok nevén keresztül lehet megtenni. Azaz pl. a magyar koronavírus esetszámokhoz a magyar demográfiai adatoknak kell kerülnie értelemszerűen. :)</p>
<p>A <code>pandas</code> csomagnak létezik egy <code>merge</code> névre hallgató függvénye, ami két data frame-et összeköt egy előre megadott közös oszlop alapján. Esetünkben ez a közös oszlop az országnév lesz.<br>
Ha egy kicsit “<em>adatbázisabbul</em>” szeretném kifejezni magam, akkor azt mondanám, hogy a <code>merge</code> függvény 2 tábla joinját oldja meg egy közös kulcs alapján.</p>
<p>Sőt, a <code>merge</code> függvény mindhárom alapvető táblakapcsolási módszert támogatja:</p>
<ul>
<li><strong>inner join</strong>: Az összekötött táblában csak azok a sorok maradnak meg, amelyek mindkét data frame-ben szerepelnek.</li>
<li><strong>left join</strong>: Az összekötött táblában csak azok a sorok maradnak meg, amelyek az elsőre megnevezett data frame-ben szerepelnek (attól függetlenül, hogy a másodszorra megnevezett táblában van-e hozzájuk találat).</li>
<li><strong>right join</strong>: Az összekötött táblában csak azok a sorok maradnak meg, amelyek a másodszorra megnevezett data frame-ben szerepelnek (attól függetlenül, hogy az elsőre megnevezett táblában van-e hozzájuk találat).</li>
<li><strong>full outer join</strong>: Az összekötött táblában mindkét tábla minden sora megmarad.</li>
</ul>
<p>A különböző típusú összekötési módokat remekül lehet halmazábrákkal szemléltetni:</p>
<center>
<img src="JoinVennDiagram.png" style="width:50.0%" />
</center>
<p>Na, akkor mielőtt a tényleges <code>merge</code>-hez hozzálátunk, annyit ellenőrizzünk le, hogy ugyanaz-e a neve az országneveket tartalmazó oszlopnak mindkét data frame-ben, a <strong>population</strong>ben és a <strong>corona_country</strong>-ban is:</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb316-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb316-1" tabindex="-1"></a>corona_country.columns</span></code></pre></div>
<pre><code>## Index([&#39;Country&#39;, &#39;COVID_Cases&#39;], dtype=&#39;object&#39;)</code></pre>
<div class="sourceCode" id="cb318"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb318-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb318-1" tabindex="-1"></a>population.columns</span></code></pre></div>
<pre><code>## Index([&#39;Country&#39;, &#39;Pop&#39;, &#39;PopDensity&#39;, &#39;UrbanPop&#39;], dtype=&#39;object&#39;)</code></pre>
<p>Szuper, mindkét táblában egységesen <strong>‘Country’</strong> az összekötésre használandó oszlop neve! Nem meglepő, mert mindkét táblában átneveztük már korábban az oszlopokat, de azért jobb biztosra menni. :)</p>
<p>Akkor lássuk azt a <code>merge</code>-t! Most egy olyan összekötést csinálunk, hogy a <strong>corona_country</strong> táblában lévő összes sorunk maradjon meg az összekötött táblában, mert alapvetően azok az országok érdekelnek, ahol megvan a COVID fertőzöttek száma. Ez az én data frame megadási sorrendben majd egy <em>left join</em>t fog jelenteni. :)</p>
<p>A <code>merge</code> függvényben a két data frame megadása után a <code>how</code> paraméter szabályozza a <em>join</em> jellegét, míg az <code>on</code> paraméterben adjuk meg az összekötésre használt oszlop nevét. A <em>join</em> tehát azért lesz <em>left</em>, mert a <strong>corona_country</strong>-t adtam meg először, azaz “<em>balrább</em>”. :)</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb320-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb320-1" tabindex="-1"></a>corona_extended <span class="op">=</span> pd.merge(corona_country, population, how<span class="op">=</span><span class="st">&#39;left&#39;</span>, on<span class="op">=</span><span class="st">&#39;Country&#39;</span>)</span>
<span id="cb320-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb320-2" tabindex="-1"></a>corona_extended.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 187 entries, 0 to 186
## Data columns (total 5 columns):
##  #   Column       Non-Null Count  Dtype  
## ---  ------       --------------  -----  
##  0   Country      187 non-null    object 
##  1   COVID_Cases  187 non-null    int64  
##  2   Pop          168 non-null    float64
##  3   PopDensity   168 non-null    float64
##  4   UrbanPop     168 non-null    float64
## dtypes: float64(3), int64(1), object(1)
## memory usage: 7.4+ KB</code></pre>
<p>Na, hát az új data frame <code>info</code> metódusa alapján van egy kis probléma. <span class="math inline">\(187-168=19\)</span> országra a <strong>corona_country</strong> data frame-ben nem volt találat a <strong>population</strong> data frame-ben.</p>
<div id="a-kapcsolási-kulcsnak-használt-oszlop-ellenőrzése-és-javítása" class="section level3 hasAnchor" number="2.11.1">
<h3><span class="header-section-number">2.11.1</span> A kapcsolási kulcsnak használt oszlop ellenőrzése és javítása<a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-kapcsolási-kulcsnak-használt-oszlop-ellenőrzése-és-javítása" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Lessük meg mik ezek az országok, ahol nem volt találat a <strong>population</strong> data frame-ben! Ezt pl. úgy tudjuk megtenni, hogy lekérdezzük a hiányzó értékek országát a <strong>Pop</strong> oszlopban.</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb322-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb322-1" tabindex="-1"></a>corona_extended.Country[corona_extended.Pop.isnull()<span class="op">==</span><span class="va">True</span>]</span></code></pre></div>
<pre><code>## 27                                Burma
## 39                  Congo (Brazzaville)
## 40                     Congo (Kinshasa)
## 42                        Cote d&#39;Ivoire
## 46                              Czechia
## 48                     Diamond Princess
## 75                             Holy See
## 91                               Kosovo
## 92                               Kuwait
## 102                          MS Zaandam
## 113                              Monaco
## 140               Saint Kitts and Nevis
## 142    Saint Vincent and the Grenadines
## 144               Sao Tome and Principe
## 150                           Singapore
## 164                             Taiwan*
## 173                                  US
## 180                           Venezuela
## 182                  West Bank and Gaza
## Name: Country, dtype: object</code></pre>
<p>Elnézegetve az országneveket kialakulhat bennünk valami sejtés: valószínűleg ezeket az országokat máshogy hívják a <strong>population</strong> data frame-ben, mint a <strong>corona_country</strong>-ban. Pl. <em>Taiwan</em> nevében valószínűleg nem lesz csillag, vagy <em>Czechia</em>-t inkább a hivatalosabb nevén jegyezheti a <strong>population</strong> tábla: <em>Czech Republic</em>. Esetleg a <em>US</em> is inkább <em>United States</em>-ként szerepelhet.</p>
<p>Teszteljük le ezeket az elméleteket egy egyszerű logikai indexes szűréssel az <code>isin</code> metódussal megtámogatva.</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb324-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb324-1" tabindex="-1"></a>population.Country[population.Country.isin([<span class="st">&quot;Czech Republic&quot;</span>, <span class="st">&quot;Taiwan&quot;</span>, <span class="st">&quot;United States&quot;</span>])]</span></code></pre></div>
<pre><code>## 2     United States
## 56           Taiwan
## Name: Country, dtype: object</code></pre>
<p>Mintha bejönne az okoskodásunk, de a cseheket csak nem akarja megtalálni a cucc. Próbáljunk meg úgy szűrni, hogy ne pontosan keressük ezeket az országneveket, hanem azt nézzük meg, hogy mik azok a sorok a <strong>population</strong> data frame-ben, amik ezeket az országneveket <em>tartalmazzák</em> valahol a <strong>Country</strong> oszlopban.<br>
Ezt egyszerűen el tudjuk érni úgy, hogy az előző kódunkban az <code>isin</code> metódust <code>str.contains</code>-re cseréljük. Annyi van, hogy itt a keresett string mintázatokat egy stringben kell megadni (azaz NEM listaként) “|” jellel elválasztva őket.<br>
Ez így amúgy egy úgynevezett <a href="http://vbence.web.elte.hu/regex_leiras.html">RegEx kifejezés</a>, és ilyenekkel lehet komplexebben működtetni ezt a <code>str.contains</code> metódust. Az érdeklődőknek jó kiindulópont a link. :)</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb326-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb326-1" tabindex="-1"></a>population.Country[population.Country.<span class="bu">str</span>.contains(<span class="st">&quot;Czech Republic|Taiwan|United States&quot;</span>)]</span></code></pre></div>
<pre><code>## 2                United States
## 56                      Taiwan
## 85    Czech Republic (Czechia)
## Name: Country, dtype: object</code></pre>
<p>Ó, hogy a kedves felmenőiket a <strong>population</strong> data frame alkotóinak: hát nem ott van zárójelben a <em>Czech Republic</em> mögött, hogy <em>Czechia</em>?! “<em>Ripsz!</em>”</p>
<p>Hát valami hasonló módon be kéne lőni a maradék 16 nem egyező országnevet is, de most ezzel nem húzzuk a drága időnket, hanem javítjuk ezt a 3 esetet és újra összekötjük a tábláinkat.<br>
Aki a nem egyértelmű kapcsoló oszlop (kulcs) alapján történő data frame összekötés világában szeretne elmélyedni, neki érdemes lehet majd előbb-utóbb utána néznie a <em>fuzzy join</em> technikáknak, amiket a Pythonban pl. a <a href="https://stackoverflow.com/questions/13636848/is-it-possible-to-do-fuzzy-match-merge-with-python-pandas">difflib csomag támogat</a>. De ezek a megoldások az itteni bevezető példának a kereteit bőven megugorják komplexitásban.</p>
<p>Szóval, akkor a 3 azonosított eltérő országnevet javítsuk a <strong>population</strong> data frame-ben. Azaz ott átírjuk ezeket az országneveket arra a verzióra, ami a <strong>corona_country</strong>-ban is szerepel. Ehhez megint az <code>str.replace</code>-t használjuk, mint anno az <strong>UrbanPop</strong> oszlop százalékjeleinek eltávolításakor. Ezt mindhárom esetben külön meg kell sajnos tenni.</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb328-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb328-1" tabindex="-1"></a>population[<span class="st">&#39;Country&#39;</span>] <span class="op">=</span> population[<span class="st">&#39;Country&#39;</span>].replace(<span class="st">&#39;United States&#39;</span>, <span class="st">&#39;US&#39;</span>)</span>
<span id="cb328-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb328-2" tabindex="-1"></a>population[<span class="st">&#39;Country&#39;</span>] <span class="op">=</span> population[<span class="st">&#39;Country&#39;</span>].replace(<span class="st">&#39;Czech Republic (Czechia)&#39;</span>, <span class="st">&#39;Czechia&#39;</span>)</span>
<span id="cb328-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb328-3" tabindex="-1"></a>population[<span class="st">&#39;Country&#39;</span>] <span class="op">=</span> population[<span class="st">&#39;Country&#39;</span>].replace(<span class="st">&#39;Taiwan&#39;</span>, <span class="st">&#39;Taiwan*&#39;</span>)</span></code></pre></div>
<p>És akkor lássuk újra azt a <code>merge</code>-t! Most a többi nem kezelt esetet eldobjuk, szóval <em>inner join</em>t csinálunk.</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb329-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb329-1" tabindex="-1"></a>corona_extended <span class="op">=</span> pd.merge(corona_country, population, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>, on<span class="op">=</span><span class="st">&#39;Country&#39;</span>)</span>
<span id="cb329-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb329-2" tabindex="-1"></a>corona_extended.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 171 entries, 0 to 170
## Data columns (total 5 columns):
##  #   Column       Non-Null Count  Dtype 
## ---  ------       --------------  ----- 
##  0   Country      171 non-null    object
##  1   COVID_Cases  171 non-null    int64 
##  2   Pop          171 non-null    int64 
##  3   PopDensity   171 non-null    int64 
##  4   UrbanPop     171 non-null    int32 
## dtypes: int32(1), int64(3), object(1)
## memory usage: 6.1+ KB</code></pre>
<p>Szupszi! Már nem <span class="math inline">\(168\)</span> sor van, amire van találat mindkét data frame-ben, mint az előbb, hanem <span class="math inline">\(171\)</span>, azaz pont a megjavított <span class="math inline">\(3\)</span> országgal több! Na, erre már elő lehet venni az ünnepi laposüveget (leánykori nevén lapiüvit)! ;)</p>
</div>
</div>
<div id="kilógó-értékek-keresése-és-kezelése" class="section level2 hasAnchor" number="2.12">
<h2><span class="header-section-number">2.12</span> Kilógó értékek keresése és kezelése<a href="statisztikához-szükséges-python-nyelvi-alapok.html#kilógó-értékek-keresése-és-kezelése" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>A sikeres data frame összekötési művelet örömére, számoljuk ki a <strong>corona_extended</strong> dataframe-ben az egymillió főre jutó COVID-19 esetek számát minden országra! Aztán nézzük is meg az oszlop leíró statisztikáit!</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb331-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb331-1" tabindex="-1"></a>corona_extended[<span class="st">&#39;COVID_perMillion&#39;</span>] <span class="op">=</span> corona_extended.COVID_Cases <span class="op">/</span> corona_extended.Pop <span class="op">*</span> <span class="dv">1000000</span></span>
<span id="cb331-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb331-2" tabindex="-1"></a>corona_extended[<span class="st">&#39;COVID_perMillion&#39;</span>].describe()</span></code></pre></div>
<pre><code>## count      171.000000
## mean       747.439425
## std       1775.534029
## min          0.201167
## 25%         19.420289
## 50%        119.830206
## 75%        700.197689
## max      16769.325985
## Name: COVID_perMillion, dtype: float64</code></pre>
<p>Na, szuper, itt is látszik egy csodás jobbra elnyúló eloszlás, hiszen az országok <span class="math inline">\(\frac{3}{4}\)</span>-ének az egymillió főre vetített COVID esetszáma nem haladja meg a <span class="math inline">\(700\)</span>-at, de ellenben a legnagyobb érték már majdnem <span class="math inline">\(17\)</span> ezer fő! Ellenben az alsó <span class="math inline">\(25\%\)</span> határa, a <span class="math inline">\(19.4\)</span> egészen közel van a minimumhoz, a <span class="math inline">\(0.2\)</span>-höz. Szóval valószínűleg brutál felfelé kilógó elemeink vannak.</p>
<p>Ezt erősítsük is meg egy doboz ábrán.</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb333-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb333-1" tabindex="-1"></a>corona_extended.boxplot(column<span class="op">=</span><span class="st">&quot;COVID_perMillion&quot;</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-116-9.png" width="672" /></p>
<p>Az ábra alapján nagyjából olyan 3000 feletti értékek tűnnek extrém módon kilógónak (kb. 3000-nél van az első szakadás a dobozban a ponttal jelölt kilógó értékek körében; a szakadás alatti részek, még kb a normál adatok “természetes” folytatásának tekinthetők). Lássuk hát, hogy mik ezek!</p>
<p>Rendezzük a <strong>COVID_perMillion</strong> szerint csökkenő sorrendbe a data frame-t, és kérjük le a sorbarendezett verzióból azokat az értékeket, ahol a <strong>COVID_perMillion</strong> nagyobb, mint 3000!</p>
<p>A data frame-t sorba rendezni a <code>sort_values</code> metódussal lehet, amelynek paraméterében meg kell adni, hogy mely oszlop alapján rendezünk, és hogy a sorrend csökkenő vagy növekvő-e. Majd ezen a rendezett állapoton elsüthetünk pl. egy iloc-ot az első 10 sor kiválasztásához.</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb334-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb334-1" tabindex="-1"></a>corona_extended.sort_values(<span class="st">&#39;COVID_perMillion&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>).loc[corona_extended[<span class="st">&#39;COVID_perMillion&#39;</span>] <span class="op">&gt;</span> <span class="dv">3000</span>,:]</span></code></pre></div>
<pre><code>##          Country  COVID_Cases  ...  UrbanPop  COVID_perMillion
## 131   San Marino          569  ...        97      16769.325985
## 3        Andorra          745  ...        88       9642.140685
## 93    Luxembourg         3784  ...        88       6044.940877
## 72       Iceland         1797  ...        94       5266.042087
## 126        Qatar        13409  ...        96       4654.201086
## 143        Spain       213435  ...        80       4564.987989
## 16       Belgium        48519  ...        98       4186.417453
## 77       Ireland        20612  ...        63       4174.340484
## 148  Switzerland        29586  ...        74       3418.520185
## 79         Italy       205463  ...        69       3398.226842
## 159           US      1069424  ...        83       3230.862341
## 
## [11 rows x 6 columns]</code></pre>
<p>Na, úgy néz ki, hogy az érintett országok töbségében ilyen jó kicsi, zsúfolt államok. Persze vannak extrém kivételek, pl. ugye az olaszok a nagy repülős turistaforgalmuk miatt.</p>
<p>Na, ezeket az extrém módon kilógó értékeket kipucoljuk a data frame-ből, aztán ránézünk újra a <strong>COVID_perMillion</strong> doboz ábrájára. Most a kilógó értékeket vegyük csak a 4000 feletti esetszámoknak, mivel a sorrend alapján van egy nagyobb ugrás ott a svájci 3418-ról az ír 4174-re. Meg a doboz ábrán is látszik, hogy ez az utolsó 3 érték ebben a “toplistában” még azért közelebb van az adatok “természetes folytatásához”, és utána jön még egy ugrás az egymillió főre vetített esetszámokban.</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb336-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb336-1" tabindex="-1"></a>corona_extended <span class="op">=</span> corona_extended[corona_extended[<span class="st">&#39;COVID_perMillion&#39;</span>] <span class="op">&lt;</span> <span class="dv">4000</span>]</span>
<span id="cb336-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb336-2" tabindex="-1"></a>corona_extended.boxplot(column<span class="op">=</span><span class="st">&quot;COVID_perMillion&quot;</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-118-11.png" width="672" /></p>
<p>Ez már egy kulturáltabb jobbra elnyúló eloszlás. Viszont, a medián még mindig túlságosan közel van az alsó kvartilishez, és a felső kvartilis eléggé elszakad.</p>
<p>Ennek szellemében még nézzünk rá arra, hogy mely országok esnek az egymillió főre jutó COVID esetszám szerint az alsó kvintilisbe!</p>
<p>Egy data frame oszlop alsó kvintilisét az oszlop <code>quantile</code> metódusával számoljuk ki. A metódus alapvetően egy tetszőleges percentilist számol ki. Azt, hogy melyiket, azt a metódus paraméterében kell megadni <span class="math inline">\(0-1\)</span> közötti számként. Szóval az alsó kvintilis alias 20. percentilis, ami alatt az adatok <span class="math inline">\(20\%\)</span>-a található, egy <span class="math inline">\(0.2\)</span> paraméterrel lesz megadható.</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb337-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb337-1" tabindex="-1"></a>corona_extended[<span class="st">&#39;COVID_perMillion&#39;</span>].quantile(<span class="fl">0.2</span>)</span></code></pre></div>
<pre><code>## 10.058723607815136</code></pre>
<p>Ezt a fenti kódot felhasználva egy logikai indexes szűrésben gyorsan meg is lesznek a népességarányos esetszám szerinti alsó kvintilisbe tartozó országok nevei is.</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb339-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb339-1" tabindex="-1"></a>corona_extended[corona_extended[<span class="st">&#39;COVID_perMillion&#39;</span>] <span class="op">&lt;</span> </span>
<span id="cb339-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb339-2" tabindex="-1"></a>               corona_extended[<span class="st">&#39;COVID_perMillion&#39;</span>].quantile(<span class="fl">0.2</span>)]</span></code></pre></div>
<pre><code>##               Country  COVID_Cases  ...  UrbanPop  COVID_perMillion
## 4              Angola           27  ...        67          0.821511
## 18              Benin           64  ...        48          5.279134
## 19             Bhutan            7  ...        46          9.071964
## 22           Botswana           23  ...        73          9.780463
## 27            Burundi           11  ...        14          0.925086
## 29           Cambodia          122  ...        24          7.297102
## 33               Chad           73  ...        23          4.444211
## 37            Comoros            1  ...        29          1.149953
## 54           Ethiopia          131  ...        21          1.139491
## 59             Gambia           11  ...        59          4.551722
## 69              Haiti           81  ...        57          7.103688
## 84              Kenya          396  ...        28          7.364524
## 86               Laos           19  ...        36          2.611483
## 90              Libya           61  ...        78          8.877515
## 94         Madagascar          128  ...        39          4.622437
## 95             Malawi           37  ...        18          1.934140
## 100        Mauritania            8  ...        57          1.720557
## 107        Mozambique           76  ...        38          2.431577
## 108           Namibia           16  ...        55          6.296969
## 109             Nepal           57  ...        21          1.956288
## 112         Nicaragua           14  ...        57          2.113350
## 114           Nigeria         1932  ...        52          9.372290
## 120  Papua New Guinea            8  ...        13          0.894152
## 142       South Sudan           35  ...        25          3.126752
## 149             Syria           43  ...        60          2.457050
## 151        Tajikistan           15  ...        27          1.572715
## 152          Tanzania          480  ...        37          8.035595
## 160            Uganda           83  ...        26          1.814564
## 166           Vietnam          270  ...        38          2.773823
## 167    Western Sahara            6  ...        87         10.044548
## 168             Yemen            6  ...        38          0.201167
## 169            Zambia          106  ...        45          5.765897
## 170          Zimbabwe           40  ...        38          2.691260
## 
## [33 rows x 6 columns]</code></pre>
<p>Az eredmények alapján úgy néz ki, hogy az egymillió főre jutó COVID esetszám szerinti alsó kvintilisbe elsősorban olyan afrikai országok esnek, ahol még 2020.04.30-án egyelőre nem tört ki tömeges járvány!</p>
<p>Ezeket az országokat távolítsuk el a corona_country dataframe-ből!<br>
Majd ezután tekintsük meg ismét az egymillió főre jutó COVID esetszám hisztogramját, és doboz ábráját!</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb341-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb341-1" tabindex="-1"></a>corona_extended <span class="op">=</span> corona_extended[corona_extended[<span class="st">&#39;COVID_perMillion&#39;</span>] <span class="op">&gt;</span></span>
<span id="cb341-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb341-2" tabindex="-1"></a>                                corona_extended[<span class="st">&#39;COVID_perMillion&#39;</span>].quantile(<span class="fl">.2</span>)]</span>
<span id="cb341-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb341-3" tabindex="-1"></a></span>
<span id="cb341-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb341-4" tabindex="-1"></a>corona_extended.boxplot(column<span class="op">=</span><span class="st">&quot;COVID_perMillion&quot;</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-121-13.png" width="672" /></p>
<p>Na, ez már kb úgy néz ki, mint egy “egészségesen” jobbra elnyúló eloszlás doboz ábrája! :)</p>
</div>
<div id="korrelációs-elemzések-data-frame-ben" class="section level2 hasAnchor" number="2.13">
<h2><span class="header-section-number">2.13</span> Korrelációs elemzések data frame-ben<a href="statisztikához-szükséges-python-nyelvi-alapok.html#korrelációs-elemzések-data-frame-ben" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Nézzünk rá a numerikus adattípusú oszlopok közti korrelációs mátrixra. Egyedül a <strong>Pop</strong> és <strong>COVID_Cases</strong> oszlopokat hagyjuk ki a vizsgálatból, mert azok abszolút és nem népességarányos adatok, így csalóka lenne őket szerepeltetni a korrelációs vizsgálatokban, hiszen “triviálisan” korrelálnak: nagyobb népességű országban nyilván több az összes esetszám. :)</p>
<p>Azt, hogy csak két oszlopot ne válasszunk ki egy data frame-ben úgy tudjuk elérni, hogy a data frame oszlopnevei közül egy <code>isin</code> metódussal kiválasztjuk a két kihagyandó oszlopot, majd az eredményt letagadjuk egy <code>~</code> jellel. Ezt a műveletet pedig beágyazzuk egy <code>loc</code> metódusba, és meg is vagyunk! :)</p>
<div class="sourceCode" id="cb342"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb342-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb342-1" tabindex="-1"></a>corona_extended.loc[:,<span class="op">~</span>corona_extended.columns.isin([<span class="st">&#39;COVID_Cases&#39;</span>, <span class="st">&#39;Pop&#39;</span>])]</span></code></pre></div>
<pre><code>##                   Country  PopDensity  UrbanPop  COVID_perMillion
## 0             Afghanistan          60        25         55.769130
## 1                 Albania         105        63        268.608244
## 2                 Algeria          18        73         91.354724
## 5     Antigua and Barbuda         223        26        245.075514
## 6               Argentina          17        93         97.973762
## ..                    ...         ...       ...               ...
## 161               Ukraine          75        69        237.939741
## 162  United Arab Emirates         118        86       1261.930506
## 163        United Kingdom         281        83       2540.744366
## 164               Uruguay          20        96        185.103621
## 165            Uzbekistan          79        50         60.921678
## 
## [130 rows x 4 columns]</code></pre>
<p>Erre az oszlopaiban megvágott data frame-re pedig egy <code>corr</code> nevű metódust tudunk alkalmazni, ami megadja a numerikus oszlopok közti korrelációk mátrixszát. Figyeljünk még arra, hogy a <strong>Country</strong> oszlopot is ki kell szedni a korrelációszámításban érintett oszlopok közül, hiszen nem numerikus adattípusú, így a korrelációszámítás nem értelmezett rajta! Ennyire azért nem okos ez a pitonka kígyócska! :)</p>
<div class="sourceCode" id="cb344"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb344-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb344-1" tabindex="-1"></a>corona_extended.loc[:,<span class="op">~</span>corona_extended.columns.isin([<span class="st">&#39;Country&#39;</span>, <span class="st">&#39;COVID_Cases&#39;</span>, <span class="st">&#39;Pop&#39;</span>])].corr()</span></code></pre></div>
<pre><code>##                   PopDensity  UrbanPop  COVID_perMillion
## PopDensity          1.000000 -0.051282          0.118036
## UrbanPop           -0.051282  1.000000          0.341160
## COVID_perMillion    0.118036  0.341160          1.000000</code></pre>
<p>A korrelációs mátrixból látszik, hogy az egymillió főre jutó COVID esetszám leginkább a városi népesség arányával függ össze, teljesen logikus módon: egyirányú, közepes erősségű a kapcsolat. A zsúfolt városi közösségi tereken, tömegközlekedésen könnyebb megfertőződni. :)</p>
<p>Nézzük is meg a kapcsolatot pontdiagramon! Teljesen úgy működik a pontdiagram is, mint pl. a korábbiakban a magyar adatokon látott területdiagram, csak a metódus neve nem <code>plot.area</code>, hanem <code>plot.scatter</code>. :)</p>
<div class="sourceCode" id="cb346"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb346-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb346-1" tabindex="-1"></a>corona_extended.plot.scatter(x<span class="op">=</span><span class="st">&quot;UrbanPop&quot;</span>, y<span class="op">=</span><span class="st">&quot;COVID_perMillion&quot;</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-124-15.png" width="672" /></p>
<p>A pontdiagramon azt vehetjük észre, hogy az egymillió főre jutó COVID esetszám jobbra elnyúló eloszlása miatt jelenlévő felfelé kiugró értékek befolyásolják a két ismérv kapcsolatát. A kilógóan magas esetszámok miatt úgy tűnik, mintha az 500 alatti esetszámú országokban nem is lenne kapcsolat a két ismérv között.<br>
A városi népesség arányával nincsenek ilyen problémák, mivel annak eloszlása közel szimmetrikus.</p>
<p>A két ismérv/oszlop eloszlásáról írtakat a hisztogramokon is meg lehet lesni.</p>
<p>Az egymillió főre jutó esetszám hisztogramja, ami elég jobbra elnyúló.</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb347-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb347-1" tabindex="-1"></a>corona_extended.COVID_perMillion.hist()</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-125-17.png" width="672" /></p>
<p>És a városi népesség arányáé, ami szimmetrikusabb egy fokkal, de némileg inkább balra elnyúló. A lényeg, hogy ezen nem segít a logaritmus. :)</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb348-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb348-1" tabindex="-1"></a>corona_extended.UrbanPop.hist()</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-126-19.png" width="672" /></p>
<p>A kiugró értékek hatását, és az <strong>eloszlás jobbra elnyúlóból közel szimmetrikussá alakítását logaritmussal</strong> lehet elérni.</p>
<p>Készítsük is el a <strong>COVID_perMillion</strong> oszlop természetes alapú logaritmusát egy új oszlopban a data frame-n belül.</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb349-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb349-1" tabindex="-1"></a>corona_extended[<span class="st">&#39;log_COVID_perMillion&#39;</span>] <span class="op">=</span> np.log(corona_extended[<span class="st">&#39;COVID_perMillion&#39;</span>])</span></code></pre></div>
<p>Ezek után lessünk rá az új oszlop hisztogramjára:</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb350-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb350-1" tabindex="-1"></a>corona_extended.log_COVID_perMillion.hist()</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-128-21.png" width="672" /></p>
<p>Sokkal szebb! :) Legalábbis szimmetria szempontjából biztos. Viszont van benne azért egy kétmóduszú jelleg. Ez azt jelenti, hogy van az országoknak egy jelentősebb csoportja, ahol emelkedettebb a népességarányos COVID esetszám, mint az országok többségében, akik az alacsonyabb értéktartományban lévő “első móduszt” adják.</p>
<p>A korreláció az esetszám logaritmusa és a városi népesség aránya között pedig feljavul. Abszolút értékben több, mint <span class="math inline">\(0.1\)</span> egységet emelkedik a korreláció, ami nem elhanyagolható mértéjű javulás. :) Most a korrelációs mátrixból kivesszük a <strong>PopDensity</strong>-t is, hogy áttekinthetőbb legyen.</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb351-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb351-1" tabindex="-1"></a>corona_extended.loc[:,<span class="op">~</span>corona_extended.columns.isin([<span class="st">&#39;Country&#39;</span>, <span class="st">&#39;COVID_Cases&#39;</span>, <span class="st">&#39;Pop&#39;</span>, <span class="st">&#39;PopDensity&#39;</span>])].corr()</span></code></pre></div>
<pre><code>##                       UrbanPop  COVID_perMillion  log_COVID_perMillion
## UrbanPop              1.000000          0.341160              0.464379
## COVID_perMillion      0.341160          1.000000              0.826654
## log_COVID_perMillion  0.464379          0.826654              1.000000</code></pre>
<p>A korreláció abszolút értékében bekövetkezett javulás oka szépen látható a pontdiagramon: nincsenek már olyan durva outlierek a pontdiagramon. A pontokra nagyobb pontossággal illeszthető egy képzeletbeli egyenes a teljes tartományon nem csak az 500 feletti egymilliófőre vetített esetszámmal bíró országokban.</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb353-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb353-1" tabindex="-1"></a>corona_extended.plot.scatter(x<span class="op">=</span><span class="st">&quot;UrbanPop&quot;</span>, y<span class="op">=</span><span class="st">&quot;log_COVID_perMillion&quot;</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-130-23.png" width="672" /></p>
<p>Annyit lehet látni, hogy van egy ország, aminek hatalmas az egymillió főre jutó COVID esetszáma az elég alacsony, <span class="math inline">\(20\%\)</span> alatti városi népesség arányához képest. Jó lenne rájönni mi ez az ország!</p>
<p>Ehhez csináljunk egy olyan verziót az előző pontdiagramból, amin minden ponton szerepel, hogy az melyik országot jelöli.</p>
<p>Ennek elkészítéséhez felhasználunk egy <code>enumerate</code> névre hallgató függvényt. Ha ezt a függvényt ráeresztjük a <strong>Country</strong> oszlopra a data frame-ben, és az eredményt egy <code>for</code> ciklussal bejárjuk, akkor igazából két listát is bejárunk prhuzamosan:</p>
<ul>
<li>Egyet, ami az ország sorszámát mutatja a data frame-ben <span class="math inline">\(0\)</span>-tól indexszelve. Ezt hívom én <code>sorszám</code>-nak.</li>
<li>A másik listában pedig az országnevek vannak. Ez a kódban <code>szöveg</code>-nek becézem.</li>
</ul>
<p>Fontos, hogy a két listát bejáró változó neve teljesen tetszőleges, akár “kismacska” és “gumimaci” is lehetnének. :)</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb354-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb354-1" tabindex="-1"></a><span class="cf">for</span> sorszám, szöveg <span class="kw">in</span> <span class="bu">enumerate</span>(corona_extended.Country):</span>
<span id="cb354-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb354-2" tabindex="-1"></a>   <span class="bu">print</span>(sorszám)</span>
<span id="cb354-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb354-3" tabindex="-1"></a>   <span class="bu">print</span>(szöveg)</span></code></pre></div>
<pre><code>## 0
## Afghanistan
## 1
## Albania
## 2
## Algeria
## 3
## Antigua and Barbuda
## 4
## Argentina
## 5
## Armenia
## 6
## Australia
## 7
## Austria
## 8
## Azerbaijan
## 9
## Bahamas</code></pre>
<p>És ez így folytatódik tovább a data frame összes sorára, csak most ide nem íratom ki a több mint 100 értéket. :)</p>
<p>Na, ezt az <code>enumerate</code>-t használó <code>for</code> ciklust úgy hasznosítjuk, hogy először egy külön <code>fig</code> című objektumba elmentjk az alap pontdiagramos ábrát, amit az előbb is megcsináltunk.<br>
Aztán elindítjuk ezt a <code>for</code> ciklust az <code>enumerate</code> alapján, és a cikluson belül használjuk a <code>fig</code> objektum <code>annotate</code> metódusát, ami a pontok feliratozását valósítja meg. A metódus paramétereiben megadom először, hogy az aktuális <code>szöveg</code>-et, azaz az országnevet rakja fel, mint felirat.<br>
A következő paraméter, ami zárójelben van az csak optikai tuning. Ott azt csinálom, hogy az <span class="math inline">\(x,y\)</span> koordinátáknak megfelelő oszlopok konkrét, pontdiagramon lévő koordinátáit kérdezem le az oszlopok <code>iat</code> tulajdonságában. Ez két lista, így mindig a <em>sorszámadik</em> elemét nézem a cikluson belül. Ezen koordináták közül a diagram <span class="math inline">\(x\)</span> tengelyét adó <strong>UrbanPop</strong>-ét eltolom <span class="math inline">\(0.05\)</span>-tel. Így a pont felirata nem a pont középpontjában kezdődik, hanem attól <span class="math inline">\(0.05\)</span> egységgel jobbra. Így olvashatóbb lesz a cucc. :) Nyilván a felirat <span class="math inline">\(y\)</span> koordinátáját is tudnám itt szabályozni, és kedvem szerint fel-le rakni a felirat kezdőpontját, de erre itt nincs szükség, így az <code>annotate</code> paraméterben ezt a koordinátát csak csak változatlanul átadom.</p>
<p>Na, és lássuk is ezt a csodát működés közben! A kód végén egy <code>plt.show()</code> utasítással lehet a diagramot láthatóvá is tenni.</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb356-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb356-1" tabindex="-1"></a>fig <span class="op">=</span> corona_extended.plot.scatter(x<span class="op">=</span><span class="st">&quot;UrbanPop&quot;</span>, y<span class="op">=</span><span class="st">&quot;log_COVID_perMillion&quot;</span>)</span>
<span id="cb356-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb356-2" tabindex="-1"></a></span>
<span id="cb356-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb356-3" tabindex="-1"></a><span class="cf">for</span> sorszám, szöveg <span class="kw">in</span> <span class="bu">enumerate</span>(corona_extended.Country):</span>
<span id="cb356-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb356-4" tabindex="-1"></a>   fig.annotate(szöveg, (corona_extended.UrbanPop.iat[sorszám]<span class="op">+</span><span class="fl">0.05</span>, corona_extended.log_COVID_perMillion.iat[sorszám]))</span>
<span id="cb356-5"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb356-5" tabindex="-1"></a></span>
<span id="cb356-6"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb356-6" tabindex="-1"></a>plt.show()</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-133-25.png" width="672" /></p>
<p>E voilá: a gyanús kis államunk a magas esetszámával a kis városi népesség arány ellenére <em>Lichtenstein</em>! :) Érdekes észrevenni még, hogy pl. Taiwan elég jól áll: a városi népesség arányához képest elég alacsony az esetszáma! Magyarország, ha jól szemmelverjük, akkor látható, hogy gyakorlatilag pont a fő csapásirány közepén van kb: pont annyi nagyjából az esetszáma, amennyi a városi népesség aránya alapján “lennie kéne”. :)</p>
</div>
<div id="gyakorló-feladatok" class="section level2 unnumbered hasAnchor">
<h2>Gyakorló feladatok<a href="statisztikához-szükséges-python-nyelvi-alapok.html#gyakorló-feladatok" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<ol style="list-style-type: decimal">
<li>Olvassuk be az <a href="https://github.com/KoLa992/Statisztika-II-Python-Alapok/blob/main/index_2019_-_pour_import_1_1.csv" target="_blank">index_2019_-_pour_import_1_1.csv</a> nevű fájlt, és mentsük el a beolvasott adatokat egy <strong>PressLiberty</strong> nevű data frame-be!
<ul>
<li>Vigyázat! A fájlban tizedesvesszők vannak tizedes pont helyett! Használni kell a <code>read_csv</code> függvény <code>decimal</code> paraméterét! Meg kell a paraméterben adni, hogy a tizedeshelyeket a <code>','</code> karakter jelöli!</li>
</ul></li>
<li>A <strong>PressLiberty</strong> data frame-ből csak az angol országnév (<strong>EN_country</strong>) és a 2019-es sajtószabadsági index (<strong>Score 2019</strong>) oszlopkra lesz szükségünk. A sajtószabadsági indexben az alacsonyabb érték jelent szabadabb sajtót egy országban. A többi változót töröljuk ki a data frame-ből!</li>
<li>A szűkített <strong>PressLiberty</strong> data frame oszlopainak neve legyen <strong>Country</strong> és <strong>PressLiberty</strong>!</li>
<li>Változtassuk meg az Egyesült Államok nevét “<em>United States</em>”-ről “<em>US</em>”-re a <strong>PressLiberty</strong> data frame-ben, hogy az összeköthető legyen a <strong>corona_extended</strong> data frame-el az országneveken keresztül!</li>
<li>Inner Join művelet segítségével vezessük át a sajtószabadsági index vonatkozó adatokat a <strong>corona_extended</strong> data frame-be!</li>
<li>Ábrázoljuk a <strong>corona_extended</strong> data frame-ben a kapcsolatot a <strong>log_COVID_perMillion</strong> és <strong>PressLiberty</strong> ismérvek között pontdiagramon! Értelmezze röviden szövegesen is a kapcsolatot! Logikus-e a kapcsolat iránya?</li>
<li>Vizsgáljuk meg a <strong>PressLiberty</strong> eloszlását hisztogramon!</li>
<li>Adjuk hozzá a <strong>corona_extended</strong> data frame-hez a <strong>PressLiberty</strong> logaritmusát <strong>log_PressLiberty</strong> néven!</li>
<li>Nézzük meg a korrelációs mátrixot a <strong>log_COVID_perMillion</strong>, <strong>PressLiberty</strong> és <strong>log_PressLiberty</strong> ismérvek között! Volt-e értelme a logaritmus alkalmazásának? Válaszát röviden indokolja!</li>
<li>Ábrázoljuk a <strong>corona_extended</strong> data frame-ben a kapcsolatot a <strong>COVID_perMillion</strong> logaritmusa és a <strong>PressLiberty</strong> logaritmusa között pontdiagramon! Az egyes pontokon szerepeljen az országok neve is!
<ul>
<li>Van-e olyan ország, amelyik a két ismérv kapcsolatát leíró általános tendenciához képest eltérően viselkedik? Válaszát röviden indokolja!</li>
</ul></li>
</ol>
</div>
<div id="gyakorló-feladatok-megoldása" class="section level2 unnumbered hasAnchor">
<h2>Gyakorló feladatok megoldása<a href="statisztikához-szükséges-python-nyelvi-alapok.html#gyakorló-feladatok-megoldása" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="feladat" class="section level3 unnumbered hasAnchor">
<h3>1. feladat<a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="sourceCode" id="cb357"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb357-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb357-1" tabindex="-1"></a>PressLiberty <span class="op">=</span> pd.read_csv(<span class="st">&#39;index_2019_-_pour_import_1_1.csv&#39;</span>, decimal<span class="op">=</span><span class="st">&#39;,&#39;</span>)</span>
<span id="cb357-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb357-2" tabindex="-1"></a>PressLiberty.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 180 entries, 0 to 179
## Data columns (total 14 columns):
##  #   Column            Non-Null Count  Dtype  
## ---  ------            --------------  -----  
##  0   ISO               180 non-null    object 
##  1   Rank2019          180 non-null    int64  
##  2   FR_Country        180 non-null    object 
##  3   EN_country        180 non-null    object 
##  4   ES_country        180 non-null    object 
##  5   Score A           180 non-null    float64
##  6   Sco Exa           180 non-null    float64
##  7   Score 2019        180 non-null    float64
##  8   Progression RANK  180 non-null    int64  
##  9   Rank 2018         180 non-null    int64  
##  10  Score 2018        180 non-null    float64
##  11  Zone              180 non-null    object 
##  12  AR_country        180 non-null    object 
##  13  FA_country        180 non-null    object 
## dtypes: float64(4), int64(3), object(7)
## memory usage: 19.8+ KB</code></pre>
</div>
<div id="feladat-1" class="section level3 unnumbered hasAnchor">
<h3>2. feladat<a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="sourceCode" id="cb359"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb359-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb359-1" tabindex="-1"></a>PressLiberty <span class="op">=</span> PressLiberty.loc[:,[<span class="st">&#39;EN_country&#39;</span>, <span class="st">&#39;Score 2019&#39;</span>]]</span>
<span id="cb359-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb359-2" tabindex="-1"></a>PressLiberty.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 180 entries, 0 to 179
## Data columns (total 2 columns):
##  #   Column      Non-Null Count  Dtype  
## ---  ------      --------------  -----  
##  0   EN_country  180 non-null    object 
##  1   Score 2019  180 non-null    float64
## dtypes: float64(1), object(1)
## memory usage: 2.9+ KB</code></pre>
</div>
<div id="feladat-2" class="section level3 unnumbered hasAnchor">
<h3>3. feladat<a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-2" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="sourceCode" id="cb361"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb361-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb361-1" tabindex="-1"></a>PressLiberty.columns <span class="op">=</span> [<span class="st">&#39;Country&#39;</span>, <span class="st">&#39;PressLiberty&#39;</span>]</span>
<span id="cb361-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb361-2" tabindex="-1"></a>PressLiberty.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 180 entries, 0 to 179
## Data columns (total 2 columns):
##  #   Column        Non-Null Count  Dtype  
## ---  ------        --------------  -----  
##  0   Country       180 non-null    object 
##  1   PressLiberty  180 non-null    float64
## dtypes: float64(1), object(1)
## memory usage: 2.9+ KB</code></pre>
</div>
<div id="feladat-3" class="section level3 unnumbered hasAnchor">
<h3>4. feladat<a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-3" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="sourceCode" id="cb363"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb363-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb363-1" tabindex="-1"></a>PressLiberty[<span class="st">&#39;Country&#39;</span>] <span class="op">=</span> PressLiberty[<span class="st">&#39;Country&#39;</span>].replace(<span class="st">&#39;United States&#39;</span>, <span class="st">&#39;US&#39;</span>)</span></code></pre></div>
</div>
<div id="feladat-4" class="section level3 unnumbered hasAnchor">
<h3>5. feladat<a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-4" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="sourceCode" id="cb364"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb364-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb364-1" tabindex="-1"></a>corona_extended <span class="op">=</span> pd.merge(corona_extended, PressLiberty, how<span class="op">=</span><span class="st">&#39;inner&#39;</span>, on<span class="op">=</span><span class="st">&#39;Country&#39;</span>)</span>
<span id="cb364-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb364-2" tabindex="-1"></a>corona_extended.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 115 entries, 0 to 114
## Data columns (total 8 columns):
##  #   Column                Non-Null Count  Dtype  
## ---  ------                --------------  -----  
##  0   Country               115 non-null    object 
##  1   COVID_Cases           115 non-null    int64  
##  2   Pop                   115 non-null    int64  
##  3   PopDensity            115 non-null    int64  
##  4   UrbanPop              115 non-null    int32  
##  5   COVID_perMillion      115 non-null    float64
##  6   log_COVID_perMillion  115 non-null    float64
##  7   PressLiberty          115 non-null    float64
## dtypes: float64(3), int32(1), int64(3), object(1)
## memory usage: 6.9+ KB</code></pre>
</div>
<div id="feladat-5" class="section level3 unnumbered hasAnchor">
<h3>6. feladat<a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-5" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="sourceCode" id="cb366"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb366-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb366-1" tabindex="-1"></a>corona_extended.plot.scatter(x<span class="op">=</span><span class="st">&quot;PressLiberty&quot;</span>, y<span class="op">=</span><span class="st">&quot;log_COVID_perMillion&quot;</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-139-27.png" width="672" /></p>
<p>Úgy látszik, hogy a a kapcsolat ellentétes irányú: a sajtószabadsági index növekedésével jellemzően csökken az esetszám. Mivel a magasabb index jelenti a kevésbé szabad sajtót, így első olvasatra nem logikus a kapcsolat iránya: kevésbé szabad sajtóval rendelkező országokban kevesebb az esetszám egymillió főre nézve. De egy picit belegondolva lehet logikus a dolog: a szabadabb sajtóval rendelkező országok jellemzően gazdagabb országok is. Feltehetően ilyen országokban a COVID tesztelésre is több erőforrás jut.</p>
</div>
<div id="feladat-6" class="section level3 unnumbered hasAnchor">
<h3>7. feladat<a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-6" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="sourceCode" id="cb367"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb367-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb367-1" tabindex="-1"></a>corona_extended.PressLiberty.hist()</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-140-29.png" width="672" /></p>
<p>Az eloszlás némileg jobbra elnyúló, vannak felső irányban kiugró értékek. Érdemes lehet logaritmust alkalmazni az oszlopon.</p>
</div>
<div id="feladat-7" class="section level3 unnumbered hasAnchor">
<h3>8. feladat<a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-7" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="sourceCode" id="cb368"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb368-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb368-1" tabindex="-1"></a>corona_extended[<span class="st">&#39;log_PressLiberty&#39;</span>] <span class="op">=</span> np.log(corona_extended[<span class="st">&#39;PressLiberty&#39;</span>])</span>
<span id="cb368-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb368-2" tabindex="-1"></a>corona_extended.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 115 entries, 0 to 114
## Data columns (total 9 columns):
##  #   Column                Non-Null Count  Dtype  
## ---  ------                --------------  -----  
##  0   Country               115 non-null    object 
##  1   COVID_Cases           115 non-null    int64  
##  2   Pop                   115 non-null    int64  
##  3   PopDensity            115 non-null    int64  
##  4   UrbanPop              115 non-null    int32  
##  5   COVID_perMillion      115 non-null    float64
##  6   log_COVID_perMillion  115 non-null    float64
##  7   PressLiberty          115 non-null    float64
##  8   log_PressLiberty      115 non-null    float64
## dtypes: float64(4), int32(1), int64(3), object(1)
## memory usage: 7.8+ KB</code></pre>
</div>
<div id="feladat-8" class="section level3 unnumbered hasAnchor">
<h3>9. feladat<a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-8" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="sourceCode" id="cb370"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb370-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb370-1" tabindex="-1"></a>corona_extended.loc[:,[<span class="st">&#39;log_COVID_perMillion&#39;</span>, <span class="st">&#39;PressLiberty&#39;</span>, <span class="st">&#39;log_PressLiberty&#39;</span>]].corr()</span></code></pre></div>
<pre><code>##                       log_COVID_perMillion  PressLiberty  log_PressLiberty
## log_COVID_perMillion              1.000000     -0.381829         -0.430291
## PressLiberty                     -0.381829      1.000000          0.944278
## log_PressLiberty                 -0.430291      0.944278          1.000000</code></pre>
<p>Volt értelme, a sajtószabadsági indexnek jobbra elnyúló az eloszlása, így a kilógó értékek hatását az egymillió főre vetített esetszámmal vett kapcsolatára tudta mérsékelni a logaritmus. Ez onnan látszódik, hogy a korreláció abszolút értékben <span class="math inline">\(0.05\)</span> egységgel nőtt. Nem akkora a javulás, mint a városi népesség arányával vett korrelációnál tapasztaltuk, de azért észrevehető.</p>
</div>
<div id="feladat-9" class="section level3 unnumbered hasAnchor">
<h3>10. feladat<a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-9" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="sourceCode" id="cb372"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb372-1"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb372-1" tabindex="-1"></a>fig <span class="op">=</span> corona_extended.plot.scatter(x<span class="op">=</span><span class="st">&quot;log_PressLiberty&quot;</span>, y<span class="op">=</span><span class="st">&quot;log_COVID_perMillion&quot;</span>)</span>
<span id="cb372-2"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb372-2" tabindex="-1"></a></span>
<span id="cb372-3"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb372-3" tabindex="-1"></a><span class="cf">for</span> sorszám, szöveg <span class="kw">in</span> <span class="bu">enumerate</span>(corona_extended.Country):</span>
<span id="cb372-4"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb372-4" tabindex="-1"></a>   fig.annotate(szöveg, (corona_extended.log_PressLiberty.iat[sorszám]<span class="op">+</span><span class="fl">0.05</span>, corona_extended.log_COVID_perMillion.iat[sorszám]))</span>
<span id="cb372-5"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb372-5" tabindex="-1"></a></span>
<span id="cb372-6"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#cb372-6" tabindex="-1"></a>plt.show()</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-143-31.png" width="672" /></p>
<p>Úgy látszik, hogy pl. a dél-amerikai <em>Suriname</em>-ben még a viszonylag rossz sajtószabadsági indexhez képest is kevés esettalálható egymillió főre. <em>Bahrain</em>ben és <em>Szaúd-Arábiában</em> viszont épp, hogy magas az esetszám a kevésbé szabad sajtó ellenére is. Itt lehet az olajvagyonból futja tesztelésre is <em>úgymond</em>. :)</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="index.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/USERNAME/REPO/edit/BRANCH/01-PythonNyelviAlapok.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf", "_main.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
