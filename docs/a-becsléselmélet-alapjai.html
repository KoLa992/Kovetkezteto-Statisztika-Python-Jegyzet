<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>5 A becsléselmélet alapjai | Következtető Statisztika Python Jegyzet</title>
  <meta name="description" content="<p>Lecture notes on BSc level Inferential Statistics in bookdown format.
Mainly for Business Information Systems BSc students at Corvinus University of Budapest.</p>" />
  <meta name="generator" content="bookdown 0.43 and GitBook 2.6.7" />

  <meta property="og:title" content="5 A becsléselmélet alapjai | Következtető Statisztika Python Jegyzet" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="<p>Lecture notes on BSc level Inferential Statistics in bookdown format.
Mainly for Business Information Systems BSc students at Corvinus University of Budapest.</p>" />
  <meta name="github-repo" content="KoLa992/Kovetkezteto-Statisztika-Python-Jegyzet" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="5 A becsléselmélet alapjai | Következtető Statisztika Python Jegyzet" />
  
  <meta name="twitter:description" content="<p>Lecture notes on BSc level Inferential Statistics in bookdown format.
Mainly for Business Information Systems BSc students at Corvinus University of Budapest.</p>" />
  

<meta name="author" content="Kovács László" />


<meta name="date" content="2025-06-30" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="eloszlások-és-mintavételezés.html"/>
<link rel="next" href="a-sokasági-átlag-intervallumbecslése.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Következtető Statisztika Python Jegyzet</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Előhang</a></li>
<li class="chapter" data-level="2" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html"><i class="fa fa-check"></i><b>2</b> Statisztikához szükséges Python nyelvi alapok</a>
<ul>
<li class="chapter" data-level="2.1" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#programozási-alapelvek"><i class="fa fa-check"></i><b>2.1</b> Programozási alapelvek</a></li>
<li class="chapter" data-level="2.2" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-pythonról-általában"><i class="fa fa-check"></i><b>2.2</b> A Pythonról általában</a></li>
<li class="chapter" data-level="2.3" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-spyder-felülete"><i class="fa fa-check"></i><b>2.3</b> A Spyder felülete</a></li>
<li class="chapter" data-level="2.4" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#working-directory"><i class="fa fa-check"></i><b>2.4</b> Working Directory</a></li>
<li class="chapter" data-level="2.5" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#alapvető-python-adattípusok-és-adatszerkezetek"><i class="fa fa-check"></i><b>2.5</b> Alapvető Python adattípusok és adatszerkezetek</a>
<ul>
<li class="chapter" data-level="2.5.1" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#egyszerű-adattípusok"><i class="fa fa-check"></i><b>2.5.1</b> Egyszerű adattípusok</a></li>
<li class="chapter" data-level="2.5.2" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#összetett-adatszerkezetek"><i class="fa fa-check"></i><b>2.5.2</b> Összetett adatszerkezetek</a></li>
<li class="chapter" data-level="2.5.3" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-numpy-tömb"><i class="fa fa-check"></i><b>2.5.3</b> A <code>numpy</code> tömb</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#vezérlési-szerkezetek"><i class="fa fa-check"></i><b>2.6</b> Vezérlési szerkezetek</a>
<ul>
<li class="chapter" data-level="2.6.1" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#elágazás-if"><i class="fa fa-check"></i><b>2.6.1</b> Elágazás (<code>if</code>)</a></li>
<li class="chapter" data-level="2.6.2" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#ciklusok-for"><i class="fa fa-check"></i><b>2.6.2</b> Ciklusok (<code>for</code>)</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-pandas-data-frame-objektum"><i class="fa fa-check"></i><b>2.7</b> A Pandas data frame objektum</a>
<ul>
<li class="chapter" data-level="2.7.1" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#hivatkozási-lehetőségek-data-frame-ben"><i class="fa fa-check"></i><b>2.7.1</b> Hivatkozási lehetőségek data frame-ben</a></li>
<li class="chapter" data-level="2.7.2" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#data-frame-k-módosítása"><i class="fa fa-check"></i><b>2.7.2</b> Data frame-k módosítása</a></li>
<li class="chapter" data-level="2.7.3" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#szűrés-data-frame-ben-logikai-indexszálás"><i class="fa fa-check"></i><b>2.7.3</b> Szűrés data frame-ben: logikai indexszálás</a></li>
<li class="chapter" data-level="2.7.4" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#hiányzó-értékek-kezelése-data-frame-ben"><i class="fa fa-check"></i><b>2.7.4</b> Hiányzó értékek kezelése data frame-ben</a></li>
<li class="chapter" data-level="2.7.5" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#adatvizualizáció-data-frame-en-keresztül"><i class="fa fa-check"></i><b>2.7.5</b> Adatvizualizáció data frame-en keresztül</a></li>
</ul></li>
<li class="chapter" data-level="2.8" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#aggregálás-data-frame-ben"><i class="fa fa-check"></i><b>2.8</b> Aggregálás data frame-ben</a></li>
<li class="chapter" data-level="2.9" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#egyszerű-leíró-statisztika-data-frame-ben"><i class="fa fa-check"></i><b>2.9</b> Egyszerű leíró statisztika data frame-ben</a></li>
<li class="chapter" data-level="2.10" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#adatminőségi-problémák-felismerése-és-kezelése-leíró-statisztika-segítségével"><i class="fa fa-check"></i><b>2.10</b> Adatminőségi problémák felismerése és kezelése leíró statisztika segítségével</a></li>
<li class="chapter" data-level="2.11" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#data-frame-k-összekapcsolása"><i class="fa fa-check"></i><b>2.11</b> Data frame-k összekapcsolása</a>
<ul>
<li class="chapter" data-level="2.11.1" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#a-kapcsolási-kulcsnak-használt-oszlop-ellenőrzése-és-javítása"><i class="fa fa-check"></i><b>2.11.1</b> A kapcsolási kulcsnak használt oszlop ellenőrzése és javítása</a></li>
</ul></li>
<li class="chapter" data-level="2.12" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#kilógó-értékek-keresése-és-kezelése"><i class="fa fa-check"></i><b>2.12</b> Kilógó értékek keresése és kezelése</a></li>
<li class="chapter" data-level="2.13" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#korrelációs-elemzések-data-frame-ben"><i class="fa fa-check"></i><b>2.13</b> Korrelációs elemzések data frame-ben</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#gyakorló-feladatok"><i class="fa fa-check"></i>Gyakorló feladatok</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#gyakorló-feladatok-megoldása"><i class="fa fa-check"></i>Gyakorló feladatok megoldása</a>
<ul>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat"><i class="fa fa-check"></i>1. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-1"><i class="fa fa-check"></i>2. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-2"><i class="fa fa-check"></i>3. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-3"><i class="fa fa-check"></i>4. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-4"><i class="fa fa-check"></i>5. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-5"><i class="fa fa-check"></i>6. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-6"><i class="fa fa-check"></i>7. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-7"><i class="fa fa-check"></i>8. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-8"><i class="fa fa-check"></i>9. feladat</a></li>
<li class="chapter" data-level="" data-path="statisztikához-szükséges-python-nyelvi-alapok.html"><a href="statisztikához-szükséges-python-nyelvi-alapok.html#feladat-9"><i class="fa fa-check"></i>10. feladat</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><i class="fa fa-check"></i><b>3</b> Leíró Statisztika ismétlés és Valószínűségszámítás alapok</a>
<ul>
<li class="chapter" data-level="3.1" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#leíró-statisztikai-mutatók"><i class="fa fa-check"></i><b>3.1</b> Leíró statisztikai mutatók</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#hisztogram-és-alakmutatók"><i class="fa fa-check"></i><b>3.1.1</b> Hisztogram és Alakmutatók</a></li>
<li class="chapter" data-level="3.1.2" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#gyakorisági-tábla-lekérése"><i class="fa fa-check"></i><b>3.1.2</b> Gyakorisági tábla lekérése</a></li>
<li class="chapter" data-level="3.1.3" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#gyakorisági-tábla-bővítése"><i class="fa fa-check"></i><b>3.1.3</b> Gyakorisági tábla bővítése</a></li>
<li class="chapter" data-level="3.1.4" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#súlyozott-átlag-és-szórás-pythonban"><i class="fa fa-check"></i><b>3.1.4</b> Súlyozott átlag és szórás Pythonban</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#a-normális-eloszlás-és-sűrűségfüggvénye"><i class="fa fa-check"></i><b>3.2</b> A normális eloszlás és sűrűségfüggvénye</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#a-sűrűségfüggvény-használata"><i class="fa fa-check"></i><b>3.2.1</b> A sűrűségfüggvény használata</a></li>
<li class="chapter" data-level="3.2.2" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#a-sűrűségfüggvény-integrálja"><i class="fa fa-check"></i><b>3.2.2</b> A sűrűségfüggvény integrálja</a></li>
<li class="chapter" data-level="3.2.3" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#valószínűség-vs-relatív-gyakoriság"><i class="fa fa-check"></i><b>3.2.3</b> Valószínűség vs Relatív Gyakoriság</a></li>
<li class="chapter" data-level="3.2.4" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#centrális-határeloszlás-tétel-cht"><i class="fa fa-check"></i><b>3.2.4</b> Centrális Határeloszlás Tétel (CHT)</a></li>
<li class="chapter" data-level="3.2.5" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#inverz-értékek"><i class="fa fa-check"></i><b>3.2.5</b> Inverz Értékek</a></li>
<li class="chapter" data-level="3.2.6" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#a-standard-normális-eloszlás"><i class="fa fa-check"></i><b>3.2.6</b> A Standard Normális Eloszlás</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#az-exponenciális-eloszlás"><i class="fa fa-check"></i><b>3.3</b> Az Exponenciális eloszlás</a></li>
<li class="chapter" data-level="3.4" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#a-varianciahányados-pythonban---kokain-a-balatonban"><i class="fa fa-check"></i><b>3.4</b> A Varianciahányados Pythonban - Kokain a Balatonban</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html"><a href="leíró-statisztika-ismétlés-és-valószínűségszámítás-alapok.html#további-minőségi-ismérvek-és-a-kokainmennyiség"><i class="fa fa-check"></i><b>3.4.1</b> További minőségi ismérvek és a kokainmennyiség</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="eloszlások-és-mintavételezés.html"><a href="eloszlások-és-mintavételezés.html"><i class="fa fa-check"></i><b>4</b> Eloszlások és Mintavételezés</a>
<ul>
<li class="chapter" data-level="4.1" data-path="eloszlások-és-mintavételezés.html"><a href="eloszlások-és-mintavételezés.html#véletlenszám-generálás-és-mintavételezés"><i class="fa fa-check"></i><b>4.1</b> Véletlenszám generálás és Mintavételezés</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="eloszlások-és-mintavételezés.html"><a href="eloszlások-és-mintavételezés.html#a-mintagenerálás-általános-elve"><i class="fa fa-check"></i><b>4.1.1</b> A mintagenerálás általános elve</a></li>
<li class="chapter" data-level="4.1.2" data-path="eloszlások-és-mintavételezés.html"><a href="eloszlások-és-mintavételezés.html#nem-egyenletes-eloszlású-minták-generálása"><i class="fa fa-check"></i><b>4.1.2</b> Nem egyenletes eloszlású minták generálása</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="eloszlások-és-mintavételezés.html"><a href="eloszlások-és-mintavételezés.html#elvi-eloszlás-vs-megfigyelt-minta"><i class="fa fa-check"></i><b>4.2</b> Elvi Eloszlás vs Megfigyelt Minta</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="eloszlások-és-mintavételezés.html"><a href="eloszlások-és-mintavételezés.html#az-elvi-eloszlás-alapján-számolt-statisztikai-mutatók"><i class="fa fa-check"></i><b>4.2.1</b> Az elvi eloszlás alapján számolt statisztikai mutatók</a></li>
<li class="chapter" data-level="4.2.2" data-path="eloszlások-és-mintavételezés.html"><a href="eloszlások-és-mintavételezés.html#a-megfigyelt-minta-alapján-számolt-statisztikai-mutatók"><i class="fa fa-check"></i><b>4.2.2</b> A megfigyelt minta alapján számolt statisztikai mutatók</a></li>
<li class="chapter" data-level="4.2.3" data-path="eloszlások-és-mintavételezés.html"><a href="eloszlások-és-mintavételezés.html#a-mintavételi-hiba-mvh-koncepciója"><i class="fa fa-check"></i><b>4.2.3</b> A mintavételi hiba (MVH) koncepciója</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="eloszlások-és-mintavételezés.html"><a href="eloszlások-és-mintavételezés.html#statisztikai-sokaságok-fae-mintavételezése"><i class="fa fa-check"></i><b>4.3</b> Statisztikai sokaságok FAE mintavételezése</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="eloszlások-és-mintavételezés.html"><a href="eloszlások-és-mintavételezés.html#ismételt-mintavételezés-resampling"><i class="fa fa-check"></i><b>4.3.1</b> Ismételt Mintavételezés (<em>Resampling</em>)</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="a-becsléselmélet-alapjai.html"><a href="a-becsléselmélet-alapjai.html"><i class="fa fa-check"></i><b>5</b> A becsléselmélet alapjai</a>
<ul>
<li class="chapter" data-level="5.1" data-path="a-becsléselmélet-alapjai.html"><a href="a-becsléselmélet-alapjai.html#ismétlés-balaton-átúszás-eredmények-és-ezek-fae-mintái"><i class="fa fa-check"></i><b>5.1</b> Ismétlés: Balaton átúszás eredmények és ezek FAE mintái</a></li>
<li class="chapter" data-level="5.2" data-path="a-becsléselmélet-alapjai.html"><a href="a-becsléselmélet-alapjai.html#a-torzítatlanság-fogalma"><i class="fa fa-check"></i><b>5.2</b> A torzítatlanság fogalma</a>
<ul>
<li class="chapter" data-level="5.2.1" data-path="a-becsléselmélet-alapjai.html"><a href="a-becsléselmélet-alapjai.html#az-aszimptotikus-torzítatlanság-fogalma"><i class="fa fa-check"></i><b>5.2.1</b> Az aszimptotikus torzítatlanság fogalma</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="a-becsléselmélet-alapjai.html"><a href="a-becsléselmélet-alapjai.html#a-korrigált-mintavariancia"><i class="fa fa-check"></i><b>5.3</b> A korrigált mintavariancia</a></li>
<li class="chapter" data-level="5.4" data-path="a-becsléselmélet-alapjai.html"><a href="a-becsléselmélet-alapjai.html#a-medián-torzítatlansága"><i class="fa fa-check"></i><b>5.4</b> A medián torzítatlansága</a></li>
<li class="chapter" data-level="5.5" data-path="a-becsléselmélet-alapjai.html"><a href="a-becsléselmélet-alapjai.html#a-standard-hiba-sh-fogalma"><i class="fa fa-check"></i><b>5.5</b> A Standard Hiba (<em>SH</em>) fogalma</a>
<ul>
<li class="chapter" data-level="5.5.1" data-path="a-becsléselmélet-alapjai.html"><a href="a-becsléselmélet-alapjai.html#a-konzisztens-becslés-fogalma"><i class="fa fa-check"></i><b>5.5.1</b> A konzisztens becslés fogalma</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="a-becsléselmélet-alapjai.html"><a href="a-becsléselmélet-alapjai.html#az-átlagos-négyzetes-hiba-mse-fogalma"><i class="fa fa-check"></i><b>5.6</b> Az átlagos négyzetes hiba (<em>MSE</em>) fogalma</a>
<ul>
<li class="chapter" data-level="5.6.1" data-path="a-becsléselmélet-alapjai.html"><a href="a-becsléselmélet-alapjai.html#különböző-becslőfüggvények-összehasonlítása"><i class="fa fa-check"></i><b>5.6.1</b> Különböző becslőfüggvények összehasonlítása</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html"><i class="fa fa-check"></i><b>6</b> A sokasági átlag intervallumbecslése</a>
<ul>
<li class="chapter" data-level="6.1" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#ismétlés-az-átlag-standard-hibája-a-balaton-átúszás-eredményeken"><i class="fa fa-check"></i><b>6.1</b> Ismétlés: Az átlag standard hibája a Balaton átúszás eredményeken</a></li>
<li class="chapter" data-level="6.2" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#a-mintaátlagok-eloszlása"><i class="fa fa-check"></i><b>6.2</b> A mintaátlagok eloszlása</a></li>
<li class="chapter" data-level="6.3" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#a-sokasági-átlag-konfidencia-intervalluma"><i class="fa fa-check"></i><b>6.3</b> A sokasági átlag konfidencia-intervalluma</a>
<ul>
<li class="chapter" data-level="6.3.1" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#az-átlag-konfidencia-intervallumának-általános-alakja"><i class="fa fa-check"></i><b>6.3.1</b> Az átlag konfidencia-intervallumának általános alakja</a></li>
<li class="chapter" data-level="6.3.2" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#a-konfidencia-intervallum-megbízhatóságának-ellenőrzése"><i class="fa fa-check"></i><b>6.3.2</b> A konfidencia-intervallum megbízhatóságának ellenőrzése</a></li>
<li class="chapter" data-level="6.3.3" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#a-konfidencia-intervallum-két-fontos-tulajdonsága"><i class="fa fa-check"></i><b>6.3.3</b> 3.3. A konfidencia-intervallum két fontos tulajdonsága</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#intervallumbecslés-a-gyakorlatban"><i class="fa fa-check"></i><b>6.4</b> Intervallumbecslés a gyakorlatban</a>
<ul>
<li class="chapter" data-level="" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#feladat-altatók-hatékonysága"><i class="fa fa-check"></i>1. feladat: Altatók hatékonysága</a></li>
<li class="chapter" data-level="" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#a-feladat-megoldás"><i class="fa fa-check"></i>1/a) feladat megoldás</a></li>
<li class="chapter" data-level="" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#b-feladat-megoldás"><i class="fa fa-check"></i>1/b) feladat megoldás</a></li>
<li class="chapter" data-level="" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#c-feladat-megoldás"><i class="fa fa-check"></i>1/c) feladat megoldás</a></li>
<li class="chapter" data-level="" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#feladat-10"><i class="fa fa-check"></i>2. feladat</a></li>
<li class="chapter" data-level="" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#feladat-megoldás"><i class="fa fa-check"></i>2. feladat megoldás</a></li>
</ul></li>
<li class="chapter" data-level="6.5" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#összefoglalás-az-átlag-konfidencia-intervallumairól"><i class="fa fa-check"></i><b>6.5</b> Összefoglalás az átlag konfidencia-intervallumairól</a></li>
<li class="chapter" data-level="6.6" data-path="a-sokasági-átlag-intervallumbecslése.html"><a href="a-sokasági-átlag-intervallumbecslése.html#esettanulmány"><i class="fa fa-check"></i><b>6.6</b> Esettanulmány</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="további-fae-becslések-és-a-bootstrap-módszer.html"><a href="további-fae-becslések-és-a-bootstrap-módszer.html"><i class="fa fa-check"></i><b>7</b> További FAE becslések és a Bootstrap módszer</a>
<ul>
<li class="chapter" data-level="7.1" data-path="további-fae-becslések-és-a-bootstrap-módszer.html"><a href="további-fae-becslések-és-a-bootstrap-módszer.html#a-konfidencia-intervallumok-két-általános-tulajdonsága"><i class="fa fa-check"></i><b>7.1</b> A Konfidencia-intervallumok két általános tulajdonsága</a></li>
<li class="chapter" data-level="7.2" data-path="további-fae-becslések-és-a-bootstrap-módszer.html"><a href="további-fae-becslések-és-a-bootstrap-módszer.html#arányok-konfidencia-intervalluma"><i class="fa fa-check"></i><b>7.2</b> Arányok konfidencia-intervalluma</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="további-fae-becslések-és-a-bootstrap-módszer.html"><a href="további-fae-becslések-és-a-bootstrap-módszer.html#mintaelemszám-meghatározása-aránybecsléshez"><i class="fa fa-check"></i><b>7.2.1</b> Mintaelemszám meghatározása aránybecsléshez</a></li>
<li class="chapter" data-level="7.2.2" data-path="további-fae-becslések-és-a-bootstrap-módszer.html"><a href="további-fae-becslések-és-a-bootstrap-módszer.html#szükséges-minimális-elemszám-aránybecsléshez"><i class="fa fa-check"></i><b>7.2.2</b> Szükséges minimális elemszám aránybecsléshez</a></li>
<li class="chapter" data-level="7.2.3" data-path="további-fae-becslések-és-a-bootstrap-módszer.html"><a href="további-fae-becslések-és-a-bootstrap-módszer.html#aránybecslés-a-statsmodels-csomaggal"><i class="fa fa-check"></i><b>7.2.3</b> Aránybecslés a <code>statsmodels</code> csomaggal</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="további-fae-becslések-és-a-bootstrap-módszer.html"><a href="további-fae-becslések-és-a-bootstrap-módszer.html#a-bootstrap-becslések-általános-elve"><i class="fa fa-check"></i><b>7.3</b> A Bootstrap becslések általános elve</a></li>
<li class="chapter" data-level="7.4" data-path="további-fae-becslések-és-a-bootstrap-módszer.html"><a href="további-fae-becslések-és-a-bootstrap-módszer.html#a-medián-bootstrap-intervallumbecslése"><i class="fa fa-check"></i><b>7.4</b> A Medián Bootstrap intervallumbecslése</a></li>
<li class="chapter" data-level="7.5" data-path="további-fae-becslések-és-a-bootstrap-módszer.html"><a href="további-fae-becslések-és-a-bootstrap-módszer.html#a-szórás-bootstrap-intervallumbecslése"><i class="fa fa-check"></i><b>7.5</b> A Szórás Bootstrap intervallumbecslése</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="becslések-ev-és-r-mintából.html"><a href="becslések-ev-és-r-mintából.html"><i class="fa fa-check"></i><b>8</b> Becslések EV és R mintából</a>
<ul>
<li class="chapter" data-level="8.1" data-path="becslések-ev-és-r-mintából.html"><a href="becslések-ev-és-r-mintából.html#intervallumbecslés-visszatevés-nélküli-egyszerű-véletlen-ev-mintákból"><i class="fa fa-check"></i><b>8.1</b> Intervallumbecslés visszatevés nélküli egyszerű véletlen (EV) mintákból</a>
<ul>
<li class="chapter" data-level="8.1.1" data-path="becslések-ev-és-r-mintából.html"><a href="becslések-ev-és-r-mintából.html#átlag-becslése-ev-mintákból"><i class="fa fa-check"></i><b>8.1.1</b> Átlag becslése EV mintákból</a></li>
<li class="chapter" data-level="8.1.2" data-path="becslések-ev-és-r-mintából.html"><a href="becslések-ev-és-r-mintából.html#arány-becslése-ev-mintákból"><i class="fa fa-check"></i><b>8.1.2</b> Arány becslése EV mintákból</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="becslések-ev-és-r-mintából.html"><a href="becslések-ev-és-r-mintából.html#átlag-becslése-arányosan-rétegzett-ar-mintákból"><i class="fa fa-check"></i><b>8.2</b> Átlag becslése Arányosan Rétegzett (AR) mintákból</a>
<ul>
<li class="chapter" data-level="8.2.1" data-path="becslések-ev-és-r-mintából.html"><a href="becslések-ev-és-r-mintából.html#az-ar-mintavételek-hatékonysága"><i class="fa fa-check"></i><b>8.2.1</b> Az AR mintavételek hatékonysága</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="hipotézisvizsgálat-alapjai.html"><a href="hipotézisvizsgálat-alapjai.html"><i class="fa fa-check"></i><b>9</b> Hipotézisvizsgálat alapjai</a>
<ul>
<li class="chapter" data-level="9.1" data-path="hipotézisvizsgálat-alapjai.html"><a href="hipotézisvizsgálat-alapjai.html#a-hipotézisvizsgálat-alapgondolata"><i class="fa fa-check"></i><b>9.1</b> A hipotézisvizsgálat alapgondolata</a>
<ul>
<li class="chapter" data-level="9.1.1" data-path="hipotézisvizsgálat-alapjai.html"><a href="hipotézisvizsgálat-alapjai.html#a-p-érték-fogalma"><i class="fa fa-check"></i><b>9.1.1</b> A p-érték fogalma</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="hipotézisvizsgálat-alapjai.html"><a href="hipotézisvizsgálat-alapjai.html#a-sokasági-átlagra-vonatkozó-t-próba"><i class="fa fa-check"></i><b>9.2</b> A sokasági átlagra vonatkozó <em>t-próba</em></a>
<ul>
<li class="chapter" data-level="9.2.1" data-path="hipotézisvizsgálat-alapjai.html"><a href="hipotézisvizsgálat-alapjai.html#a-t-próba-beépített-függvénnyel"><i class="fa fa-check"></i><b>9.2.1</b> A <em>t-próba</em> beépített függvénnyel</a></li>
<li class="chapter" data-level="9.2.2" data-path="hipotézisvizsgálat-alapjai.html"><a href="hipotézisvizsgálat-alapjai.html#a-t-próba-előfeltételei"><i class="fa fa-check"></i><b>9.2.2</b> A <em>t-próba</em> előfeltételei</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="hipotézisvizsgálat-alapjai.html"><a href="hipotézisvizsgálat-alapjai.html#a-sokasági-átlagra-vonatkozó-z-próba"><i class="fa fa-check"></i><b>9.3</b> A sokasági átlagra vonatkozó <em>z-próba</em></a></li>
<li class="chapter" data-level="9.4" data-path="hipotézisvizsgálat-alapjai.html"><a href="hipotézisvizsgálat-alapjai.html#a-sokasági-arányra-vonatkozó-z-próba"><i class="fa fa-check"></i><b>9.4</b> A sokasági arányra vonatkozó <em>z-próba</em></a></li>
<li class="chapter" data-level="9.5" data-path="hipotézisvizsgálat-alapjai.html"><a href="hipotézisvizsgálat-alapjai.html#a-hipotézisvizsgálat-menete-madártávlatból"><i class="fa fa-check"></i><b>9.5</b> A hipotézisvizsgálat menete madártávlatból</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="egymintás-és-kétmintás-próbák.html"><a href="egymintás-és-kétmintás-próbák.html"><i class="fa fa-check"></i><b>10</b> Egymintás és Kétmintás próbák</a>
<ul>
<li class="chapter" data-level="10.1" data-path="egymintás-és-kétmintás-próbák.html"><a href="egymintás-és-kétmintás-próbák.html#a-szórásra-vonatkozó-chi2-próba"><i class="fa fa-check"></i><b>10.1</b> A szórásra vonatkozó <span class="math inline">\(\chi^2\)</span>-próba</a></li>
<li class="chapter" data-level="10.2" data-path="egymintás-és-kétmintás-próbák.html"><a href="egymintás-és-kétmintás-próbák.html#a-kétmintás-hipotézisvizsgálatok-elve"><i class="fa fa-check"></i><b>10.2</b> A kétmintás hipotézisvizsgálatok elve</a></li>
<li class="chapter" data-level="10.3" data-path="egymintás-és-kétmintás-próbák.html"><a href="egymintás-és-kétmintás-próbák.html#az-átlagokra-vonatkozó-kétmintás-z-próba"><i class="fa fa-check"></i><b>10.3</b> Az átlagokra vonatkozó kétmintás <em>z-próba</em></a></li>
<li class="chapter" data-level="10.4" data-path="egymintás-és-kétmintás-próbák.html"><a href="egymintás-és-kétmintás-próbák.html#az-arányokra-vonatkozó-kétmintás-z-próba"><i class="fa fa-check"></i><b>10.4</b> Az arányokra vonatkozó kétmintás <em>z-próba</em></a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="nemparaméteres-próbák.html"><a href="nemparaméteres-próbák.html"><i class="fa fa-check"></i><b>11</b> Nemparaméteres próbák</a>
<ul>
<li class="chapter" data-level="11.1" data-path="nemparaméteres-próbák.html"><a href="nemparaméteres-próbák.html#nemparaméteres-próbák-elve"><i class="fa fa-check"></i><b>11.1</b> Nemparaméteres próbák elve</a></li>
<li class="chapter" data-level="11.2" data-path="nemparaméteres-próbák.html"><a href="nemparaméteres-próbák.html#illeszkedésvizsgálatok"><i class="fa fa-check"></i><b>11.2</b> Illeszkedésvizsgálatok</a>
<ul>
<li class="chapter" data-level="11.2.1" data-path="nemparaméteres-próbák.html"><a href="nemparaméteres-próbák.html#reprezentativitás-vizsgálat"><i class="fa fa-check"></i><b>11.2.1</b> Reprezentativitás vizsgálat</a></li>
<li class="chapter" data-level="11.2.2" data-path="nemparaméteres-próbák.html"><a href="nemparaméteres-próbák.html#normalitás-vizsgálat"><i class="fa fa-check"></i><b>11.2.2</b> Normalitás vizsgálat</a></li>
</ul></li>
<li class="chapter" data-level="11.3" data-path="nemparaméteres-próbák.html"><a href="nemparaméteres-próbák.html#függetlenségvizsgálatok-homogenitásvizsgálatok"><i class="fa fa-check"></i><b>11.3</b> Függetlenségvizsgálatok (homogenitásvizsgálatok)</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="kétváltozós-lineáris-regresszió.html"><a href="kétváltozós-lineáris-regresszió.html"><i class="fa fa-check"></i><b>12</b> Kétváltozós lineáris regresszió</a>
<ul>
<li class="chapter" data-level="12.1" data-path="kétváltozós-lineáris-regresszió.html"><a href="kétváltozós-lineáris-regresszió.html#budapesti-lakások-vizsgálata"><i class="fa fa-check"></i><b>12.1</b> Budapesti lakások vizsgálata</a></li>
<li class="chapter" data-level="12.2" data-path="kétváltozós-lineáris-regresszió.html"><a href="kétváltozós-lineáris-regresszió.html#a-kétváltozós-lineáris-regresszió-ols-elvű-becslése"><i class="fa fa-check"></i><b>12.2</b> A Kétváltozós Lineáris Regresszió OLS elvű becslése</a></li>
<li class="chapter" data-level="12.3" data-path="kétváltozós-lineáris-regresszió.html"><a href="kétváltozós-lineáris-regresszió.html#az-ols-regresszió-magyarázóerejének-mérése"><i class="fa fa-check"></i><b>12.3</b> Az OLS Regresszió magyarázóerejének mérése</a></li>
<li class="chapter" data-level="12.4" data-path="kétváltozós-lineáris-regresszió.html"><a href="kétváltozós-lineáris-regresszió.html#a-regresszió-magyarázóereje-nem-megfigyelt-adatok-körében"><i class="fa fa-check"></i><b>12.4</b> A Regresszió magyarázóereje nem megfigyelt adatok körében</a></li>
<li class="chapter" data-level="12.5" data-path="kétváltozós-lineáris-regresszió.html"><a href="kétváltozós-lineáris-regresszió.html#a-modell-együtthatóinak-értelemzése"><i class="fa fa-check"></i><b>12.5</b> A modell együtthatóinak értelemzése</a></li>
<li class="chapter" data-level="12.6" data-path="kétváltozós-lineáris-regresszió.html"><a href="kétváltozós-lineáris-regresszió.html#egy-gyakorló-példa-covid-adatokon"><i class="fa fa-check"></i><b>12.6</b> Egy gyakorló példa COVID adatokon</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html"><i class="fa fa-check"></i><b>13</b> Többváltozós OLS Regresszió alapjai</a>
<ul>
<li class="chapter" data-level="13.1" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#magyar-járások-covid-19-halálozási-arányai"><i class="fa fa-check"></i><b>13.1</b> Magyar járások COVID-19 halálozási arányai</a></li>
<li class="chapter" data-level="13.2" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#a-többváltozós-lineáris-regresszió-ols-elvű-előállítása"><i class="fa fa-check"></i><b>13.2</b> A Többváltozós Lineáris Regresszió OLS elvű előállítása</a></li>
<li class="chapter" data-level="13.3" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#a-magyarázóváltozók-marginális-hatása"><i class="fa fa-check"></i><b>13.3</b> A magyarázóváltozók marginális hatása</a>
<ul>
<li class="chapter" data-level="13.3.1" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#útelemzés"><i class="fa fa-check"></i><b>13.3.1</b> Útelemzés</a></li>
<li class="chapter" data-level="13.3.2" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#parciális-t-próba"><i class="fa fa-check"></i><b>13.3.2</b> Parciális t-próba</a></li>
</ul></li>
<li class="chapter" data-level="13.4" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#magyarázóváltozók-fontossági-sorrendjének-megállapítása-t-próba-alapján"><i class="fa fa-check"></i><b>13.4</b> Magyarázóváltozók fontossági sorrendjének megállapítása t-próba alapján</a></li>
<li class="chapter" data-level="13.5" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#konfidencia-intervallumok-és-a-t-próba-kapcsolata"><i class="fa fa-check"></i><b>13.5</b> 5. Konfidencia-intervallumok és a t-próba kapcsolata</a></li>
<li class="chapter" data-level="13.6" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#nominális-magyarázóváltozók---használtautó-adatok"><i class="fa fa-check"></i><b>13.6</b> Nominális magyarázóváltozók - Használtautó adatok</a></li>
<li class="chapter" data-level="13.7" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#dummy-változók-és-működésük-pythonban"><i class="fa fa-check"></i><b>13.7</b> Dummy változók és működésük Pythonban</a>
<ul>
<li class="chapter" data-level="13.7.1" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#referencia-kategória-megváltoztatása"><i class="fa fa-check"></i><b>13.7.1</b> Referencia kategória megváltoztatása</a></li>
</ul></li>
<li class="chapter" data-level="13.8" data-path="többváltozós-ols-regresszió-alapjai.html"><a href="többváltozós-ols-regresszió-alapjai.html#a-korrigált-r-négyzet-mutató"><i class="fa fa-check"></i><b>13.8</b> A korrigált R-négyzet mutató</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Bookdownban szerkesztve</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Következtető Statisztika Python Jegyzet</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="a-becsléselmélet-alapjai" class="section level1 hasAnchor" number="5">
<h1><span class="header-section-number">5</span> A becsléselmélet alapjai<a href="a-becsléselmélet-alapjai.html#a-becsléselmélet-alapjai" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="ismétlés-balaton-átúszás-eredmények-és-ezek-fae-mintái" class="section level2 hasAnchor" number="5.1">
<h2><span class="header-section-number">5.1</span> Ismétlés: Balaton átúszás eredmények és ezek FAE mintái<a href="a-becsléselmélet-alapjai.html#ismétlés-balaton-átúszás-eredmények-és-ezek-fae-mintái" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Folytassuk ott a dolgainkat, ahol a 2. heti anyagban abbahagytuk. Töltsük be egy <code>pandas</code> data frame-be a <a href="https://github.com/KoLa992/Kovetkezteto-Statisztika-Python-Jegyzet/blob/main/LIDLBalaton2022.xlsx" target="_blank">LIDLBalaton2022.xlsx</a> fájl adatait. Ebben az Excelben a 2022-es LIDL Balaton átúszás résztvevőinek <em>neve, neme és percben mért időeredménye</em> található. Ez az adatsor lesz most nekünk a <strong>sokaságunk</strong>.</p>
<div class="sourceCode" id="cb549"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb549-1"><a href="a-becsléselmélet-alapjai.html#cb549-1" tabindex="-1"></a><span class="co"># Elemzéshez és ábrázoláshoz szükséges csomagok betöltése</span></span>
<span id="cb549-2"><a href="a-becsléselmélet-alapjai.html#cb549-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb549-3"><a href="a-becsléselmélet-alapjai.html#cb549-3" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb549-4"><a href="a-becsléselmélet-alapjai.html#cb549-4" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb549-5"><a href="a-becsléselmélet-alapjai.html#cb549-5" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb549-6"><a href="a-becsléselmélet-alapjai.html#cb549-6" tabindex="-1"></a></span>
<span id="cb549-7"><a href="a-becsléselmélet-alapjai.html#cb549-7" tabindex="-1"></a><span class="co"># Adatbeolvasás data frame-be</span></span>
<span id="cb549-8"><a href="a-becsléselmélet-alapjai.html#cb549-8" tabindex="-1"></a>Balcsi <span class="op">=</span> pd.read_excel(<span class="st">&quot;LIDLBalaton2022.xlsx&quot;</span>)</span>
<span id="cb549-9"><a href="a-becsléselmélet-alapjai.html#cb549-9" tabindex="-1"></a></span>
<span id="cb549-10"><a href="a-becsléselmélet-alapjai.html#cb549-10" tabindex="-1"></a>Balcsi.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## RangeIndex: 9751 entries, 0 to 9750
## Data columns (total 3 columns):
##  #   Column  Non-Null Count  Dtype  
## ---  ------  --------------  -----  
##  0   Nev     9751 non-null   object 
##  1   Nem     9751 non-null   object 
##  2   PERC    9751 non-null   float64
## dtypes: float64(1), object(2)
## memory usage: 228.7+ KB</code></pre>
<div class="sourceCode" id="cb551"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb551-1"><a href="a-becsléselmélet-alapjai.html#cb551-1" tabindex="-1"></a>Balcsi.head()</span></code></pre></div>
<pre><code>##                    Nev Nem        PERC
## 0           Aba Attila   F  142.416667
## 1        Abaffy Károly   F  197.883333
## 2        Abaffy Kornél   F  197.983333
## 3  Abelovszki Hajnalka   N  182.000000
## 4   Abért Valentin ifj   F  222.516667</code></pre>
<p>Oké, meg is vagyunk! A sokságnak <span class="math inline">\(N=9751\)</span> eleme van, tehát ennyi versenyző úszta át 2022-ben a Balatont. A sokaságnak alapvetően egy ismérvével, <strong>az időeredménnyel</strong> (<code>PERC</code> oszlop) <strong>fogunk foglalkozni, és ennek három</strong> statisztikai mutatóját vagy szebben fogalmazva <strong>statisztikai paraméterét fogjuk megvizsgálni</strong>:</p>
<ul>
<li>Az <strong>átlag</strong>os időt Jele: <span class="math inline">\(\bar{Y}\)</span> vagy <span class="math inline">\(\mu\)</span></li>
<li>Az egyéni idők <strong>szórás</strong>át Jele: <span class="math inline">\(\sigma\)</span></li>
<li>A 3 óra (180 perc) felett teljesítők <strong>arányát</strong> Jele: <span class="math inline">\(P\)</span></li>
</ul>
<p>Ahogy a <a href="https://kola992.github.io/Kovetkezteto-Statisztika-Python-Jegyzet/eloszl%C3%A1sok-%C3%A9s-mintav%C3%A9telez%C3%A9s.html#statisztikai-sokas%C3%A1gok-fae-mintav%C3%A9telez%C3%A9se" target="_blank">4.3. fejezetben</a> ezt tisztáztuk, egy <strong>teljes statisztikai</strong> adatsor, azaz <strong>sokaság statisztikai mutatóit/paramétereit együttesen <span class="math inline">\(\theta\)</span>-val jelöljük</strong>.</p>
<p>Akkor hát <strong>számoljuk is ki ezeket</strong> a <span class="math inline">\(\theta\)</span>-kat! Még kiszámoljuk az időeredmények varianciáját (szórásnégyzetét) is, mert erre is szükségünk lesz a későbbiekben.</p>
<div class="sourceCode" id="cb553"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb553-1"><a href="a-becsléselmélet-alapjai.html#cb553-1" tabindex="-1"></a>SokasagiAtlag <span class="op">=</span> np.mean(Balcsi.PERC)</span>
<span id="cb553-2"><a href="a-becsléselmélet-alapjai.html#cb553-2" tabindex="-1"></a>SokasagiSzoras <span class="op">=</span> np.std(Balcsi.PERC)</span>
<span id="cb553-3"><a href="a-becsléselmélet-alapjai.html#cb553-3" tabindex="-1"></a>SokasagiVariancia <span class="op">=</span> SokasagiSzoras<span class="op">**</span><span class="dv">2</span></span>
<span id="cb553-4"><a href="a-becsléselmélet-alapjai.html#cb553-4" tabindex="-1"></a>SokasagiArany <span class="op">=</span> np.<span class="bu">sum</span>(Balcsi.PERC <span class="op">&gt;</span> <span class="dv">180</span>)<span class="op">/</span><span class="bu">len</span>(Balcsi)</span>
<span id="cb553-5"><a href="a-becsléselmélet-alapjai.html#cb553-5" tabindex="-1"></a></span>
<span id="cb553-6"><a href="a-becsléselmélet-alapjai.html#cb553-6" tabindex="-1"></a>SokasagiAtlag</span></code></pre></div>
<pre><code>## 167.52914060096398</code></pre>
<div class="sourceCode" id="cb555"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb555-1"><a href="a-becsléselmélet-alapjai.html#cb555-1" tabindex="-1"></a>SokasagiSzoras</span></code></pre></div>
<pre><code>## 44.08833385551663</code></pre>
<div class="sourceCode" id="cb557"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb557-1"><a href="a-becsléselmélet-alapjai.html#cb557-1" tabindex="-1"></a>SokasagiArany</span></code></pre></div>
<pre><code>## 0.3295046661880833</code></pre>
<p>Meg is vagyunk! Akkor <strong>következő lépésben vegyünk is egy <span class="math inline">\(n=100\)</span> elemű FAE</strong> (tehát visszatevéses véletlen) <strong>mintát ebből a sokaságból</strong> egy <span class="math inline">\(1992\)</span>-es véletlen mag mellett. Majd <strong>számoljuk is ki a három vizsgált statisztikai paraméter értékét a mintában</strong>.</p>
<div class="sourceCode" id="cb559"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb559-1"><a href="a-becsléselmélet-alapjai.html#cb559-1" tabindex="-1"></a>BalcsiMinta <span class="op">=</span> Balcsi.sample(n <span class="op">=</span> <span class="dv">100</span>, replace <span class="op">=</span> <span class="va">True</span>, random_state <span class="op">=</span> <span class="dv">1992</span>)</span>
<span id="cb559-2"><a href="a-becsléselmélet-alapjai.html#cb559-2" tabindex="-1"></a></span>
<span id="cb559-3"><a href="a-becsléselmélet-alapjai.html#cb559-3" tabindex="-1"></a>BalcsiMinta.info()</span></code></pre></div>
<pre><code>## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
## Index: 100 entries, 7991 to 5727
## Data columns (total 3 columns):
##  #   Column  Non-Null Count  Dtype  
## ---  ------  --------------  -----  
##  0   Nev     100 non-null    object 
##  1   Nem     100 non-null    object 
##  2   PERC    100 non-null    float64
## dtypes: float64(1), object(2)
## memory usage: 3.1+ KB</code></pre>
<div class="sourceCode" id="cb561"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb561-1"><a href="a-becsléselmélet-alapjai.html#cb561-1" tabindex="-1"></a>MintaAtlag <span class="op">=</span> np.mean(BalcsiMinta.PERC)</span>
<span id="cb561-2"><a href="a-becsléselmélet-alapjai.html#cb561-2" tabindex="-1"></a>MintaSzoras <span class="op">=</span> np.std(BalcsiMinta.PERC)</span>
<span id="cb561-3"><a href="a-becsléselmélet-alapjai.html#cb561-3" tabindex="-1"></a>MintaArany <span class="op">=</span> np.<span class="bu">sum</span>(BalcsiMinta.PERC <span class="op">&gt;</span> <span class="dv">180</span>)<span class="op">/</span><span class="bu">len</span>(BalcsiMinta)</span>
<span id="cb561-4"><a href="a-becsléselmélet-alapjai.html#cb561-4" tabindex="-1"></a></span>
<span id="cb561-5"><a href="a-becsléselmélet-alapjai.html#cb561-5" tabindex="-1"></a>MintaAtlag</span></code></pre></div>
<pre><code>## 164.44033333333334</code></pre>
<div class="sourceCode" id="cb563"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb563-1"><a href="a-becsléselmélet-alapjai.html#cb563-1" tabindex="-1"></a>MintaSzoras</span></code></pre></div>
<pre><code>## 38.62827175499542</code></pre>
<div class="sourceCode" id="cb565"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb565-1"><a href="a-becsléselmélet-alapjai.html#cb565-1" tabindex="-1"></a>MintaArany</span></code></pre></div>
<pre><code>## 0.3</code></pre>
<p>Ezek szerint összefoglalva statisztikai <strong>paramétereink mintából becsült értékei</strong>:</p>
<ul>
<li><span class="math inline">\(\bar{y}=164.4\)</span> perc</li>
<li><span class="math inline">\(s^* = 38.6\)</span> perc</li>
<li><span class="math inline">\(p = 0.3=30\%\)</span></li>
</ul>
<p>Szintén a <a href="https://kola992.github.io/Kovetkezteto-Statisztika-Python-Jegyzet/eloszl%C3%A1sok-%C3%A9s-mintav%C3%A9telez%C3%A9s.html#statisztikai-sokas%C3%A1gok-fae-mintav%C3%A9telez%C3%A9se" target="_blank">4.3. fejezetben</a> szerepelt, hogy a <strong>statisztikai paraméterek mintából becsült értékeit együttesen <span class="math inline">\(\hat{\theta}\)</span>-val jelöljük</strong>. A <span class="math inline">\(\hat{\theta}\)</span>-ok <strong>speciális elnevezése: becslőfüggvény</strong> a <em>valódi, sokasági</em> <span class="math inline">\(\theta\)</span>-hoz. Szóval, a mintaátlag (<span class="math inline">\(\bar{y}\)</span>) a sokasági átlag <span class="math inline">\(\bar{Y}=\mu\)</span> <em>becslőfüggvénye</em>, a mintából számolt szórás (<span class="math inline">\(s^*\)</span>) a valós, sokasági szórás (<span class="math inline">\(\sigma\)</span>) <em>becslőfüggvénye</em> és a mintából számított 3 órán túli úszók aránya (<span class="math inline">\(p\)</span>), a sokasági arány (<span class="math inline">\(P\)</span>) <em>becslőfüggvénye</em>.</p>
<p>A feladatunk pedig az lenne, hogy rájöjjünk: <strong>Hogyan tudunk egyetlen egy db <span class="math inline">\(n\)</span> elemű minta <span class="math inline">\(\hat{\theta}\)</span> becslőfüggvény értékeiből következtetni a teljes <span class="math inline">\(N\)</span> elemű sokaság valós <span class="math inline">\(\theta\)</span> paraméter értékeire?</strong> Ez a <strong>statisztikai becsléselmélet alapfeladata</strong>. Azt is körbejártuk a <a href="https://kola992.github.io/Kovetkezteto-Statisztika-Python-Jegyzet/eloszl%C3%A1sok-%C3%A9s-mintav%C3%A9telez%C3%A9s.html#statisztikai-sokas%C3%A1gok-fae-mintav%C3%A9telez%C3%A9se" target="_blank">4.3. fejezetben</a>, hogy ha a mintavételünk tényleg rendes FAE mintavétel, akkor ami <span class="math inline">\(\hat{\theta}\)</span> és a valós <span class="math inline">\(\theta\)</span> között áll az nem más, mint a <strong>mintavételi hiba (MVH)</strong>. A feladatunk tehát konkrétabban nézve az <strong>MVH kiszámítása vagy legalábbis valamilyen közelítése</strong>.</p>
<p>Ahhoz, hogy <strong>elinduljunk az MVH számítás rögös útján egy olyan trükkel élünk, ami kihasználja, hogy most éppen ismerjük a teljes Balatont átúszó sokaságot</strong>. Nyilván a gyakorlatban azért kell becsléselmélettel meg MVH számítással foglalkozni, mert a sokaságot nem tudjuk megismerni. :) De most mivel megvannak a sokasági adatok, így <strong>kivehetünk a sokasági időeredményekből nagyon-nagyon sok, mondjuk <span class="math inline">\(10000\)</span> db <span class="math inline">\(n=100\)</span> elemű mintát</strong>.<br>
Ezt meg is tettük a <a href="https://kola992.github.io/Kovetkezteto-Statisztika-Python-Jegyzet/eloszl%C3%A1sok-%C3%A9s-mintav%C3%A9telez%C3%A9s.html#statisztikai-sokas%C3%A1gok-fae-mintav%C3%A9telez%C3%A9se" target="_blank">4.3. fejezet legvégén</a>. Most csak <strong>visszatöltjük az eredményt tartalmazó Excel táblát egy data frame-be</strong>. Az Excel fájl, amit ebben a jegyzetben használok <a href="https://github.com/KoLa992/Kovetkezteto-Statisztika-Python-Jegyzet/blob/main/MintaDataFrame.xlsx" target="_blank">innen</a> elérhető.</p>
<div class="sourceCode" id="cb567"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb567-1"><a href="a-becsléselmélet-alapjai.html#cb567-1" tabindex="-1"></a>MintaVetelek100Elem <span class="op">=</span> pd.read_excel(<span class="st">&quot;MintaDataFrame.xlsx&quot;</span>)</span>
<span id="cb567-2"><a href="a-becsléselmélet-alapjai.html#cb567-2" tabindex="-1"></a>MintaVetelek100Elem</span></code></pre></div>
<pre><code>##            Elem1       Elem2       Elem3  ...      Elem98      Elem99     Elem100
## 0     164.800000  129.066667  156.166667  ...  207.350000  159.666667  165.883333
## 1     152.516667  212.483333  152.900000  ...  307.266667  119.783333  128.216667
## 2     145.666667  185.266667  169.516667  ...  167.733333  228.366667  215.633333
## 3     185.683333  120.333333  201.250000  ...  182.766667  177.666667  112.450000
## 4     117.483333  142.350000  320.266667  ...  188.566667  189.166667   99.916667
## ...          ...         ...         ...  ...         ...         ...         ...
## 9995  162.333333   83.350000  146.750000  ...  164.250000  131.933333  128.183333
## 9996  100.416667  161.433333  187.366667  ...  160.483333  168.416667  209.300000
## 9997  146.450000  160.783333  165.483333  ...  158.816667  167.733333  183.400000
## 9998  139.250000  140.466667  130.933333  ...  153.616667  112.366667  196.050000
## 9999  147.316667  173.450000  106.100000  ...  185.616667  171.800000  135.166667
## 
## [10000 rows x 100 columns]</code></pre>
<p>Oké, az eredményből látjuk is, hogy úgy néz ki a data frame, hogy <strong>1 sor tartalmaz 1 db 100 elemű mintát és a mintaelemeket</strong> (tehát a mintába besorsolt versenyző percben mért időeredményét) <strong>az oszlopkban tároljuk</strong>.</p>
<p>Ez a tárolási forma azért is kényelmes, mert a data frame “<em>szeletelésével</em>” bármikor tudunk <span class="math inline">\(n&lt;100\)</span> elemű mintákat is előállítani. Hiszen a mintavétel a pitonkának köszönhetően teljesen véletlenszerű volt, így <strong>ha kiválasztom a tábla első <span class="math inline">\(20\)</span> oszlopát az olyan, mintha lenne <span class="math inline">\(10000\)</span> db <span class="math inline">\(n=20\)</span> elemű mintám is!</strong><br>
Ezt most tegyük is akkor meg!</p>
<div class="sourceCode" id="cb569"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb569-1"><a href="a-becsléselmélet-alapjai.html#cb569-1" tabindex="-1"></a>MintaVetelek20Elem <span class="op">=</span> MintaVetelek100Elem.iloc[:, <span class="dv">0</span>:<span class="dv">20</span>]</span>
<span id="cb569-2"><a href="a-becsléselmélet-alapjai.html#cb569-2" tabindex="-1"></a>MintaVetelek20Elem</span></code></pre></div>
<pre><code>##            Elem1       Elem2       Elem3  ...      Elem18      Elem19      Elem20
## 0     164.800000  129.066667  156.166667  ...  136.066667  115.616667  174.966667
## 1     152.516667  212.483333  152.900000  ...  150.933333  172.316667  218.083333
## 2     145.666667  185.266667  169.516667  ...  140.300000  121.900000  195.650000
## 3     185.683333  120.333333  201.250000  ...  147.950000  264.466667  137.033333
## 4     117.483333  142.350000  320.266667  ...  150.500000  245.600000  178.166667
## ...          ...         ...         ...  ...         ...         ...         ...
## 9995  162.333333   83.350000  146.750000  ...  178.166667  143.166667  146.433333
## 9996  100.416667  161.433333  187.366667  ...  139.366667  166.483333  129.966667
## 9997  146.450000  160.783333  165.483333  ...  113.033333  195.250000  167.200000
## 9998  139.250000  140.466667  130.933333  ...  182.200000  148.633333  121.183333
## 9999  147.316667  173.450000  106.100000  ...  217.333333  198.366667  166.133333
## 
## [10000 rows x 20 columns]</code></pre>
<p>Szuper, olybá tűnik akkor jók vagyunk! :)</p>
</div>
<div id="a-torzítatlanság-fogalma" class="section level2 hasAnchor" number="5.2">
<h2><span class="header-section-number">5.2</span> A torzítatlanság fogalma<a href="a-becsléselmélet-alapjai.html#a-torzítatlanság-fogalma" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Na hát akkor vizsgáljuk meg először a <span class="math inline">\(10000\)</span> db <span class="math inline">\(n=100\)</span> elemű mintát alaposabban ahhoz, hogy megértsük: <strong>hogyan is viselkednek a <span class="math inline">\(\hat{\theta}\)</span> becslőfüggvények a valós <span class="math inline">\(\theta\)</span> paraméterekhez képest</strong>.</p>
<p>Először <strong>számoljuk ki mindegyik <span class="math inline">\(100\)</span> elemű mintában a három</strong> statisztikai mutatónk, azaz <strong>becslőfüggvényünk értékét</strong>: átlag, szórásnyégyzet (variancia) és a 180 percen felül teljesítők aránya. A szórás kapcsán kényelmesebb lesz a gyökjel nélkül vizsgálni a dolgokat, ezért veszünk varianciát.<br>
Szerencsénkre, a <code>numpy</code> csomag statisztikai függvényei <code>axis = 1</code> paraméter beállítással soronként és NEM oszloponként számolják ki az átlagot, varianciát, összegeket, így <strong>minden mintára ki tudjuk számolni a becslőfüggvények értékét 1-1 új oszlopban</strong>. <strong>Figyeljünk</strong> arra, hogy mivel a data frame oszlopai folyamatosan bővülnek, így manuálisan le kell szorítani a <code>numpy</code> statisztikai függvények alkalmazását mindig az első 100 oszlopra az <code>iloc</code> metódussal!</p>
<div class="sourceCode" id="cb571"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb571-1"><a href="a-becsléselmélet-alapjai.html#cb571-1" tabindex="-1"></a>MintaVetelek100Elem[<span class="st">&#39;Atlagok&#39;</span>] <span class="op">=</span> np.mean(MintaVetelek100Elem.iloc[:,<span class="dv">0</span>:<span class="dv">100</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb571-2"><a href="a-becsléselmélet-alapjai.html#cb571-2" tabindex="-1"></a>MintaVetelek100Elem[<span class="st">&#39;Varianciak&#39;</span>] <span class="op">=</span> np.std(MintaVetelek100Elem.iloc[:,<span class="dv">0</span>:<span class="dv">100</span>], axis<span class="op">=</span><span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb571-3"><a href="a-becsléselmélet-alapjai.html#cb571-3" tabindex="-1"></a>MintaVetelek100Elem[<span class="st">&#39;Aranyok&#39;</span>] <span class="op">=</span> np.<span class="bu">sum</span>(MintaVetelek100Elem.iloc[:,<span class="dv">0</span>:<span class="dv">100</span>] <span class="op">&gt;</span> <span class="dv">180</span>, axis<span class="op">=</span><span class="dv">1</span>)<span class="op">/</span><span class="dv">100</span></span>
<span id="cb571-4"><a href="a-becsléselmélet-alapjai.html#cb571-4" tabindex="-1"></a></span>
<span id="cb571-5"><a href="a-becsléselmélet-alapjai.html#cb571-5" tabindex="-1"></a>MintaVetelek100Elem</span></code></pre></div>
<pre><code>##            Elem1       Elem2       Elem3  ...     Atlagok   Varianciak  Aranyok
## 0     164.800000  129.066667  156.166667  ...  171.261667  1779.537092     0.34
## 1     152.516667  212.483333  152.900000  ...  158.026500  1941.843989     0.29
## 2     145.666667  185.266667  169.516667  ...  172.278833  1987.792994     0.34
## 3     185.683333  120.333333  201.250000  ...  163.434167  2045.349935     0.33
## 4     117.483333  142.350000  320.266667  ...  166.552833  2077.951717     0.33
## ...          ...         ...         ...  ...         ...          ...      ...
## 9995  162.333333   83.350000  146.750000  ...  163.682333  1687.185827     0.28
## 9996  100.416667  161.433333  187.366667  ...  164.332833  1748.105975     0.32
## 9997  146.450000  160.783333  165.483333  ...  163.702333  1425.601189     0.30
## 9998  139.250000  140.466667  130.933333  ...  166.423833  1564.257813     0.37
## 9999  147.316667  173.450000  106.100000  ...  173.050333  2302.607722     0.44
## 
## [10000 rows x 103 columns]</code></pre>
<p>Oké, olybá tűnik, hogy mind a <span class="math inline">\(10000\)</span> db mintára megvan mindhárom becslőfüggvény a <code>MintaVetelek100Elem</code> data frame utolsó három oszlopában.</p>
<p>Következő lépésként <strong>vegyük a mintaátlagos és a mintaarányok átlagát, és vessük össze az eredményeke a valós sokasági átlaggal és aránnyal!</strong></p>
<div class="sourceCode" id="cb573"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb573-1"><a href="a-becsléselmélet-alapjai.html#cb573-1" tabindex="-1"></a>AtlagokAtlaga <span class="op">=</span> np.mean(MintaVetelek100Elem[<span class="st">&#39;Atlagok&#39;</span>])</span>
<span id="cb573-2"><a href="a-becsléselmélet-alapjai.html#cb573-2" tabindex="-1"></a>AranyokAtlaga <span class="op">=</span> np.mean(MintaVetelek100Elem[<span class="st">&#39;Aranyok&#39;</span>])</span>
<span id="cb573-3"><a href="a-becsléselmélet-alapjai.html#cb573-3" tabindex="-1"></a></span>
<span id="cb573-4"><a href="a-becsléselmélet-alapjai.html#cb573-4" tabindex="-1"></a>[AtlagokAtlaga, SokasagiAtlag]</span></code></pre></div>
<pre><code>## [167.4932536, 167.52914060096398]</code></pre>
<div class="sourceCode" id="cb575"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb575-1"><a href="a-becsléselmélet-alapjai.html#cb575-1" tabindex="-1"></a>[AranyokAtlaga, SokasagiArany]</span></code></pre></div>
<pre><code>## [0.329556, 0.3295046661880833]</code></pre>
<p>Hoppá, a <strong>kétféle értékek egészen közel vannak egymáshoz!</strong> Sőt, némi <strong>kerekítéssel a becslőfüggvények átlaga megegyezik az adott paraméter valós sokasági értékével!</strong></p>
<div class="sourceCode" id="cb577"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb577-1"><a href="a-becsléselmélet-alapjai.html#cb577-1" tabindex="-1"></a>[<span class="bu">round</span>(AtlagokAtlaga,<span class="dv">1</span>), <span class="bu">round</span>(SokasagiAtlag,<span class="dv">1</span>)]</span></code></pre></div>
<pre><code>## [167.5, 167.5]</code></pre>
<div class="sourceCode" id="cb579"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb579-1"><a href="a-becsléselmélet-alapjai.html#cb579-1" tabindex="-1"></a>[<span class="bu">round</span>(AranyokAtlaga<span class="op">*</span><span class="dv">100</span>, <span class="dv">1</span>), <span class="bu">round</span>(SokasagiArany<span class="op">*</span><span class="dv">100</span>, <span class="dv">1</span>)]</span></code></pre></div>
<pre><code>## [33.0, 33.0]</code></pre>
<p>Amit itt tapasztalunk az a <strong>TORZÍTATLANSÁG jelensége</strong>. Eszerint, <strong>ha az összes lehetséges mintából számolt <span class="math inline">\(\hat{\theta}\)</span>-ok átlaga</strong> (vagy más szóval várható értéke) <strong>megegyezik a valós, sokasági <span class="math inline">\(\theta\)</span> értékével, akkor a <span class="math inline">\(\hat{\theta}\)</span> becslőfüggvény torzítatlan</strong>. A <strong>torzítatlanság esetünkben azért teljesül csak kerekítésekkel, mert mi csak <span class="math inline">\(10000\)</span> db minta alapján vizsgálódunk, és nem vettük ki az összes lehetséges mintát</strong>, mivel azt valószínűleg nem bírta volna el a RAM-unk az <span class="math inline">\(N=9751\)</span> elemű sokaság esetén. :)</p>
<p>A <strong>fenti fogalom matematikai formalizmussal</strong> az alábbi formát ölti. A képletben az <span class="math inline">\(E()\)</span> függvény az átlagolás, azaz <em>várható érték</em> jele, ami az angolban ugyebár <em>expected value</em> álnéven fut … innen az <em>E</em>. :) <span class="math display">\[E(\hat{\theta})=\theta\]</span></p>
<p>Ha a <strong>fenti egyenlőség teljesül az összes lehetséges tetszőleges <span class="math inline">\(n\)</span> elemű mintában, akkor <span class="math inline">\(\hat{\theta}\)</span> torzítatlan becslése <span class="math inline">\(\theta\)</span>-nak</strong>.</p>
<p>Ebből kiindulva pedig megadhatjuk a <strong>torzítottság fokának (angolul Bias, rövidítve <span class="math inline">\(Bs\)</span>)</strong> definícióját is, ami nem más, mint a <strong>becslőfüggvények</strong> (<span class="math inline">\(\hat{\theta}\)</span>-ok) <strong>várható értékének különbsége</strong> a valós, <strong>sokasági</strong> <span class="math inline">\(\theta\)</span> <strong>értéktől</strong>:<span class="math display">\[Bs=E(\hat{\theta})-\theta\]</span></p>
<p>Láthatjuk, hogy <span class="math inline">\(10000\)</span> db mintát vizsgálva az <strong>átlag és arány</strong>, mint <span class="math inline">\(\theta\)</span> paraméterek esetében elég kicsi ez a <span class="math inline">\(Bs\)</span>. Mindkét esetben <strong>1 tizedesre kerekítve <span class="math inline">\(0\)</span> a torzítás</strong>.</p>
<div class="sourceCode" id="cb581"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb581-1"><a href="a-becsléselmélet-alapjai.html#cb581-1" tabindex="-1"></a><span class="co"># Bs(Átlag)</span></span>
<span id="cb581-2"><a href="a-becsléselmélet-alapjai.html#cb581-2" tabindex="-1"></a><span class="bu">round</span>(AtlagokAtlaga <span class="op">-</span> SokasagiAtlag, <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## -0.0</code></pre>
<div class="sourceCode" id="cb583"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb583-1"><a href="a-becsléselmélet-alapjai.html#cb583-1" tabindex="-1"></a><span class="co"># Bs(Arány)</span></span>
<span id="cb583-2"><a href="a-becsléselmélet-alapjai.html#cb583-2" tabindex="-1"></a><span class="bu">round</span>(AranyokAtlaga <span class="op">-</span> SokasagiArany, <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## 0.0</code></pre>
<p>Oké, a kis <span class="math inline">\(10000\)</span> db <span class="math inline">\(n=100\)</span> mintás kísérletünk alapján azt mondhatjuk, hogy a <strong>mintaátlag és mintaarány torzítatlan becslőfüggvényei a valós sokasági átlagnak és sokasági aránynak</strong>.</p>
<p>De mi a helyzet a szórás frontján? Konkrétan, <strong>első körben vizsgáljuk meg, hogy a mintákból számolt szórásnégyzetek torzítatlan becslései-e a sokasági szórásnégyzetnek, azaz varianciának!</strong></p>
<div class="sourceCode" id="cb585"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb585-1"><a href="a-becsléselmélet-alapjai.html#cb585-1" tabindex="-1"></a>VarianciakAtlaga <span class="op">=</span> np.mean(MintaVetelek100Elem[<span class="st">&#39;Varianciak&#39;</span>])</span>
<span id="cb585-2"><a href="a-becsléselmélet-alapjai.html#cb585-2" tabindex="-1"></a></span>
<span id="cb585-3"><a href="a-becsléselmélet-alapjai.html#cb585-3" tabindex="-1"></a>[VarianciakAtlaga, SokasagiVariancia]</span></code></pre></div>
<pre><code>## [1925.3877225365777, 1943.781182155494]</code></pre>
<div class="sourceCode" id="cb587"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb587-1"><a href="a-becsléselmélet-alapjai.html#cb587-1" tabindex="-1"></a><span class="co"># Bs(Variancia)</span></span>
<span id="cb587-2"><a href="a-becsléselmélet-alapjai.html#cb587-2" tabindex="-1"></a><span class="bu">round</span>(VarianciakAtlaga <span class="op">-</span> SokasagiVariancia, <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## -18.4</code></pre>
<p>Jajj! Olybá tűnik, hogy <strong>a válasz NEM</strong>! A <strong>mintából számolt varianciák, azaz <span class="math inline">\({(s^*)}^2\)</span>-ek átlaga a valós, sokasági varianciához képest esetünkben <span class="math inline">\(18.4\)</span>-gyel alacsonyabb érték!</strong> Tehát, a <strong>mintavariancia, mint becslőfüggvény lefelé torzít a valós sokasági szóráshoz képest!</strong> Kellemetlen. Hiszen, ez <strong>azt jelenti, hogy egy mintából számolt variancia a valós soksági értékhez képest jó eséllyel kisebb lesz</strong>. Ez azért szerencsétlen, mert eszerint a <strong>vizsgált ismérvünk szóródásáról, indagozásáról egy mintából nézve a valósághoz képest jellemzően kisebb értéket látunk</strong>.<br>
Tehát, pl. egy részvény árfolyamának szóródását (kockázat) az árfolyamadatok egy mintájából nézve a valósághoz képest jellemzően kisebbnek látjuk. <strong>A “kockázat” alulbecslése pedig egy olyan probléma, amivel kezdeni kell valamit!</strong></p>
<p>A <strong>jelenség matematikailag</strong> az alábbi módon írható le: <span class="math display">\[E\left({(s^*)}^2 \right) &lt; \sigma^2\]</span></p>
<p>Azaz: <span class="math display">\[Bs\left({(s^*)}^2\right) &lt; 0\]</span></p>
<div id="az-aszimptotikus-torzítatlanság-fogalma" class="section level3 hasAnchor" number="5.2.1">
<h3><span class="header-section-number">5.2.1</span> Az aszimptotikus torzítatlanság fogalma<a href="a-becsléselmélet-alapjai.html#az-aszimptotikus-torzítatlanság-fogalma" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Ami valamilyen szinten menti a helyzetet az az a tény, hogy bár a <strong>sokasági variancia alapból torzítottan becsülhető a mintavarianciákkal</strong>, de a becslés viszont <strong>aszimptotikusan torzítatlan</strong>. Ez azt jelenti, hogy <strong>mintaelemszám növelésével a torzítás mértéke (<span class="math inline">\(|Bs|\)</span>) csökken, konkrétan <span class="math inline">\(0\)</span>-ba tart</strong>. Azaz: <span class="math display">\[\lim_{n \rightarrow \infty}{Bs\left({(s^*)}^2\right)}=0\]</span></p>
<p>Próbáljuk <strong>szemléltetni a jelenséget!</strong> A data frame-k <strong>1. fejezet végén bemutatott oszlopkiválasztásával</strong> <span class="math inline">\(10000\)</span> db <span class="math inline">\(n=\{10,20,30,...,90,100\}\)</span> elemű minta esetén kiszámoljuk a mintavarianciák <span class="math inline">\(Bs({(s^*)}^2)\)</span> értékét a valós sokasági varianciához (<span class="math inline">\(\sigma^2\)</span>) képest.<br>
Természetesen, technikailag ezt egy <code>for</code> ciklus segítségével tudjuk megoldani:</p>
<ul>
<li>A ciklus minden iterációjában kiválasztjuk a megfelelő elemszámú mintákat a <code>MintaVetelek100Elem</code> data frame-ből</li>
<li>Kiszámoljuk minden elemszám esetén <span class="math inline">\({(s^*)}^2\)</span>-et mind a <span class="math inline">\(10000\)</span> db mintára</li>
<li>Kiszámoljuk és egy <code>list</code>-ben eltároljuk <span class="math inline">\(Bs({(s^*)}^2)\)</span>, mint <span class="math inline">\(E({(s^*)}^2)\)</span> és a valós, sokasági variancia, <span class="math inline">\(\sigma^2\)</span> különbsége</li>
</ul>
<div class="sourceCode" id="cb589"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb589-1"><a href="a-becsléselmélet-alapjai.html#cb589-1" tabindex="-1"></a><span class="co"># Üres lista létrehozása Bs-ek tárolására</span></span>
<span id="cb589-2"><a href="a-becsléselmélet-alapjai.html#cb589-2" tabindex="-1"></a>Bs_Lista <span class="op">=</span> []</span>
<span id="cb589-3"><a href="a-becsléselmélet-alapjai.html#cb589-3" tabindex="-1"></a><span class="co"># Vizsgált elemszámok listájának létrehozása</span></span>
<span id="cb589-4"><a href="a-becsléselmélet-alapjai.html#cb589-4" tabindex="-1"></a><span class="co"># 10 és 100 közötti egész számok felsoroltatása a &#39;range&#39; függvényben 10-es lépésközzel</span></span>
<span id="cb589-5"><a href="a-becsléselmélet-alapjai.html#cb589-5" tabindex="-1"></a><span class="co"># Felső határ 101 a nyílt intervallum miatt</span></span>
<span id="cb589-6"><a href="a-becsléselmélet-alapjai.html#cb589-6" tabindex="-1"></a>Elemszam_Lista <span class="op">=</span> <span class="bu">range</span>(<span class="dv">10</span>, <span class="dv">101</span>, <span class="dv">10</span>)</span>
<span id="cb589-7"><a href="a-becsléselmélet-alapjai.html#cb589-7" tabindex="-1"></a></span>
<span id="cb589-8"><a href="a-becsléselmélet-alapjai.html#cb589-8" tabindex="-1"></a><span class="co"># Ciklus indítása</span></span>
<span id="cb589-9"><a href="a-becsléselmélet-alapjai.html#cb589-9" tabindex="-1"></a><span class="cf">for</span> AktualisElemszam <span class="kw">in</span> Elemszam_Lista:</span>
<span id="cb589-10"><a href="a-becsléselmélet-alapjai.html#cb589-10" tabindex="-1"></a>  AktualisMintaVetelek <span class="op">=</span> MintaVetelek100Elem.iloc[:, <span class="dv">0</span>:AktualisElemszam].copy()</span>
<span id="cb589-11"><a href="a-becsléselmélet-alapjai.html#cb589-11" tabindex="-1"></a>  AktualisMintaVetelek[<span class="st">&#39;Varianciak&#39;</span>] <span class="op">=</span> np.std(AktualisMintaVetelek, axis <span class="op">=</span> <span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb589-12"><a href="a-becsléselmélet-alapjai.html#cb589-12" tabindex="-1"></a>  AktualisVarianciakAtlaga <span class="op">=</span> np.mean(AktualisMintaVetelek[<span class="st">&#39;Varianciak&#39;</span>])</span>
<span id="cb589-13"><a href="a-becsléselmélet-alapjai.html#cb589-13" tabindex="-1"></a>  AktualisBs <span class="op">=</span> AktualisVarianciakAtlaga <span class="op">-</span> SokasagiVariancia</span>
<span id="cb589-14"><a href="a-becsléselmélet-alapjai.html#cb589-14" tabindex="-1"></a>  Bs_Lista.append(<span class="bu">round</span>(AktualisBs, <span class="dv">1</span>))</span>
<span id="cb589-15"><a href="a-becsléselmélet-alapjai.html#cb589-15" tabindex="-1"></a></span>
<span id="cb589-16"><a href="a-becsléselmélet-alapjai.html#cb589-16" tabindex="-1"></a><span class="co"># Eredmény megtekintése </span></span>
<span id="cb589-17"><a href="a-becsléselmélet-alapjai.html#cb589-17" tabindex="-1"></a>Bs_Lista</span></code></pre></div>
<pre><code>## [-201.4, -100.7, -70.9, -52.4, -42.5, -30.9, -24.0, -19.6, -18.8, -18.4]</code></pre>
<p>Szépen láthatjuk, hogy <strong>a <span class="math inline">\(Bs\)</span> értékek abszolút értéke</strong> az elég hatalmas <span class="math inline">\(201.4\)</span>-től indulva <strong>szépen lefut</strong> az <span class="math inline">\(n=100\)</span> esetben <strong>korábban is mért <span class="math inline">\(18.4\)</span>-be</strong>. Az eredmények még látványosabbak egy vonaldiagramon ábrázolva.</p>
<div class="sourceCode" id="cb591"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb591-1"><a href="a-becsléselmélet-alapjai.html#cb591-1" tabindex="-1"></a><span class="co"># Vizsgált elemszámok és a mért Bs-ek data frame-be rendezése</span></span>
<span id="cb591-2"><a href="a-becsléselmélet-alapjai.html#cb591-2" tabindex="-1"></a><span class="co"># Ahol az elemszámok a sorindexek</span></span>
<span id="cb591-3"><a href="a-becsléselmélet-alapjai.html#cb591-3" tabindex="-1"></a>BsData <span class="op">=</span> pd.DataFrame(np.<span class="bu">abs</span>(Bs_Lista), columns<span class="op">=</span>[<span class="st">&#39;Bs_AbszErtekek&#39;</span>], index <span class="op">=</span> <span class="bu">range</span>(<span class="dv">10</span>, <span class="dv">101</span>, <span class="dv">10</span>))</span>
<span id="cb591-4"><a href="a-becsléselmélet-alapjai.html#cb591-4" tabindex="-1"></a></span>
<span id="cb591-5"><a href="a-becsléselmélet-alapjai.html#cb591-5" tabindex="-1"></a><span class="co"># Ábrázolás a &#39;plot&#39; metódussal: nem kell paraméterezni, mert csak egy oszlopunk van</span></span>
<span id="cb591-6"><a href="a-becsléselmélet-alapjai.html#cb591-6" tabindex="-1"></a>BsData.plot()</span>
<span id="cb591-7"><a href="a-becsléselmélet-alapjai.html#cb591-7" tabindex="-1"></a>plt.show()</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-239-1.png" width="672" /></p>
<p>Szépen, gyakorlatilag exponenciális ütemben csökken a <span class="math inline">\(Bs\)</span> abszolút érték, bár a <strong>csökkenés nagysága <span class="math inline">\(n=90\)</span>-ről <span class="math inline">\(n=100\)</span>-ra már nem túl jelentős</strong>! Ez azt jelenti, hogy <strong>varianciák esetén a torzítás mértéke függ az <span class="math inline">\(n\)</span> elemszámtól!</strong> Minél nagyobb az elemszám, annál kisebb a torzítás mértéke, tehát az <span class="math inline">\(|Bs|\)</span>.</p>
</div>
</div>
<div id="a-korrigált-mintavariancia" class="section level2 hasAnchor" number="5.3">
<h2><span class="header-section-number">5.3</span> A korrigált mintavariancia<a href="a-becsléselmélet-alapjai.html#a-korrigált-mintavariancia" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>A 2.1. fejezetben tapasztalt tényt, miszerint a mintavariancia <span class="math inline">\((s^*)^2\)</span> a valós, sokasági <span class="math inline">\(\sigma^2\)</span>-nek <strong>aszimptotikusan torzítatlan becslése</strong> fel lehet használni a <strong>variancia torzítási probléma megoldására</strong>.</p>
<p>Ugyebár azt tudjuk az szimptotikusan torzítatlanságból, hogy minél nagyobb az elemszám, annál kisebb a torzítás mértéke. Sőt, azt is meg lehet mondani, hogy <strong>a mintavarianciák várható értéke, <span class="math inline">\(E\left((s^*)^2\right)\)</span> arányaiban <span class="math inline">\(\frac{n-1}{n}\)</span>-nel tér el a sokasági varianciától, <span class="math inline">\(\sigma^2\)</span>-től</strong>. Azaz igaz a következő egyenlőség: <span class="math display">\[\frac{E\left((s^*)^2\right)}{\sigma^2}=\frac{n-1}{n}\]</span></p>
<p>Újrahasznosítva a <span class="math inline">\(Bs\)</span>-ek meghatározására alkalmazott <code>for</code> ciklusos megoldásunkat, a <strong>fenti összefüggés helyessége is ellenőrizhető <span class="math inline">\(n=\{10,20,30,...,90,100\}\)</span> elemszámok mesetén</strong>.</p>
<div class="sourceCode" id="cb592"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb592-1"><a href="a-becsléselmélet-alapjai.html#cb592-1" tabindex="-1"></a><span class="co"># Üres lista létrehozása a (várható érték) / (sokasági variancia) hányadosok tárolására</span></span>
<span id="cb592-2"><a href="a-becsléselmélet-alapjai.html#cb592-2" tabindex="-1"></a>Hanyados_Lista <span class="op">=</span> []</span>
<span id="cb592-3"><a href="a-becsléselmélet-alapjai.html#cb592-3" tabindex="-1"></a><span class="co"># Üres lista létrehozása az (n-1)/n hányadosok tárolására</span></span>
<span id="cb592-4"><a href="a-becsléselmélet-alapjai.html#cb592-4" tabindex="-1"></a>ElemszamHanyados_Lista <span class="op">=</span> []</span>
<span id="cb592-5"><a href="a-becsléselmélet-alapjai.html#cb592-5" tabindex="-1"></a><span class="co"># Vizsgált elemszámok listájának létrehozása</span></span>
<span id="cb592-6"><a href="a-becsléselmélet-alapjai.html#cb592-6" tabindex="-1"></a><span class="co"># 10 és 100 közötti egész számok felsoroltatása a &#39;range&#39; függvényben 10-es lépésközzel</span></span>
<span id="cb592-7"><a href="a-becsléselmélet-alapjai.html#cb592-7" tabindex="-1"></a><span class="co"># Felső határ 101 a nyílt intervallum miatt</span></span>
<span id="cb592-8"><a href="a-becsléselmélet-alapjai.html#cb592-8" tabindex="-1"></a>Elemszam_Lista <span class="op">=</span> <span class="bu">range</span>(<span class="dv">10</span>, <span class="dv">101</span>, <span class="dv">10</span>)</span>
<span id="cb592-9"><a href="a-becsléselmélet-alapjai.html#cb592-9" tabindex="-1"></a></span>
<span id="cb592-10"><a href="a-becsléselmélet-alapjai.html#cb592-10" tabindex="-1"></a><span class="co"># Ciklus indítása</span></span>
<span id="cb592-11"><a href="a-becsléselmélet-alapjai.html#cb592-11" tabindex="-1"></a><span class="cf">for</span> AktualisElemszam <span class="kw">in</span> Elemszam_Lista:</span>
<span id="cb592-12"><a href="a-becsléselmélet-alapjai.html#cb592-12" tabindex="-1"></a>  AktualisMintaVetelek <span class="op">=</span> MintaVetelek100Elem.iloc[:, <span class="dv">0</span>:AktualisElemszam].copy()</span>
<span id="cb592-13"><a href="a-becsléselmélet-alapjai.html#cb592-13" tabindex="-1"></a>  AktualisMintaVetelek[<span class="st">&#39;Varianciak&#39;</span>] <span class="op">=</span> np.std(AktualisMintaVetelek, axis <span class="op">=</span> <span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb592-14"><a href="a-becsléselmélet-alapjai.html#cb592-14" tabindex="-1"></a>  AktualisVarianciakAtlaga <span class="op">=</span> np.mean(AktualisMintaVetelek[<span class="st">&#39;Varianciak&#39;</span>])</span>
<span id="cb592-15"><a href="a-becsléselmélet-alapjai.html#cb592-15" tabindex="-1"></a>  Hanyados_Lista.append(<span class="bu">round</span>(AktualisVarianciakAtlaga<span class="op">/</span>SokasagiVariancia, <span class="dv">3</span>))</span>
<span id="cb592-16"><a href="a-becsléselmélet-alapjai.html#cb592-16" tabindex="-1"></a>  ElemszamHanyados_Lista.append(<span class="bu">round</span>((AktualisElemszam <span class="op">-</span> <span class="dv">1</span>)<span class="op">/</span>AktualisElemszam, <span class="dv">3</span>))</span>
<span id="cb592-17"><a href="a-becsléselmélet-alapjai.html#cb592-17" tabindex="-1"></a></span>
<span id="cb592-18"><a href="a-becsléselmélet-alapjai.html#cb592-18" tabindex="-1"></a><span class="co"># Eredmények összefűzése data frame-be </span></span>
<span id="cb592-19"><a href="a-becsléselmélet-alapjai.html#cb592-19" tabindex="-1"></a>Hanyados_df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb592-20"><a href="a-becsléselmélet-alapjai.html#cb592-20" tabindex="-1"></a>  <span class="bu">list</span>(<span class="bu">zip</span>(ElemszamHanyados_Lista, Hanyados_Lista)),</span>
<span id="cb592-21"><a href="a-becsléselmélet-alapjai.html#cb592-21" tabindex="-1"></a>  columns<span class="op">=</span>[<span class="st">&#39;(n-1)/n&#39;</span>, <span class="st">&#39;VarhatoErtek/SokasagiVar&#39;</span>])</span>
<span id="cb592-22"><a href="a-becsléselmélet-alapjai.html#cb592-22" tabindex="-1"></a>Hanyados_df</span></code></pre></div>
<pre><code>##    (n-1)/n  VarhatoErtek/SokasagiVar
## 0    0.900                     0.896
## 1    0.950                     0.948
## 2    0.967                     0.964
## 3    0.975                     0.973
## 4    0.980                     0.978
## 5    0.983                     0.984
## 6    0.986                     0.988
## 7    0.988                     0.990
## 8    0.989                     0.990
## 9    0.990                     0.991</code></pre>
<p>Szuper, <strong>aránylag szépen kijön a kétféle hányadosok közötti egyezőség</strong>! :) Persze itt is van némi <strong>eltérés, mivel csak <span class="math inline">\(10000\)</span> db mintát vizsgálunk és nem az összes lehetségeset</strong>, de ez még így is látványos egyezés! Így már <strong>érthető, hogy a <span class="math inline">\(Bs\)</span> abszolút értéke miért nem csökkent már látványosan <span class="math inline">\(n=90\)</span>-ről <span class="math inline">\(n=100\)</span>-ra: az <span class="math inline">\(\frac{n-1}{n}\)</span> hányados mindkét esetben már elég kicsit volt, így a torzítás mértéke is!</strong></p>
<p>Viszont, ha a <span class="math inline">\(\frac{E\left((s^*)^2\right)}{\sigma^2}=\frac{n-1}{n}\)</span> egyenlőség igaz, akkor azt átrendezve a következő összefüggésre jutunk: <span class="math display">\[\sigma^2=\frac{n}{n-1} \times E\left((s^*)^2\right)\]</span></p>
<p>Konstans szorzót egy átlagolás (<span class="math inline">\(E(...)\)</span>) eredményén alkalmazni ugyan az, mintha minden kiátlagolandó elemet felszoroztam volna azzal a szorzóval. Tehát az <span class="math inline">\(\frac{n}{n-1}\)</span> bevihető a várható érték függvényen belülre: <span class="math display">\[\sigma^2= E\left(\frac{n}{n-1} \times (s^*)^2\right)\]</span></p>
<p>Mindezek alapján pedig azt mondjatjuk, hogy <strong>az <span class="math inline">\(s^2=\frac{n}{n-1} \times (s^*)^2\)</span> módon KORRIGÁLT MINTAVARIANCIA már TORZÍTATLANUL becsli a valós sokasági varianciát, azaz <span class="math inline">\(\sigma^2\)</span>-t!</strong> Hiszen <span class="math inline">\(\sigma^2= E\left(s^2\right)\)</span>.</p>
<p>Tyűha, ez nagyon szépen hangzik! :) <strong>Próbáljuk ki! Számoljuk ki a <span class="math inline">\(10000\)</span> db <span class="math inline">\(n=100\)</span> elemű mintában a korrigált mintavarianciákat, és nézzük meg azok átlagát (várható értékét)!</strong></p>
<div class="sourceCode" id="cb594"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb594-1"><a href="a-becsléselmélet-alapjai.html#cb594-1" tabindex="-1"></a><span class="co"># Elemszám megadása külön változóban</span></span>
<span id="cb594-2"><a href="a-becsléselmélet-alapjai.html#cb594-2" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb594-3"><a href="a-becsléselmélet-alapjai.html#cb594-3" tabindex="-1"></a></span>
<span id="cb594-4"><a href="a-becsléselmélet-alapjai.html#cb594-4" tabindex="-1"></a><span class="co"># Korrigált varianciák</span></span>
<span id="cb594-5"><a href="a-becsléselmélet-alapjai.html#cb594-5" tabindex="-1"></a>MintaVetelek100Elem[<span class="st">&#39;KorrigaltVar&#39;</span>] <span class="op">=</span> (n<span class="op">/</span>(n<span class="op">-</span><span class="dv">1</span>)) <span class="op">*</span> MintaVetelek100Elem[<span class="st">&#39;Varianciak&#39;</span>]</span>
<span id="cb594-6"><a href="a-becsléselmélet-alapjai.html#cb594-6" tabindex="-1"></a></span>
<span id="cb594-7"><a href="a-becsléselmélet-alapjai.html#cb594-7" tabindex="-1"></a><span class="co"># Torzítatlanság ellenőrzése</span></span>
<span id="cb594-8"><a href="a-becsléselmélet-alapjai.html#cb594-8" tabindex="-1"></a>KorrVarAtlaga <span class="op">=</span> np.mean(MintaVetelek100Elem[<span class="st">&#39;KorrigaltVar&#39;</span>])</span>
<span id="cb594-9"><a href="a-becsléselmélet-alapjai.html#cb594-9" tabindex="-1"></a></span>
<span id="cb594-10"><a href="a-becsléselmélet-alapjai.html#cb594-10" tabindex="-1"></a>[KorrVarAtlaga, SokasagiVariancia]</span></code></pre></div>
<pre><code>## [1944.8360833702807, 1943.781182155494]</code></pre>
<div class="sourceCode" id="cb596"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb596-1"><a href="a-becsléselmélet-alapjai.html#cb596-1" tabindex="-1"></a><span class="bu">round</span>(KorrVarAtlaga <span class="op">-</span> SokasagiVariancia, <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## 1.1</code></pre>
<p>Győzelem! :) Ha <strong>nem is szűnt meg teljesen a dolog, de láthatóan nagyon alacsony, majdnem elhanyagolható lett a <span class="math inline">\(Bs\)</span> mértéke</strong>! Sőt, már nem lefele torzítunk azzal a minimális <span class="math inline">\(1.1\)</span>-gyel, hanem felfelé, ami egy szóródás becslésnél még a “<em>jobbik eset</em>”. Lásd a korábbi pénzügyi kockázat becslése példát. :) Ha <strong>lenne több mintánk, akkor a korrekció ki is nullázná a <span class="math inline">\(Bs\)</span>-t</strong>.</p>
<p>Ezek alapján akkor jó lenne, ha <strong>lenne valami beépített függvényünk</strong> az <code>std</code> helyett, ami <strong>mintaadatok esetén alapból a KORRIGÁLT SZÓRÁS <span class="math inline">\(s = \sqrt{s^2}=\sqrt{\frac{n}{n-1} \times (s^*)^2}\)</span> értékét számolja</strong>!</p>
<p>Nos, <strong>valójában az</strong> <code>std</code> <strong>tud korrigált szórást számolni egy extra paraméter segítségével</strong>. Ahhoz, hogy <strong>megértsük a paraméter működését egy picit végig kell gondolni a korrigált szórás képletének a működését</strong>.</p>
<p>Alapból a mintaadatok <span class="math inline">\(s^*\)</span> szórását az alánbbi képlettel számoljuk: <span class="math display">\[s^*=\sqrt{\frac{\sum_{i=1}^n{(y_i-\bar{y})^2}}{n}}\]</span></p>
<p>Azaz, megnézzük, hogy minden <span class="math inline">\(y_i\)</span> mintaelem mennyivel tér el a minta <span class="math inline">\(\bar{y}\)</span> átlagától, majd ezen eltéréseket négyzetre emelve összeadjuk és az összeget leosztjuk a minta <span class="math inline">\(n\)</span> elemszámával, végül gyököt vonunk az egész hányadosból.<br>
Ennek az értéknek a négyzete a sima, <em>nem korrigált</em> variancia: <span class="math display">\[(s^*)^2=\frac{\sum_{i=1}^n{(y_i-\bar{y})^2}}{n}\]</span></p>
<p>Ha a fenrti variancia képletet beszorozzuk <span class="math inline">\(\frac{n}{n-1}\)</span>-gyel akkor a következő egyszerűséítéseket tehetjük: <span class="math display">\[s^2=\frac{n}{n-1} \times \frac{\sum_{i=1}^n{(y_i-\bar{y})^2}}{n} = \frac{\sum_{i=1}^n{(y_i-\bar{y})^2}}{n-1}\]</span></p>
<p>Tehát, a <strong>minta korrigált szórását úgy számoljuk ki mint a nem korrigáltat, csak a NEVEZŐBEN <span class="math inline">\(n-1\)</span>-gyel osztunk, nem pedig <span class="math inline">\(n\)</span>-nel</strong>: <span class="math display">\[s=\sqrt{\frac{\sum_{i=1}^n{(y_i-\bar{y})^2}}{n-1}}\]</span></p>
<p>Ezt az <strong>eltérést a nevezőben</strong> a <code>ddof = 1</code> <strong>paraméter beállítással jelezzuk</strong> a <code>numpy</code> csomag <code>std</code> függvényében. Könnyen kitalálható, hogy alapértelmezésben <code>ddof = 0</code> beállítással fut az <code>std</code> függvény. :)</p>
<p>Lássuk is a dolgot akcióban!</p>
<div class="sourceCode" id="cb598"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb598-1"><a href="a-becsléselmélet-alapjai.html#cb598-1" tabindex="-1"></a><span class="co"># Korrigált varianciák &#39;std&#39;-vel</span></span>
<span id="cb598-2"><a href="a-becsléselmélet-alapjai.html#cb598-2" tabindex="-1"></a>MintaVetelek100Elem[<span class="st">&#39;KorrigaltVar_std&#39;</span>] <span class="op">=</span> np.std(MintaVetelek100Elem.iloc[:,<span class="dv">0</span>:<span class="dv">100</span>], axis<span class="op">=</span><span class="dv">1</span>, ddof <span class="op">=</span> <span class="dv">1</span>)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb598-3"><a href="a-becsléselmélet-alapjai.html#cb598-3" tabindex="-1"></a></span>
<span id="cb598-4"><a href="a-becsléselmélet-alapjai.html#cb598-4" tabindex="-1"></a><span class="co"># Torzítatlanság ellenőrzése</span></span>
<span id="cb598-5"><a href="a-becsléselmélet-alapjai.html#cb598-5" tabindex="-1"></a>KorrVarAtlaga_std <span class="op">=</span> np.mean(MintaVetelek100Elem[<span class="st">&#39;KorrigaltVar_std&#39;</span>])</span>
<span id="cb598-6"><a href="a-becsléselmélet-alapjai.html#cb598-6" tabindex="-1"></a></span>
<span id="cb598-7"><a href="a-becsléselmélet-alapjai.html#cb598-7" tabindex="-1"></a>[KorrVarAtlaga_std, SokasagiVariancia]</span></code></pre></div>
<pre><code>## [1944.8360833702802, 1943.781182155494]</code></pre>
<div class="sourceCode" id="cb600"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb600-1"><a href="a-becsléselmélet-alapjai.html#cb600-1" tabindex="-1"></a><span class="bu">round</span>(KorrVarAtlaga_std <span class="op">-</span> SokasagiVariancia, <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## 1.1</code></pre>
<p>Királyság! Tökéletesen ugyan ott vagyunk, mint az előbb a manuális számolással! :)</p>
<p><strong>Szépen szakszavakkal összefoglalva</strong> tehát az a fő tanulságunk, hogy</p>
<ol style="list-style-type: decimal">
<li>A <strong>sima mintavariancia (<span class="math inline">\((s^*)^2\)</span>) a sokasági variancia <span class="math inline">\(\sigma^2\)</span> TORZÍTOTT becslőfüggvénye</strong></li>
<li>A <strong>korrigált mintavariancia (<span class="math inline">\(s^2\)</span>)</strong> viszont <strong>a sokasági variancia <span class="math inline">\(\sigma^2\)</span> TORZÍTATLAN becslőfüggvénye</strong></li>
</ol>
</div>
<div id="a-medián-torzítatlansága" class="section level2 hasAnchor" number="5.4">
<h2><span class="header-section-number">5.4</span> A medián torzítatlansága<a href="a-becsléselmélet-alapjai.html#a-medián-torzítatlansága" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>Stat. 1-en nagyon fontos mutatónk volt a medián</strong>, mint a vizsgált ismérv felezőpontja, hiszen nem volt érzékeny a kilógó értékekre az adatsorban, mint az átlag. <strong>Nézzük meg</strong> itt a Balaton átúszás 100 elemű mintáinak példáján, hogy ez a statisztikai paraméter <strong>torzítatlanul becsülhető-e!</strong></p>
<div class="sourceCode" id="cb602"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb602-1"><a href="a-becsléselmélet-alapjai.html#cb602-1" tabindex="-1"></a><span class="co"># Sokasági medián átúszási idő</span></span>
<span id="cb602-2"><a href="a-becsléselmélet-alapjai.html#cb602-2" tabindex="-1"></a>SokasagiMedian <span class="op">=</span> np.median(Balcsi.PERC)</span>
<span id="cb602-3"><a href="a-becsléselmélet-alapjai.html#cb602-3" tabindex="-1"></a></span>
<span id="cb602-4"><a href="a-becsléselmélet-alapjai.html#cb602-4" tabindex="-1"></a><span class="co"># Mintabeli mediánok kiszámítása</span></span>
<span id="cb602-5"><a href="a-becsléselmélet-alapjai.html#cb602-5" tabindex="-1"></a>MintaVetelek100Elem[<span class="st">&#39;Medianok&#39;</span>] <span class="op">=</span> np.median(MintaVetelek100Elem.iloc[:,<span class="dv">0</span>:<span class="dv">100</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb602-6"><a href="a-becsléselmélet-alapjai.html#cb602-6" tabindex="-1"></a></span>
<span id="cb602-7"><a href="a-becsléselmélet-alapjai.html#cb602-7" tabindex="-1"></a><span class="co"># Mintabeli mediánok átlaga</span></span>
<span id="cb602-8"><a href="a-becsléselmélet-alapjai.html#cb602-8" tabindex="-1"></a>MedianokAtlaga <span class="op">=</span> np.mean(MintaVetelek100Elem[<span class="st">&#39;Medianok&#39;</span>])</span>
<span id="cb602-9"><a href="a-becsléselmélet-alapjai.html#cb602-9" tabindex="-1"></a></span>
<span id="cb602-10"><a href="a-becsléselmélet-alapjai.html#cb602-10" tabindex="-1"></a><span class="co"># Torzítatlanság ellenőrzése</span></span>
<span id="cb602-11"><a href="a-becsléselmélet-alapjai.html#cb602-11" tabindex="-1"></a>[MedianokAtlaga, SokasagiMedian]</span></code></pre></div>
<pre><code>## [162.3393025, 162.26666666666668]</code></pre>
<div class="sourceCode" id="cb604"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb604-1"><a href="a-becsléselmélet-alapjai.html#cb604-1" tabindex="-1"></a><span class="bu">round</span>(MedianokAtlaga <span class="op">-</span> SokasagiMedian, <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## 0.1</code></pre>
<p>Olybá tűnik, hogy a medián a mintabeli mediánokkal <strong>torzítatlanul becsülhető</strong> A <span class="math inline">\(Bs(me) = E(me) - Me\)</span> eltérés olyan minimális, hogy simán elhihető, hogy megszűnik, ha az összes lehetséges <span class="math inline">\(n=100\)</span> lemeű mintát vizsgálnánk és nem csak <span class="math inline">\(10000\)</span>-et.</p>
</div>
<div id="a-standard-hiba-sh-fogalma" class="section level2 hasAnchor" number="5.5">
<h2><span class="header-section-number">5.5</span> A Standard Hiba (<em>SH</em>) fogalma<a href="a-becsléselmélet-alapjai.html#a-standard-hiba-sh-fogalma" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Szép és jó, hogy megállapítottuk, hogy a mintaátlag, mintaarány, korrigált mintavariancia és mintamedián <strong>torzítatlan becslőfüggvény</strong>ei a nekik megfelelő sokasági <span class="math inline">\(\theta\)</span> paramézereknek, de <strong>mire jó ez nekünk a gyakorlatban, amikor csak egyetlen egy darab mintavételünk van?</strong></p>
<p>Hiszen, mint a 3-4. fejeuetekben tapasztaltuk, a torzítatlanság csak annyit mond, hogy ha van <strong>nagyon-nagyon sok mintavételünk</strong>, akkor a vizsgált statisztikai mutatónk/paraméterünk mintából számított értékei (becslőfüggvények) <strong>átlagosan eltalálják a mutató valós, sokasági értékét</strong>. De sajnos ebbe a <strong>definícióba nagyon sok minden belefér</strong>, és igazából <strong>önmagában a mintavételi hibáról (MVH) nem mond semmit</strong>.<br>
Ezt a problémát nagyon jól érzékelteti a következő <em>favicc</em>.</p>
<blockquote>
<p>“Egy mérnök, egy fizikus és egy statisztikus együtt mennek vaddisznóra vadászni. Alig tesznek meg néhány lépést az erdőben, máris észrevesznek 150 méterre egy hatalmas példányt.<br>
A mérnök felemeli a puskáját, céloz és lő, de három méterrel mellétalál jobbra. A fizikus így okoskodik:<br>”Egy kis szellő fúj balról, ha kicsit balra célzok, akkor eltalálom.”<br>
Ő is célbaveszi a szarvast, lő és három méterrel balra elvéti. A statisztikus felugrik, és örvendezni kezd:<br>
“Megvan! Megvan! Eltaláltuk!”</p>
<footer>
– Méltán Ismeretlen Szerző
</footer>
</blockquote>
<p>Ugyebár kedvenc viccbéli statisztikus azért örvendez, mivel a három méterrel jobbra és balra hibázó két lövés átlagban pont telibe kapta szegény vaddisznónkat!<br>
Na, hát erről szól a <strong>torzítatlanság</strong> is:</p>
<ul>
<li>Le akarunk vadászni <em>lövésekkel</em>, azaz <em>mintavételekkel</em> egy statisztikai paraméter sokasági értékét, <span class="math inline">\(\theta\)</span>-t.</li>
<li>Az első lövés, az 1. mintavételből származó becslőfüggvényünk értéke <span class="math inline">\(\hat{\theta}_1\)</span></li>
<li>A második lövés, a 2. mintavételből származó becslőfüggvényünk értéke <span class="math inline">\(\hat{\theta}_2\)</span></li>
<li>Ezek átlagban, azaz várható értékben eltallálják a keresett valós értéket, <span class="math inline">\(\theta\)</span>-t: <span class="math inline">\(E(\hat{\theta})=\theta\)</span></li>
<li>Íme: ez a <em>torzítatlan becslés</em> definíciója :)</li>
</ul>
<p>Az statisztikai “<span class="math inline">\(\hat{\theta}\)</span>”-os vadászat és a vaddisznó vadász közti <strong>analógia az alábbi ábrán szemléltethető</strong>. <strong>FONTOS</strong> :)</p>
<center>
<img src="BiasBoar.jpg" style="width:50.0%" />
</center>
<p><br>A fenti ábrán bejelöltem <strong>zölddel</strong> egy <strong>tetszőleges <span class="math inline">\(\hat{\theta}_i\)</span> és a valós, sokasági <span class="math inline">\(\theta\)</span> közti távolság</strong>ot. Valójában <strong>ez az a távolság, amire kíváncsiak vagyunk egy tetszőleges FAE mintából számolt becslés és a keresett mutató sokasági értéke közötti távolság</strong>! Hiszen a gyakorlatban <strong>csak egy db mintavételünk van, és az egyetlen egy megfigyelt mintából kimókolt <span class="math inline">\(\hat{\theta}\)</span> és <span class="math inline">\(\theta\)</span> közti távolságot kéne kiszámolni</strong>! Ez lenne ugyebár a <strong>MVH</strong>, amit kersünk!<br>
Nos, a <strong>torzítatlanságnak hála</strong> van egy módszer, amivel ezt a <strong>távolságot ki lehet számolni</strong>! Hiszen, ha a torzítatlanság miatt <span class="math inline">\(E(\hat{\theta})=\theta\)</span>, akkor ez azt jelenti, hogy <strong>a sok-sok mintából számolt <span class="math inline">\(\hat{\theta}_i\)</span> értékek szórása épp a keresett zöld távolság</strong>. Hiszen mi is a <strong>szórás általános értelmezése</strong>? Egy <strong>véletlenszerűen kiválasztott elem az adatsorból várhatóan mennyivel tér el az átlagtól</strong>. Hogyan fordul ez le a <span class="math inline">\(\hat{\theta}\)</span>-ok adatsorára? Ha a <strong>sok-sok lehetséges mintavételből kiválasztok egyet, akkor a kiválasztott mintából számolt <span class="math inline">\(\hat{\theta}\)</span> várhatóan szórásnyival tér el</strong> a <span class="math inline">\(\hat{\theta}\)</span>-ok átlagától, azaz a <em>torzítatlanság</em> miatt épp a <strong>valós, sokasági <span class="math inline">\(\theta\)</span> értékétől</strong>.<br>
Ebből az okfejtésből kiindulva <strong>a<span class="math inline">\(\hat{\theta}\)</span>-ok szórását standard mintavételi hibának, röviden csak standard hibának, “SH”-nak nevezzük</strong>.</p>
<p>Akkor ezen felbuzdulva <strong>számoltassuk ki</strong> pitonkával az <strong>átlag és arány standard hibáit</strong>, mint a <span class="math inline">\(\hat{\theta}\)</span>-ként funkcionáló <strong>mintaátlagok és minatarányok szórása</strong>! Itt sima szórást kell stámolni, semmi korrekció nem kell az <code>std</code> függvényben.</p>
<div class="sourceCode" id="cb606"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb606-1"><a href="a-becsléselmélet-alapjai.html#cb606-1" tabindex="-1"></a>SH_Atlag <span class="op">=</span> np.std(MintaVetelek100Elem.Atlagok)</span>
<span id="cb606-2"><a href="a-becsléselmélet-alapjai.html#cb606-2" tabindex="-1"></a>SH_Arany <span class="op">=</span> np.std(MintaVetelek100Elem.Aranyok)</span>
<span id="cb606-3"><a href="a-becsléselmélet-alapjai.html#cb606-3" tabindex="-1"></a></span>
<span id="cb606-4"><a href="a-becsléselmélet-alapjai.html#cb606-4" tabindex="-1"></a>SH_Atlag</span></code></pre></div>
<pre><code>## 4.402018186841923</code></pre>
<div class="sourceCode" id="cb608"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb608-1"><a href="a-becsléselmélet-alapjai.html#cb608-1" tabindex="-1"></a>SH_Arany</span></code></pre></div>
<pre><code>## 0.04667871960540553</code></pre>
<p>Mivel az <strong>átlag és arány torzítatlan becslések</strong>, így a <strong>szórásként kiszámolt standard hibát a következőképpen lehet értelmezni</strong>:</p>
<ul>
<li>100 elemű minták esetén <strong>egy konkrét mintaátlag várhatóan <span class="math inline">\(4.4\)</span> perccel tér el az átlagok átlagától, azaz a valós, sokasági átlagos átúszási időtől</strong>.</li>
<li><strong>Egy konkrét 100 elemű mintában a Balatont 3 órán túl átúszók aránya várhatóan <span class="math inline">\(4.67\)</span> százalékponttal tér el a teljes sokaság hasonló arányától</strong>.</li>
</ul>
<p>Hasonlóan működik a dolog ezen a szinten a varianciákra és mediánokra is. HF kiszámolni és értelmezni az eredményeket. :)</p>
<p>Viszont, <strong>olybá tűnik, hogy nem vagyunk sokkal előrébb</strong>. Mivel, bár a standard hiba megadja, hogy egy mintából számolt becslés várhatóan mennyivel tér el a valóságtól, de a <strong>standard hiba (SH) kiszámolásához sok-sok mintavételre van szükség, hiszen ezekből a mintákból számolt <span class="math inline">\(\hat{\theta}\)</span>-k szórásaként tudjuk az SH értéket megahtározni</strong>!<br>
Az kéne, hogy <strong>az SH-t egyetlen egy mintavételből is valahogy ki tudjuk számolni</strong>!</p>
<p>Erre <strong>az átlag és az arány esetében van megoldásunk</strong>. Ugyanis e két mutató esetében a <strong>SH kifejezhető zárt formulával is</strong>:</p>
<ul>
<li><span class="math inline">\(SH(\bar{y})=\frac{\sigma}{\sqrt{n}}\)</span></li>
<li><span class="math inline">\(SH(p)=\sqrt{\frac{P(1-P)}{n}}\)</span></li>
</ul>
<p>Tehát, a <strong>két standard hiba a sokasági szórás (<span class="math inline">\(\sigma\)</span>) és a keresett sokasági arány (<span class="math inline">\(P\)</span>) és a mintaelemszám <span class="math inline">\(n\)</span> ismeretében megahtározahtó</strong>. Próbáljuk is ki a dolgot.</p>
<div class="sourceCode" id="cb610"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb610-1"><a href="a-becsléselmélet-alapjai.html#cb610-1" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb610-2"><a href="a-becsléselmélet-alapjai.html#cb610-2" tabindex="-1"></a></span>
<span id="cb610-3"><a href="a-becsléselmélet-alapjai.html#cb610-3" tabindex="-1"></a>SH_Atlag_Formula <span class="op">=</span> SokasagiSzoras <span class="op">/</span> np.sqrt(n)</span>
<span id="cb610-4"><a href="a-becsléselmélet-alapjai.html#cb610-4" tabindex="-1"></a>SH_Arany_Formula <span class="op">=</span> np.sqrt((SokasagiArany <span class="op">*</span> (<span class="dv">1</span><span class="op">-</span>SokasagiArany))<span class="op">/</span>n)</span>
<span id="cb610-5"><a href="a-becsléselmélet-alapjai.html#cb610-5" tabindex="-1"></a></span>
<span id="cb610-6"><a href="a-becsléselmélet-alapjai.html#cb610-6" tabindex="-1"></a>[SH_Atlag, SH_Atlag_Formula]</span></code></pre></div>
<pre><code>## [4.402018186841923, 4.408833385551663]</code></pre>
<div class="sourceCode" id="cb612"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb612-1"><a href="a-becsléselmélet-alapjai.html#cb612-1" tabindex="-1"></a>[SH_Arany, SH_Arany_Formula]</span></code></pre></div>
<pre><code>## [0.04667871960540553, 0.04700333404646558]</code></pre>
<p>Olybá tűnik, hogy <strong>nagyjából egyezik a két érték</strong>. :) A minimális eltérés megint abbók fakad, hogy nem az összes lehetséges mintát vizsgáltuk, csak <span class="math inline">\(10000\)</span> db-ot, amikor a <span class="math inline">\(SH\)</span>-kat a <span class="math inline">\(\hat{\theta}\)</span>-ok szórásaként számoltuk ki.</p>
<p>Viszont, itt <strong>megint az a probléma, hogy a <span class="math inline">\(SH\)</span> kiszámításhoz olyan dolgokat kell ismerni, amiket egyetlen egy mintavétel esetén nem ismerünk</strong>: sokasági szórás (<span class="math inline">\(\sigma\)</span>) és a sokasági arány (<span class="math inline">\(P\)</span>).<br>
<strong>NODE!</strong> Ezeket az ismeretlenek legalább tudjuk <strong>helyettesíteni az egy mintavételből számolt torzítatlan becslésükkel</strong>: a <span class="math inline">\(P\)</span>-t helyettesítjük <span class="math inline">\(p\)</span>-vel, a <span class="math inline">\(\sigma\)</span>-t pedig a korrigált szórással, <span class="math inline">\(s\)</span>-el (hiszen egy torzítatlan becslése kell).</p>
<p>Ennyi ismerettel pedig akkor pl. az <span class="math inline">\(5.\)</span> mintánk alapján a <span class="math inline">\(SH(\bar{y}) \approx \frac{s}{\sqrt{n}}\)</span> és <span class="math inline">\(SH(p) \approx \sqrt{\frac{p(1-p)}{n}}\)</span> <strong>közelítő képletekkel</strong> meg tudjuk már határozni a <span class="math inline">\(SH\)</span>-kat.</p>
<div class="sourceCode" id="cb614"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb614-1"><a href="a-becsléselmélet-alapjai.html#cb614-1" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb614-2"><a href="a-becsléselmélet-alapjai.html#cb614-2" tabindex="-1"></a></span>
<span id="cb614-3"><a href="a-becsléselmélet-alapjai.html#cb614-3" tabindex="-1"></a>SH_Atlag_ÖtödikMinta <span class="op">=</span> np.sqrt(MintaVetelek100Elem.Varianciak[<span class="dv">4</span>] <span class="op">/</span> n)</span>
<span id="cb614-4"><a href="a-becsléselmélet-alapjai.html#cb614-4" tabindex="-1"></a>SH_Arany_ÖtödikMinta <span class="op">=</span> np.sqrt((MintaVetelek100Elem.Aranyok[<span class="dv">4</span>] <span class="op">*</span> (<span class="dv">1</span><span class="op">-</span>MintaVetelek100Elem.Aranyok[<span class="dv">4</span>]))<span class="op">/</span>n)</span>
<span id="cb614-5"><a href="a-becsléselmélet-alapjai.html#cb614-5" tabindex="-1"></a></span>
<span id="cb614-6"><a href="a-becsléselmélet-alapjai.html#cb614-6" tabindex="-1"></a>SH_Atlag_ÖtödikMinta</span></code></pre></div>
<pre><code>## 4.558455568470775</code></pre>
<div class="sourceCode" id="cb616"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb616-1"><a href="a-becsléselmélet-alapjai.html#cb616-1" tabindex="-1"></a>SH_Arany_ÖtödikMinta</span></code></pre></div>
<pre><code>## 0.04702127178203499</code></pre>
<p>Nem tűpontos a <span class="math inline">\(SH\)</span> közelítése, de azért <strong>nagyságrendileg látszik, hogy jó nyomon járunk már egy mintavétel alapján is!</strong> :)</p>
<p>Sajnos <strong>hasonló közelítő képleteink a varianciák més mediánok esetén NINCSENEK</strong>. Ott majd más trükkökkel próbáljuk kiszámolni az <span class="math inline">\(SH\)</span>-kat egy mintavétel alapján. De erről majd pár anyaggal később. :)</p>
<p>Most még egy <strong>fontos elnevezés: a <span class="math inline">\(SH^2\)</span>-et gyakran nevezi a szaknyelv a becslőfüggvény VARIANCIÁJÁNAK</strong>. Én nem szeretem ezt az elnevezést, mert könnyű összekeverni a minta vagy éppen a sokasági adatok varianciájával, de sok helyen használják ezt az elnevezést, így fontos tudni! Tehát, ha valahol <strong>olyat olvastok, hogy a mintaátlagok varianciája ennnyi vagy a mintaarányok varianciája amannyi, akkor ott a költő az adott mutatók <span class="math inline">\(SH^2\)</span>-re gonfolt</strong>. Jelölni pedig az elnevezés alapján logikus módon így szokás a dolgot: <span class="math inline">\(SH^2(\hat{\theta})=Var(\hat{\theta})\)</span></p>
<p>Ennek kapcsán talán fontos megemlékezni <strong>összefoglalásként arról, hogy itt a becsléselméletben milyen különböző szórásokkal, illetve varianciákkal találkoztunk</strong>:</p>
<ul>
<li><strong>Sokasági szórás</strong>: A sokaság elemeinek várható eltérése a sokaság átlagától. Jele: <span class="math inline">\(\sigma\)</span>.
<ul>
<li>Négyzete: sokasági variancia, <span class="math inline">\(\sigma^2\)</span></li>
</ul></li>
<li><strong>Korrigálatlan mintaszórás</strong>: Egy db minta elemeinek várható eltérése az egy db mintánk átlagától. Jele: <span class="math inline">\(\sigma^*\)</span>
<ul>
<li>Négyzete: korrigálatlan mintavariancia, <span class="math inline">\((s^*)^2\)</span></li>
</ul></li>
<li><strong>Korrigált mintaszórás</strong>: Ugyan az, mint a korigálatlan mintaszórás, csak <em>torzítatlan</em> becslést ad a valós, sokasági szóródásra. Jele: <span class="math inline">\(s\)</span>
<ul>
<li>Négyzete: korrigált mintavariancia, <span class="math inline">\(s^2\)</span></li>
</ul></li>
<li><strong>Standard hiba</strong>: Sok-sok mintából számolt becslőfüggvény, azaz <span class="math inline">\(\hat{\theta}\)</span> szórása. <em>Torzítatlanság esetén</em> egy konkrét mintából számolt becslőfüggvény eltérése a vizsgált <span class="math inline">\(\theta\)</span> paraméter valós, sokasági értékétől. Jele: <span class="math inline">\(SH(\hat{\theta})\)</span>
<ul>
<li>Négyzete: becslőfüggvény varianciája, <span class="math inline">\(Var(\hat{\theta})\)</span></li>
</ul></li>
</ul>
<div id="a-konzisztens-becslés-fogalma" class="section level3 hasAnchor" number="5.5.1">
<h3><span class="header-section-number">5.5.1</span> A konzisztens becslés fogalma<a href="a-becsléselmélet-alapjai.html#a-konzisztens-becslés-fogalma" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>A standard hibáik formulájából az is kikövetkeztethető a <strong>mintaátlag és mintaarány</strong> becslőfüggvények esetében, hogy ezek <strong>konzisztens becslések is a valós sokasági átlagra, arányra</strong>.</p>
<p>Ugyanis, általánosságban <strong>egy <span class="math inline">\(\hat{\theta}\)</span> becslőfüggvény akkor konzisztens, ha <span class="math inline">\(SH\)</span>-ja, a mintaelemszám (<span class="math inline">\(n\)</span>) növelésével <span class="math inline">\(0\)</span>-ba tart</strong>:<span class="math display">\[\lim_{n \rightarrow \infty}{SH(\hat{\theta})} = 0\]</span></p>
<p>Azaz, a egyre nagyobb a mintaméret, akkor a vizsgált statisztikai mutatónk egy mintából számított értéke (<span class="math inline">\(\hat{\theta}\)</span>) egyre közelebb lesz a mutató valós, sokasági értékéhez (<span class="math inline">\(\theta\)</span>).</p>
<p>Könnyen látható, hogy <strong>mintaelemszám (<span class="math inline">\(n\)</span>) függvényében, mind a mintaátlagok, mind a mintaarányok standard hibái <span class="math inline">\(f(n) \sim \frac{1}{n}\)</span> stílusú hiperbola függvények, amik a végtelenbe tartó <span class="math inline">\(n\)</span> nevező esetén <span class="math inline">\(0\)</span>-ba tartanak</strong>:<span class="math display">\[\lim_{n \rightarrow \infty}{SH(\bar{y})} = \lim_{n \rightarrow \infty}{\frac{\sigma}{\sqrt{n}}} = 0\]</span></p>
<p>és <span class="math display">\[lim_{n \rightarrow \infty}{SH(p)} = \lim_{n \rightarrow \infty}{\sqrt{\frac{P(1-P)}{n}}} = 0\]</span></p>
<p><strong>Rajzoljuk is ki a standard hiba függvényt mondjuk <span class="math inline">\(SH(\bar{y})\)</span> esetében</strong> <span class="math inline">\(n=\{10,20,...,200\}\)</span> elemszámok mellett, és <strong>látni fogjuk a hiperbola alakot</strong>. Bár a dolog nem teljesen tiszta, mert a <span class="math inline">\(0\)</span>-ba tartás sebesség a képlet alapján “<em>gyökös</em>”. :) Az ábrázolást végző Python kód logikája teljesen egyezik azzal, amit a <em>2.1. fejezetben</em> is használtunk.</p>
<div class="sourceCode" id="cb618"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb618-1"><a href="a-becsléselmélet-alapjai.html#cb618-1" tabindex="-1"></a><span class="co"># Üres lista létrehozása a különböző elemszámok mellett vett SH-k tárolására</span></span>
<span id="cb618-2"><a href="a-becsléselmélet-alapjai.html#cb618-2" tabindex="-1"></a>SH_Lista <span class="op">=</span> []</span>
<span id="cb618-3"><a href="a-becsléselmélet-alapjai.html#cb618-3" tabindex="-1"></a><span class="co"># Vizsgált elemszámok listájának létrehozása</span></span>
<span id="cb618-4"><a href="a-becsléselmélet-alapjai.html#cb618-4" tabindex="-1"></a><span class="co"># 10 és 200 közötti egész számok felsoroltatása a &#39;range&#39; függvényben 10-es lépésközzel</span></span>
<span id="cb618-5"><a href="a-becsléselmélet-alapjai.html#cb618-5" tabindex="-1"></a><span class="co"># Felső határ 201 a nyílt intervallum miatt</span></span>
<span id="cb618-6"><a href="a-becsléselmélet-alapjai.html#cb618-6" tabindex="-1"></a>Elemszam_Lista <span class="op">=</span> <span class="bu">range</span>(<span class="dv">10</span>, <span class="dv">201</span>, <span class="dv">10</span>)</span>
<span id="cb618-7"><a href="a-becsléselmélet-alapjai.html#cb618-7" tabindex="-1"></a></span>
<span id="cb618-8"><a href="a-becsléselmélet-alapjai.html#cb618-8" tabindex="-1"></a><span class="co"># Ciklus indítása SH-k számításához</span></span>
<span id="cb618-9"><a href="a-becsléselmélet-alapjai.html#cb618-9" tabindex="-1"></a><span class="cf">for</span> AktualisElemszam <span class="kw">in</span> Elemszam_Lista:</span>
<span id="cb618-10"><a href="a-becsléselmélet-alapjai.html#cb618-10" tabindex="-1"></a>  SH_Lista.append(<span class="bu">round</span>(SokasagiSzoras <span class="op">/</span> np.sqrt(AktualisElemszam), <span class="dv">3</span>))</span>
<span id="cb618-11"><a href="a-becsléselmélet-alapjai.html#cb618-11" tabindex="-1"></a></span>
<span id="cb618-12"><a href="a-becsléselmélet-alapjai.html#cb618-12" tabindex="-1"></a><span class="co"># Vizsgált elemszámok és a mért SH-k data frame-be rendezése</span></span>
<span id="cb618-13"><a href="a-becsléselmélet-alapjai.html#cb618-13" tabindex="-1"></a><span class="co"># Ahol az elemszámok a sorindexek</span></span>
<span id="cb618-14"><a href="a-becsléselmélet-alapjai.html#cb618-14" tabindex="-1"></a>SHData <span class="op">=</span> pd.DataFrame(SH_Lista, columns<span class="op">=</span>[<span class="st">&#39;SH_Átlag&#39;</span>], index <span class="op">=</span> <span class="bu">range</span>(<span class="dv">10</span>, <span class="dv">201</span>, <span class="dv">10</span>))</span>
<span id="cb618-15"><a href="a-becsléselmélet-alapjai.html#cb618-15" tabindex="-1"></a></span>
<span id="cb618-16"><a href="a-becsléselmélet-alapjai.html#cb618-16" tabindex="-1"></a><span class="co"># Ábrázolás a &#39;plot&#39; metódussal: nem kell paraméterezni, mert csak egy oszlopunk van</span></span>
<span id="cb618-17"><a href="a-becsléselmélet-alapjai.html#cb618-17" tabindex="-1"></a>SHData.plot()</span>
<span id="cb618-18"><a href="a-becsléselmélet-alapjai.html#cb618-18" tabindex="-1"></a>plt.show()</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-247-3.png" width="672" /></p>
</div>
</div>
<div id="az-átlagos-négyzetes-hiba-mse-fogalma" class="section level2 hasAnchor" number="5.6">
<h2><span class="header-section-number">5.6</span> Az átlagos négyzetes hiba (<em>MSE</em>) fogalma<a href="a-becsléselmélet-alapjai.html#az-átlagos-négyzetes-hiba-mse-fogalma" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Ugyebár arra jutottunk, hogy egy statisztikai paraméter becslőfüggvénynek a szórása, mint <strong>standard hiba, csak akkor adja meg egy konkrét mintából számolt <span class="math inline">\(\hat{\theta}\)</span> várható eltérését a valós, sokasági <span class="math inline">\(\theta\)</span> értéktől, ha a becslőfüggvény torzítatlan</strong>, mert ekkor egyezik meg <span class="math inline">\(\theta\)</span> a sok-sok mintából számolt <span class="math inline">\(\hat{\theta}\)</span>-ok átlagával, <span class="math inline">\(E(\hat{\theta})\)</span>-val.</p>
<p>Ha nem torzítatlan becslőfüggvényről beszélünk, akkor <strong>manuálisan ki tudjuk számolni a sok-sok mintából megadott <span class="math inline">\(\hat{\theta}\)</span>-ok várható eltérését a valós, sokasági <span class="math inline">\(\theta\)</span>-tól</strong>. <strong>Ez a mutató lesz a <span class="math inline">\(\hat{\theta}\)</span> átlagos négyzetes hibája, angolul Mean Squared Error = MSE</strong>. A számoláshoz simán a klasszikus variancia képletet kell alkalmazni a kövtekező módon: <span class="math display">\[MSE(\hat{\theta})=\frac{\sum_{i=1}^K{(\hat{\theta}_i-\theta)^2}}{K}\]</span></p>
<p>A képletben <span class="math inline">\(K\)</span> a mintavételek száma (nekünk most <span class="math inline">\(10000\)</span>) <span class="math inline">\(\hat{\theta}_i\)</span> egyszerűen az <span class="math inline">\(i\)</span>-edik mintából számolt <span class="math inline">\(\hat{\theta}\)</span> értéke.</p>
<p><strong>Számoljuk is ki az <span class="math inline">\(MSE\)</span>-t, az egyetlen torzított becslőfüggvényre, a korrigálatlan mintavarianciára!</strong> A képletnél muszáj Pythonban a <code>sum</code> függvényt alkalmazni, és “<em>manuálisan</em>” lekódolni a formulát, mivel a beépített <code>std</code> függvénnyel <span class="math inline">\(\theta\)</span> helyett <span class="math inline">\(E(\hat{\theta})\)</span>-hoz viszonyítanánk, és a torzítottság miatt e két érték nem esik most egybe!</p>
<div class="sourceCode" id="cb619"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb619-1"><a href="a-becsléselmélet-alapjai.html#cb619-1" tabindex="-1"></a>MSE_Varianciak <span class="op">=</span> np.<span class="bu">sum</span>((MintaVetelek100Elem.Varianciak <span class="op">-</span> SokasagiVariancia)<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">10000</span></span>
<span id="cb619-2"><a href="a-becsléselmélet-alapjai.html#cb619-2" tabindex="-1"></a></span>
<span id="cb619-3"><a href="a-becsléselmélet-alapjai.html#cb619-3" tabindex="-1"></a>MSE_Varianciak</span></code></pre></div>
<pre><code>## 163460.24046057483</code></pre>
<p>Királyság! Namármost. Ez <strong>a <span class="math inline">\(MSE\)</span> érték</strong> valójában a <strong>becslés kétféje hibájának négyzetes összege</strong>. Konkrétan <span class="math display">\[MSE=SH^2+Bs^2\]</span></p>
<p>Ugyebár itt <strong>egy <span class="math inline">\(\hat{\theta}\)</span> becslőfüggvény eltérését a valós <span class="math inline">\(\theta\)</span>-tól két lépcsőben lehet megközelíteni</strong>:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(SH\)</span>: Mennyivel tér el egy konkrét minta <span class="math inline">\(\hat{\theta}\)</span>-ja a becslések átlagától, <span class="math inline">\(E(\hat{\theta})\)</span>-től.</li>
<li><span class="math inline">\(Bs\)</span>: Mennyivel tér el a becslések átlaga a valós <span class="math inline">\(\theta\)</span>-tól: <span class="math inline">\(Bs = E(\hat{\theta}) - \theta\)</span></li>
</ol>
<p>És ha kiszámoljuk a gyakorlatban, akkor látjuk, hogy az E<span class="math inline">\(MSE\)</span> tényleg <strong>ennek a fenti kétféle hibának az összege</strong>.</p>
<div class="sourceCode" id="cb621"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb621-1"><a href="a-becsléselmélet-alapjai.html#cb621-1" tabindex="-1"></a>Bs_Varianciak <span class="op">=</span> np.mean(MintaVetelek100Elem.Varianciak) <span class="op">-</span> SokasagiVariancia</span>
<span id="cb621-2"><a href="a-becsléselmélet-alapjai.html#cb621-2" tabindex="-1"></a>SH_Varianciak <span class="op">=</span> np.std(MintaVetelek100Elem.Varianciak)</span>
<span id="cb621-3"><a href="a-becsléselmélet-alapjai.html#cb621-3" tabindex="-1"></a></span>
<span id="cb621-4"><a href="a-becsléselmélet-alapjai.html#cb621-4" tabindex="-1"></a>MSE_Varianciak_Összeggel <span class="op">=</span> Bs_Varianciak<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> SH_Varianciak<span class="op">**</span><span class="dv">2</span></span>
<span id="cb621-5"><a href="a-becsléselmélet-alapjai.html#cb621-5" tabindex="-1"></a></span>
<span id="cb621-6"><a href="a-becsléselmélet-alapjai.html#cb621-6" tabindex="-1"></a>[MSE_Varianciak, MSE_Varianciak_Összeggel]</span></code></pre></div>
<pre><code>## [163460.24046057483, 163460.2404605743]</code></pre>
<p>Jé, tényleg jó az összeges logikánk is! :)</p>
<p>Természetesen, ahol <strong>torzítatlan a becslés, ott a <span class="math inline">\(Bs=0\)</span> miatt az <span class="math inline">\(MSE = SH^2\)</span> azonosság áll</strong>. Vegyük <strong>pl. a mintaarányok esetét</strong>.</p>
<div class="sourceCode" id="cb623"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb623-1"><a href="a-becsléselmélet-alapjai.html#cb623-1" tabindex="-1"></a>MSE_Aranyok <span class="op">=</span> np.<span class="bu">sum</span>((MintaVetelek100Elem.Aranyok <span class="op">-</span> SokasagiArany)<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">10000</span></span>
<span id="cb623-2"><a href="a-becsléselmélet-alapjai.html#cb623-2" tabindex="-1"></a>SH_Aranyok <span class="op">=</span> np.std(MintaVetelek100Elem.Aranyok)</span>
<span id="cb623-3"><a href="a-becsléselmélet-alapjai.html#cb623-3" tabindex="-1"></a></span>
<span id="cb623-4"><a href="a-becsléselmélet-alapjai.html#cb623-4" tabindex="-1"></a>[MSE_Aranyok, SH_Aranyok<span class="op">**</span><span class="dv">2</span>]</span></code></pre></div>
<pre><code>## [0.0021789054991602453, 0.0021789028640000706]</code></pre>
<p>ExcellenT! :)</p>
<div id="különböző-becslőfüggvények-összehasonlítása" class="section level3 hasAnchor" number="5.6.1">
<h3><span class="header-section-number">5.6.1</span> Különböző becslőfüggvények összehasonlítása<a href="a-becsléselmélet-alapjai.html#különböző-becslőfüggvények-összehasonlítása" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Az <span class="math inline">\(MSE\)</span>-t kiválóan lehet hasznosítani, mint egy olyan <strong>mérőszámot, amivel választani tudunk egy <span class="math inline">\(\theta\)</span> sokasági paraméterre adott több lehetséges <span class="math inline">\(\hat{\theta}\)</span> becslőfüggvény alternatíva közül</strong>. Kiváló <strong>példa erre az <span class="math inline">\((s^*)^2\)</span> és <span class="math inline">\(s^2\)</span>, mint két alternatív becslőfüggény a sokasági variancia, <span class="math inline">\(\sigma^2\)</span> becslésére</strong>.</p>
<p>Mondhatnánk erre a kérdésre válaszként csípőből azt, hogy <strong>“de hát a torzítatlan becslőfüggvény biztos jobb”</strong>. Nos nem feltétlenül. Mert mi van <strong>ha egy torzított becslés standard hibája annyival kisebb a torzítatlannál, hogy az ellensúlyozza a torzítás mértékét</strong>, és a végén egy “lövés” (azaz <span class="math inline">\(\hat{\theta}\)</span> becslés) a torzított becslőfüggvényből közelebb esik a valós <span class="math inline">\(\theta\)</span>-hoz, mint a torzítatlan becslésből származó “lövés”.</p>
<p>Ezt nagyon jól lehet érzékeltetni az 5. fejezet vaddisznó vadászatos példáján egy másik nézőpontból: <strong>mi van ha a torzítatlan becslésnek akkor a standard hibája, hogy egy konkrét “lövés” (azaz <span class="math inline">\(\hat{\theta}\)</span> becslés) jóval messzebb lesz a valós <span class="math inline">\(\theta\)</span>-tól, mint egy torzított becslőfüggvényből származó becslés?</strong></p>
<center>
<img src="BiasBoarCompare.png" style="width:90.0%" />
</center>
<p><br>Az ábrán látható, hogy <strong>egy enyhén “balra” torzított becslőfüggvényből származó, de kis standard hibájú <span class="math inline">\(\hat{\theta}_i\)</span> becslések még eltalálják a vaddisznót, de a torzítatlan becslések, bár sok-sok mintavétel átlagában nagyon jól működnek, de egy konkrét <span class="math inline">\(\hat{\theta}_i\)</span> lövésnek akkora a standard hibája, hogy nagyon messzire elvéti azt a vaddisznót!</strong></p>
<p>Tehát a fenti jelenség miatt, ha <strong>egy adott <span class="math inline">\(\theta\)</span>-ra több becslőfüggvény közül kell választanunk, akkor azt az <span class="math inline">\(MSE\)</span> alapján</strong> szabad csak megtennünk, mert az egyszerre veszi figyelembe a torzítás mértékét és a standard hibát is.</p>
<p>Lássuk a dolgot a gyakorlatban: <strong>Mi a jobb becslés a sokasági varianciára? A korrigált vagy a korrigálatlan mintavariancia?</strong></p>
<div class="sourceCode" id="cb625"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb625-1"><a href="a-becsléselmélet-alapjai.html#cb625-1" tabindex="-1"></a><span class="co"># Torzított becslés = Korrigálatlan mintavar.</span></span>
<span id="cb625-2"><a href="a-becsléselmélet-alapjai.html#cb625-2" tabindex="-1"></a>Bs_Varianciak <span class="op">=</span> np.mean(MintaVetelek100Elem.Varianciak) <span class="op">-</span> SokasagiVariancia</span>
<span id="cb625-3"><a href="a-becsléselmélet-alapjai.html#cb625-3" tabindex="-1"></a>SH_Varianciak <span class="op">=</span> np.std(MintaVetelek100Elem.Varianciak)</span>
<span id="cb625-4"><a href="a-becsléselmélet-alapjai.html#cb625-4" tabindex="-1"></a></span>
<span id="cb625-5"><a href="a-becsléselmélet-alapjai.html#cb625-5" tabindex="-1"></a>MSE_Varianciak <span class="op">=</span> Bs_Varianciak<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> SH_Varianciak<span class="op">**</span><span class="dv">2</span></span>
<span id="cb625-6"><a href="a-becsléselmélet-alapjai.html#cb625-6" tabindex="-1"></a></span>
<span id="cb625-7"><a href="a-becsléselmélet-alapjai.html#cb625-7" tabindex="-1"></a><span class="co"># Torzítatlan becslés = Korrigált mintavar.</span></span>
<span id="cb625-8"><a href="a-becsléselmélet-alapjai.html#cb625-8" tabindex="-1"></a>SH_KorrVarianciak <span class="op">=</span> np.std(MintaVetelek100Elem.KorrigaltVar)</span>
<span id="cb625-9"><a href="a-becsléselmélet-alapjai.html#cb625-9" tabindex="-1"></a></span>
<span id="cb625-10"><a href="a-becsléselmélet-alapjai.html#cb625-10" tabindex="-1"></a>MSE_KorrVarianciak <span class="op">=</span> <span class="dv">0</span> <span class="op">+</span> SH_KorrVarianciak<span class="op">**</span><span class="dv">2</span></span>
<span id="cb625-11"><a href="a-becsléselmélet-alapjai.html#cb625-11" tabindex="-1"></a></span>
<span id="cb625-12"><a href="a-becsléselmélet-alapjai.html#cb625-12" tabindex="-1"></a>[MSE_Varianciak, MSE_KorrVarianciak]</span></code></pre></div>
<pre><code>## [163460.2404605743, 166433.95684503784]</code></pre>
<p>Hoppá, olybá tűnik, hogy <span class="math inline">\(MSE((s^*)^2) &lt; MSE(s^2)\)</span>, tehát a <strong>nem korrigált mintavariancia van közelebb a valós, sokasági <span class="math inline">\(\sigma^2\)</span>-hez egy “átlagos” mintavétel esetén, hanem a sima korrigálatlan verzió</strong>.<br>
Ugyanakkor az <strong>adatsor bizonytalanságának, szóródásának “rendszeres” alábecslése a legtöbb esetben nagyobb probléma, mint a némileg magasabb standard hiba</strong>. Tehát, <strong>bár összességében, azaz <span class="math inline">\(MSE\)</span>-ben az <span class="math inline">\((s^*)^2\)</span> mintavételi hibája kisebb, mint <span class="math inline">\(s^2\)</span>-nek, de a kisebb hiba iránya “lefelé” van a torzítás miatt</strong>, és ezt nem szeretjük itt most. Inkább <strong>bevállalunk egy valamivel nagyobb, de “szimmetrikus” hibát</strong>.<br>
Így <strong>variancia esetében</strong> felülírjuk az <span class="math inline">\(MSE\)</span> döntését, és a <strong>korrigált mintavarianciát használjuk a legtöbb esetben</strong>. Vagy másképpen fogalmazva azt mondhatjuk, hogy variancia esetén nagyobb súlyt helyezünk <span class="math inline">\(MSE\)</span>-ben a <span class="math inline">\(Bs^2\)</span>-re, mint a <span class="math inline">\(SH^2\)</span>-re, és nem egyenlő mértékben preferáljuk a csökkenésüket.<br>
Pl. az <strong>átlag standard hibájának <span class="math inline">\(\frac{s}{\sqrt{n}}\)</span> elvű közekítésénél ez azért is jogos, mert a korrigálatlan mintaszórás használata esetén egy mintaátlag távolságát a valós, sokasági átlagtól az “átlagos mintavételben” alábecsülnénk, ami azért kellemetlen</strong>. :)</p>
<p>Ha <strong>két torzítatlan becslőfüggvény közül kell választanunk, akkor simán választhatjuk azt, aminek a standard hibája kisebb, hiszen ilyenkor ez egyben azt is jelenti, hogy az <span class="math inline">\(MSE\)</span>-je is kisebb</strong>, mivel <span class="math inline">\(Bs^2=0\)</span>. Ezt hívják úgy is a szakirodalomban, mint a <strong>hatásosság kritériuma: Két becslőfüggvény közül az a hatásosabb, amelynek <span class="math inline">\(SH\)</span>-ja kisebb</strong>. :)</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="eloszlások-és-mintavételezés.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="a-sokasági-átlag-intervallumbecslése.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "night",
"family": "sans",
"size": 1
},
"edit": {
"link": "https://github.com/USERNAME/REPO/edit/BRANCH/04-Becsleselmelet.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf", "_main.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
